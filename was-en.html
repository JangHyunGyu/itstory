<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>ArcherLab IT Story · Web Server Timeline</title>
		<meta name="description" content="Follow the journey from CERN httpd through Tomcat, Spring Boot, Nginx, and serverless platforms to see how web servers kept reinventing request handling." />
		<meta property="og:title" content="ArcherLab IT Story · Web Server Timeline" />
		<meta property="og:description" content="Explore the moments that reshaped backend delivery: the first web daemon, SSL, proxies, servlet containers, lightweight frameworks, caches, and the rise of serverless and Ingress." />
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700;800&family=Space+Grotesk:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500;600&display=swap" rel="stylesheet">
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css">
		<link rel="stylesheet" href="assets/css/style.css">
		<link rel="alternate" hreflang="ko" href="https://itstory.archerlab.dev/was.html" />
		<link rel="alternate" hreflang="en" href="https://itstory.archerlab.dev/was-en.html" />
		<link rel="alternate" hreflang="x-default" href="https://itstory.archerlab.dev/was-en.html" />
		<link rel="canonical" href="https://itstory.archerlab.dev/was-en.html" />
		<script async src="https://www.googletagmanager.com/gtag/js?id=G-EDBPXC8PL7"></script>
		<script defer src="assets/js/ga.js"></script>
	</head>
	<body>
		<div class="page">
			<header class="page__header" role="banner">
				<div class="page__header-left">
					<a class="page__brand" href="https://archerlab.dev" target="_blank" rel="noopener">
						<img src="assets/images/archerlab_mini_logo.png" alt="ArcherLab" class="page__brand-logo" loading="lazy">
						<span class="page__brand-label">ArcherLab Chronicle</span>
					</a>
					<nav class="page__topic-nav" aria-label="Switch topic">
						<a href="index-en.html">Home Hub</a>
						<a href="computers-en.html">Computers Timeline</a>
						<a href="networks-en.html">Networks Timeline</a>
						<a href="databases-en.html">Database Timeline</a>
						<a href="os-en.html">Operating Systems Timeline</a>
									<p class="event-detail__summary">Spring 1.0 offered a lightweight IoC container that replaced heavy EJB stacks for many teams.</p>
							<span class="page__topic-nav-label">Web Making</span>
							<a href="web-en.html" data-topic-role="parent">Web Making Hub</a>
							<a href="web-structure-en.html" data-topic-role="child">Document Structure Timeline</a>
										<p>After critiquing heavyweight J2EE in his book, Rod Johnson demonstrated Spring 1.0 wiring services and DAOs via XML while running unit tests without a full container.</p>
										<p>Teams realised they could keep business logic as plain Java objects while Spring handled transactions and security, kicking off the lightweight container era.</p>
							<a href="web-tools-en.html" data-topic-role="child">Web Tools Timeline</a>
						</div>
										<p>Spring introduced IoC and AOP so dependencies were injected and transactions managed declaratively. Backends stayed slim yet testable, and later modules like Spring MVC, Security, and Boot extended the same ideas.</p>
					</nav>
				</div>
				<nav class="page__nav" aria-label="Page sections">
					<a href="#timeline">View Years</a>
					<a href="#sources">Sources</a>
					<div class="language-switch">
						<label class="sr-only" for="language-select-was">Language</label>
						<select id="language-select-was" data-language-switch>
							<option value="was.html" data-language-code="ko">한국어</option>
							<option value="was-en.html" data-language-code="en" selected>English</option>
									<p class="event-detail__summary">Nginx 1.0 delivered a stable, event-driven proxy that handled huge concurrent loads with low memory.</p>
					</div>
				</nav>
			</header>
										<p>Igor Sysoev announced Nginx 1.0 on the mailing list in April 2011 and called it production ready. Benchmarks showed tens of thousands of concurrent connections on modest hardware.</p>
										<p>Startups used Nginx for static assets and as a reverse proxy in front of their application tiers. Configuration snippets in <code>nginx.conf</code> handled load balancing and caching.</p>
				<section class="timeline-hero" aria-labelledby="timeline-title">
					<div class="timeline-hero__head">
										<p>Nginx’s asynchronous event loop, non-blocking I/O, and configuration-driven routing let teams split backend services without thread-per-connection overhead. The pattern carried forward into microservices and container orchestration.</p>
						<h1 class="timeline-hero__title" id="timeline-title">From static files to global backends: how web servers kept growing</h1>
						<p class="timeline-hero__lede">
							In 1990 a single NeXT machine at CERN ran httpd so colleagues could click a link and read a paper immediately. Tim Berners-Lee showed that a server could read a request, find the right HTML file, and send it back without ceremony.
						</p>
						<p class="timeline-hero__lede">
							Open releases from NCSA and Apache spread that idea to every lab and ISP. Operators soon added SSL, mod_proxy, and LVS to terminate encryption, fan out requests, and keep application logic on its own machines. Servlet specs and Tomcat gave dynamic sites a consistent home for code and sessions.
						</p>
						<p class="timeline-hero__lede">
							Today Nginx, Spring Boot, Lambda, and Kubernetes Ingress minimize manual configuration and turn scaling into an automated routine. Browse the timeline to see the problems engineers faced each year and the solutions they shipped to move the web forward.
						</p>
									<p class="event-detail__summary">Spring Boot 1.0 packaged auto-configuration and embedded servers so teams could ship a single executable JAR.</p>
				</section>

				<section class="timeline-grid" id="timeline" aria-labelledby="timeline-title" aria-describedby="timeline-instructions">
										<p>Pivotal’s Phil Webb demoed <code>spring init --dependencies=web demo</code> and ran <code>DemoApplication</code> seconds later with Tomcat embedded. The audience saw a working service without XML boilerplate.</p>
										<p>Teams replaced sprawling XML with targeted settings in <code>application.properties</code> and shipped executable JARs through their pipelines. Many microservice efforts adopted a “one Spring Boot app per service” approach.</p>
					<section class="timeline-group" aria-labelledby="decade-1990-webserver topic-1990-webserver">
						<header class="timeline-group__head">
										<p>Spring Boot’s starters, auto-configuration, and embedded Tomcat or Jetty collapsed deployment into a single artifact. Backends lined up with CI/CD pipelines, feeding naturally into Spring Cloud and Kubernetes rollouts.</p>
							<h3 class="timeline-group__topic" id="topic-1990-webserver">“Drag the code, run your own server”</h3>
							<p class="timeline-group__summary">CERN, NCSA, and Apache shared their source so anyone could install, modify, and operate a web server on their own machines.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1990-cern-httpd">
								<span class="timeline-event__year">1990</span>
								<span class="timeline-event__label">CERN httpd pilot</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1993-ncsa-httpd">
								<span class="timeline-event__year">1993</span>
									<p class="event-detail__summary">AWS Lambda let developers run code as small functions without managing servers.</p>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1995-apache-httpd">
								<span class="timeline-event__year">1995</span>
										<p>At re:Invent AWS showed a console demo where a developer pasted a function, saved it, and immediately received an endpoint that triggered the code on demand.</p>
										<p>Startups moved login, notifications, and image processing to Lambda, shifting backend work to small event-driven units billed only for execution time.</p>
						</div>
					</section>
										<p>Serverless platforms handled scaling and billing automatically, letting backends focus on logic. Front ends kept static assets on CDNs and called small APIs only when needed.</p>
					<section class="timeline-group" aria-labelledby="decade-1994-infra topic-1994-infra">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1994-infra">1994–1998</p>
							<h3 class="timeline-group__topic" id="topic-1994-infra">“Edge handles the lock, backend handles the logic”</h3>
							<p class="timeline-group__summary">SSL, mod_proxy, and LVS made it normal to terminate security and split traffic at the edge while application servers handled business logic.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1994-ssl">
								<span class="timeline-event__year">1994</span>
								<span class="timeline-event__label">Netscape SSL 2.0 pilot</span>
									<p class="event-detail__summary">Kubernetes Ingress let teams declare L7 routing and TLS in YAML instead of hand-managed proxies.</p>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1996-mod-proxy">
								<span class="timeline-event__year">1996</span>
								<span class="timeline-event__label">Apache mod_proxy arrives</span>
										<p>A 2015 blog post walked through defining <code>host: api.example.com</code> and TLS rules in YAML so traffic automatically flowed to the right service.</p>
										<p>Operations teams stopped managing per-application Nginx instances and wrote cluster-level Ingress rules instead. Deployment pipelines began shipping routing config alongside application code.</p>
								<span class="timeline-event__year">1998</span>
								<span class="timeline-event__label">Linux Virtual Server</span>
										<p>Ingress absorbed L7 routing and TLS into Kubernetes objects. Application containers focused on execution while the platform enforced traffic policies, paving the way for service mesh patterns.</p>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-1990-was topic-1990-was">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1990-was">1997–1999</p>
							<h3 class="timeline-group__topic" id="topic-1990-was">“Requests are objects, sessions are mine”</h3>
							<p class="timeline-group__summary">Servlet specifications and Tomcat containers treated requests as objects and kept session state consistent, laying the groundwork for dynamic sites.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1997-servlet">
								<span class="timeline-event__year">1997</span>
								<span class="timeline-event__label">Servlet 1.0 spec</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1997-httpsession">
								<span class="timeline-event__year">1997</span>
								<span class="timeline-event__label">HttpSession API</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1999-tomcat">
								<span class="timeline-event__year">1999</span>
								<span class="timeline-event__label">Apache Tomcat release</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-2000-was topic-2000-was">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-2000-was">2003</p>
							<h3 class="timeline-group__topic" id="topic-2000-was">“EJB isn’t the only path”</h3>
							<p class="timeline-group__summary">Spring 1.0 showed that lightweight containers could handle transactions and security without heavy EJB stacks.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="2003-spring">
								<span class="timeline-event__year">2003</span>
								<span class="timeline-event__label">Spring 1.0 launch</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-2005-session topic-2005-session">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-2005-session">2005</p>
							<h3 class="timeline-group__topic" id="topic-2005-session">“Throw the session into the cache”</h3>
							<p class="timeline-group__summary">Memcached encouraged teams to share session and query data in memory so multiple application nodes could stay in sync.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="2005-memcached">
								<span class="timeline-event__year">2005</span>
								<span class="timeline-event__label">Memcached goes open source</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-2010-was topic-2010-was">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-2010-was">2011–2015</p>
							<h3 class="timeline-group__topic" id="topic-2010-was">“Configure less, let the platform route”</h3>
							<p class="timeline-group__summary">Nginx, Spring Boot, Lambda, and Ingress combined lightweight proxies, auto-configuration, serverless execution, and cluster routing into the default operating model.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="2011-nginx">
								<span class="timeline-event__year">2011</span>
								<span class="timeline-event__label">Nginx 1.0 stable</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2014-spring-boot">
								<span class="timeline-event__year">2014</span>
								<span class="timeline-event__label">Spring Boot 1.0</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2014-lambda">
								<span class="timeline-event__year">2014</span>
								<span class="timeline-event__label">AWS Lambda launch</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2015-k8s-ingress">
								<span class="timeline-event__year">2015</span>
								<span class="timeline-event__label">Kubernetes Ingress resource</span>
							</button>
						</div>
					</section>
				</section>

				<section class="sources" id="sources" aria-labelledby="sources-title">
					<div class="section__head">
						<h2 id="sources-title">Further reading</h2>
						<p>Specification docs, release notes, and postmortems that reveal which pains web servers and WAS containers were built to solve.</p>
					</div>
					<ul class="source-list">
						<li><a href="https://www.w3.org/History/1991-WWW-NeXT/Implementation/" target="_blank" rel="noopener">W3C History · CERN httpd Implementation Notes</a></li>
						<li><a href="https://archive.ncsa.illinois.edu/General/Internet/wwwserver.html" target="_blank" rel="noopener">NCSA Archives · NCSA HTTPd Web Server</a></li>
						<li><a href="https://httpd.apache.org/ABOUT_APACHE.html" target="_blank" rel="noopener">Apache HTTP Server Project · About Apache HTTP Server</a></li>
						<li><a href="https://web.archive.org/web/19970222044424/http://home.netscape.com/eng/security/SSL_2.html" target="_blank" rel="noopener">Netscape · SSL 2.0 Technical Overview (1994 archive)</a></li>
						<li><a href="https://httpd.apache.org/docs/1.3/mod/mod_proxy.html" target="_blank" rel="noopener">Apache HTTP Server 1.3 Docs · mod_proxy</a></li>
						<li><a href="http://www.linuxvirtualserver.org/history.html" target="_blank" rel="noopener">Linux Virtual Server · Project History</a></li>
						<li><a href="https://docs.oracle.com/javaee/1.3/api/javax/servlet/http/HttpSession.html" target="_blank" rel="noopener">Java Servlet API · HttpSession Interface</a></li>
						<li><a href="https://memcached.org/about" target="_blank" rel="noopener">memcached.org · About Memcached</a></li>
						<li><a href="https://jakarta.ee/specifications/servlet/" target="_blank" rel="noopener">Jakarta EE · Servlet Specification</a></li>
						<li><a href="https://tomcat.apache.org/whichversion.html" target="_blank" rel="noopener">Apache Tomcat · Release History</a></li>
						<li><a href="https://spring.io/blog/2004/03/24/announcing-spring-framework-1-0" target="_blank" rel="noopener">Spring Blog · Announcing Spring Framework 1.0</a></li>
						<li><a href="https://nginx.org/en/announcements.html" target="_blank" rel="noopener">NGINX · Announcements Archive</a></li>
						<li><a href="https://spring.io/blog/2014/04/01/spring-boot-1-0-available-now" target="_blank" rel="noopener">Spring Blog · Spring Boot 1.0 Available Now</a></li>
						<li><a href="https://aws.amazon.com/blogs/aws/aws-lambda-event-driven-code-in-the-cloud/" target="_blank" rel="noopener">AWS News Blog · AWS Lambda Announcement</a></li>
						<li><a href="https://kubernetes.io/blog/2015/11/introducing-ingress-resource/" target="_blank" rel="noopener">Kubernetes Blog · Introducing the Ingress Resource</a></li>
					</ul>
				</section>
			</main>

			<footer class="page__footer" role="contentinfo">
				<p>© 2025 ArcherLab · Stories on how web servers learned to scale.</p>
				<a class="page__footer-link" href="https://archerlab.dev" target="_blank" rel="noopener">archerlab.dev</a>
			</footer>
		</div>

		<div class="modal" id="event-modal" role="dialog" aria-modal="true" hidden>
			<div class="modal__overlay" data-modal-close></div>
			<div class="modal__window" role="document" tabindex="-1">
				<button class="modal__close" type="button" aria-label="Close dialog" data-modal-close>&times;</button>
				<div class="modal__content"></div>
			</div>
		</div>

		<template id="event-1990-cern-httpd">
			<article class="event-detail" aria-labelledby="event-1990-cern-httpd-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1990</p>
					<h2 id="event-1990-cern-httpd-title">CERN httpd pilot</h2>
					<p class="event-detail__summary">The HttpSession API let containers manage cookies and session state so apps could focus on logic.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Servlet 1.0 introduced the <code>HttpSession</code> interface and the <code>getSession()</code> method. Developers used calls like <code>session.setAttribute("cart", items)</code> while the container created session cookies, set expirations, and synced clusters.</p>
						<p>Banks and commerce sites stored login state and shopping carts in HttpSession, showing that stateless HTTP could still deliver personalised flows. Teams no longer needed to write fragile session plumbing by hand.</p>
					</div>
					<div class="event-detail__notes">
						<p>HttpSession supported cookie-based identifiers, URL rewriting, and clustered storage. PHP, ASP, Rails, and other stacks later adopted similar session APIs so frameworks, not developers, managed user state.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1993-ncsa-httpd">
			<article class="event-detail" aria-labelledby="event-1993-ncsa-httpd-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1993</p>
					<h2 id="event-1993-ncsa-httpd-title">NCSA HTTPd release</h2>
					<p class="event-detail__summary">Memcached let multiple application servers share a fast in-memory cache for sessions and hot data.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Memcached started at LiveJournal in 2003 and went public on SourceForge in 2005 with a straightforward TCP protocol built around <code>set</code> and <code>get</code>. Teams pushed sessions and frequently used query results into the cache to ease database load.</p>
						<p>Flickr, YouTube, and Facebook soon shared success stories about using Memcached, making cache clusters a standard scaling move. Sharing the same cache meant any application node could serve a returning user.</p>
					</div>
					<div class="event-detail__notes">
						<p>Memcached gave multiple application servers access to the same in-memory key/value store. Offloading sessions and hot data kept responses quick while allowing horizontal scaling behind the load balancer.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1995-apache-httpd">
			<article class="event-detail" aria-labelledby="event-1995-apache-httpd-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1995</p>
					<h2 id="event-1995-apache-httpd-title">Apache HTTP Server 1.0</h2>
					<p class="event-detail__summary">Apache 1.0 turned the volunteer patch crew into a dependable, modular web server project.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>When NCSA updates slowed in 1995, Brian Behlendorf, Roy Fielding, and fellow contributors opened a shared repository and released Apache 1.0 on December 1. They emphasised that modules could be enabled or disabled as needed and that every patch would be reviewed in public.</p>
						<p>SSL, proxy, and load-balancing modules appeared almost immediately, so ISPs and portals made Apache their default front end. Netcraft surveys soon showed Apache powering most measured sites, demonstrating that open-source infrastructure could lead the market.</p>
					</div>
					<div class="event-detail__notes">
						<p>Apache’s MPM design and configuration system let operators add scripting engines and reverse proxies without touching the core. That made it natural to run Apache at the edge while Tomcat, JBoss, or other application servers handled business logic behind it.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1994-ssl">
			<article class="event-detail" aria-labelledby="event-1994-ssl-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1994</p>
					<h2 id="event-1994-ssl-title">Netscape SSL 2.0 pilot</h2>
					<p class="event-detail__summary">Servlet 1.0 defined a common Java lifecycle for handling HTTP requests and responses.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>On stage a Sun engineer live-coded an <code>HttpServlet</code>, then showed how <code>doGet</code> and <code>doPost</code> could read form data and render a dynamic page immediately after submission.</p>
						<p>Banks and public agencies now had a shared contract for transaction-heavy Java workloads, giving vendors a roadmap for building servlet containers.</p>
					</div>
					<div class="event-detail__notes">
						<p>The servlet spec outlined request and response objects, filters, and lifecycle methods. Developers could write once and deploy anywhere, while container vendors focused on sessions, threading, and security.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1996-mod-proxy">
			<article class="event-detail" aria-labelledby="event-1996-mod-proxy-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1996</p>
					<h2 id="event-1996-mod-proxy-title">Apache mod_proxy arrives</h2>
					<p class="event-detail__summary">Tomcat gave teams an open servlet container that ran WAR files with almost no setup.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>At JavaOne James Duncan Davidson ran <code>startup.sh</code>; the cat logo appeared and a browser rendered a JSP page seconds later. Sun donated the code to the Apache Software Foundation so the implementation would remain open.</p>
						<p>Developers downloaded Tomcat, copied WAR files into <code>webapps</code>, and saw their servlet applications deploy immediately. Open source now anchored the Java middle tier.</p>
					</div>
					<div class="event-detail__notes">
						<p>Tomcat bundled connectors, thread pools, and a JSP compiler, quickly becoming the default development container. Teams matched dev and production environments, and frameworks such as Struts and Spring integrated smoothly. Tomcat’s open model nudged other WAS vendors toward more open stacks.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1998-lvs">
			<article class="event-detail" aria-labelledby="event-1998-lvs-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1998</p>
					<h2 id="event-1998-lvs-title">Linux Virtual Server project</h2>
					<p class="event-detail__summary">Linux Virtual Server introduced kernel-level load balancing without specialised hardware.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>In May 1998 Zhang Wensong announced on a mailing list that he had built kernel patches using IPVS to distribute traffic. A small Linux PC could now split thousands of HTTP connections across several backends.</p>
						<p>Administrators replaced costly hardware load balancers with a few commodity servers running LVS and paired them with Keepalived for virtual IP failover. High availability no longer required proprietary appliances.</p>
					</div>
					<div class="event-detail__notes">
						<p>LVS shipped the IPVS kernel module and <code>ipvsadm</code> tooling for layer 4 distribution. Sticky sessions and health checks meant application servers could scale out while preserving user experience, laying groundwork for HAProxy, Nginx, and cloud load balancers.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1997-httpsession">
			<article class="event-detail" aria-labelledby="event-1997-httpsession-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1997</p>
					<h2 id="event-1997-httpsession-title">HttpSession API</h2>
					<p class="event-detail__summary">“Call <code>getSession()</code> and relax,” the Servlet 1.0 crew assured teams while containers took over cookie and session chores.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>The draft spec included <code>HttpSession</code> and <code>getSession()</code>. Developers wrote <code>session.setAttribute("cart", items)</code> while the container handled cookie issuance, timeouts, and cluster sync.</p>
						<p>Banks and commerce sites used HttpSession to hold logins and shopping carts, finally making stateless HTTP feel personal. Hand-rolled session code started to disappear.</p>
					</div>
					<div class="event-detail__notes">
						<p>The API enabled cookie-based IDs, URL rewriting, and distributed session stores. Other frameworks such as PHP, ASP, and Rails mirrored the approach, leaving WAS platforms in charge of user state while frontends simply sent cookies along.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2005-memcached">
			<article class="event-detail" aria-labelledby="event-2005-memcached-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2005</p>
					<h2 id="event-2005-memcached-title">Memcached goes open source</h2>
					<p class="event-detail__summary">LiveJournal laughed, “Just stash it in RAM,” as Memcached went open source and made shared caches the norm.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Born in 2003, Memcached hit SourceForge in 2005 with the pitch, “Open a TCP port and use <code>set</code>/<code>get</code> to share memory.” Web apps began storing sessions and query results in Memcached, easing database load.</p>
						<p>By 2005 Flickr, YouTube, and Facebook praised the speed boost: “Refreshes stay fast thanks to Memcached.” Running a cache cluster became standard practice for large services.</p>
					</div>
					<div class="event-detail__notes">
						<p>Memcached lets multiple application servers share the same in-memory key-value store. Externalizing session data keeps load balancers free to direct traffic anywhere while retaining state, enabling painless horizontal scaling.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1997-servlet">
			<article class="event-detail" aria-labelledby="event-1997-servlet-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1997</p>
					<h2 id="event-1997-servlet-title">Servlet 1.0 spec</h2>
					<p class="event-detail__summary">“Treat every request as a Java object,” Sun urged when the Servlet 1.0 spec landed with a shared contract.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>At a Sun developer conference the presenter displayed the <code>HttpServlet</code> class. “Put your logic in <code>doGet</code> and <code>doPost</code>,” he said. A live demo showed a servlet reading an order form and rendering fresh HTML.</p>
						<p>Financial institutions responded, “We finally have a standard to serve many concurrent requests.” The Java ecosystem rallied behind shared APIs.</p>
					</div>
					<div class="event-detail__notes">
						<p>The spec defined request and response objects, filters, and lifecycle hooks. Developers could deploy the same code on any compliant container, while vendors focused on threading, security, and session management. JSP, Tomcat, and Spring later layered on top of this foundation.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1999-tomcat">
			<article class="event-detail" aria-labelledby="event-1999-tomcat-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1999</p>
					<h2 id="event-1999-tomcat-title">Apache Tomcat release</h2>
					<p class="event-detail__summary">Apache grinned, “Drop in the WAR, I’ll serve it,” after Sun gifted the Tomcat reference implementation to the community.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>At JavaOne, James Duncan Davidson ran <code>startup.sh</code>. A cat logo flashed on screen, the crowd laughed, and a browser showed JSP rendering live HTML.</p>
						<p>Sun argued, “Standards need open implementations,” and handed Tomcat to Apache. Teams could download it, drop a WAR into <code>webapps</code>, and deploy instantly.</p>
					</div>
					<div class="event-detail__notes">
						<p>Tomcat bundled connectors, thread pools, and a JSP compiler, becoming the default developer WAS. Shared containers aligned dev and prod environments, while Spring and Struts integrated seamlessly. Tomcat's openness encouraged Jetty, JBoss, and others to enter the scene.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2003-spring">
			<article class="event-detail" aria-labelledby="event-2003-spring-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2003</p>
					<h2 id="event-2003-spring-title">Spring 1.0 launch</h2>
					<p class="event-detail__summary">Spring 1.0 whispered, “Keep the beans plain, we’ll wire them,” easing teams away from heavyweight EJB stacks.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Rod Johnson chronicled painful EJB experiences in his book, then told conference attendees, “Keep beans as simple classes and wire them from outside.” Spring 1.0's demo wired services via XML and ran unit tests without a container.</p>
						<p>Enterprise teams embraced the approach: “We get transactions and security without the bloat.” Java backends slimmed down.</p>
					</div>
					<div class="event-detail__notes">
						<p>Spring's IoC container and AOP support injected dependencies and wrapped transactions declaratively. Teams maintained thin service layers with strong test coverage, delivering predictable APIs to frontend partners. Spring MVC, Security, and Boot extended the same principles.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2011-nginx">
			<article class="event-detail" aria-labelledby="event-2011-nginx-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2011</p>
					<h2 id="event-2011-nginx-title">Nginx 1.0 stable</h2>
					<p class="event-detail__summary">Operators bragged, “Half the memory, twice the throughput,” when Nginx 1.0 marked the event-driven proxy era.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>In April 2011 Igor Sysoev wrote a short announcement: “Nginx 1.0 is out. Use it in production.” Benchmarks showed it handling tens of thousands of connections while sipping memory.</p>
						<p>Startups served static files with Nginx and placed it in front of backend apps. Operators tweaked <code>nginx.conf</code> to add load balancing and caching, celebrating how much traffic one server could sustain.</p>
					</div>
					<div class="event-detail__notes">
						<p>Nginx relies on non-blocking I/O and an asynchronous event loop. That architecture encouraged teams to split backend services and let Nginx steer traffic, a pattern later mirrored in microservices and container platforms.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2014-spring-boot">
			<article class="event-detail" aria-labelledby="event-2014-spring-boot-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2014</p>
					<h2 id="event-2014-spring-boot-title">Spring Boot 1.0</h2>
					<p class="event-detail__summary">Spring Boot set "just run it" as the default, spinning up a Spring backend in minutes with embedded Tomcat.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Pivotal engineer Phil Webb ran <code>spring init --dependencies=web demo</code> on stage, opened <code>DemoApplication.java</code>, and launched an app in five seconds with Tomcat already embedded.</p>
						<p>Teams stopped hunting for XML configs. They tuned <code>application.properties</code> and shipped fat JARs through CI/CD. Organizations eyeing microservices embraced the slogan “one service, one Spring Boot app.”</p>
					</div>
					<div class="event-detail__notes">
						<p>Spring Boot offers auto-configuration, starter dependencies, and embedded servers, turning services into self-contained deployables. Backend teams iterate faster, while frontend teams enjoy consistent REST or GraphQL endpoints. Spring Cloud and Kubernetes deployments picked up the same momentum.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2014-lambda">
			<article class="event-detail" aria-labelledby="event-2014-lambda-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2014</p>
					<h2 id="event-2014-lambda-title">AWS Lambda launch</h2>
					<p class="event-detail__summary">“Upload the function, we’ll scale it,” AWS teased at Lambda’s launch and kicked off the serverless wave.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>On the re:Invent stage an AWS presenter said, “You no longer reserve servers.” Developer Alice saved a short function in the console and instantly received a webhook URL ready for traffic.</p>
						<p>Startups shifted logins, notifications, and image processing into Lambda, trimming operations overhead. Backends splintered into small, event-driven functions.</p>
					</div>
					<div class="event-detail__notes">
						<p>Serverless platforms scale and bill automatically. Backend teams focus on business logic while frontends serve static assets from CDNs and call APIs on demand. The model foreshadowed today's event-driven architectures.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2015-k8s-ingress">
			<article class="event-detail" aria-labelledby="event-2015-k8s-ingress-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2015</p>
					<h2 id="event-2015-k8s-ingress-title">Kubernetes Ingress resource</h2>
					<p class="event-detail__summary">Kubernetes engineers said, “Describe the host in YAML and relax,” as Ingress let clusters manage HTTP entry points.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>In fall 2015 the Kubernetes team blogged, “Define TLS and virtual hosts with a few lines of YAML,” and showed <code>host: api.example.com</code> routing traffic automatically.</p>
						<p>Operators stopped running separate Nginx instances per service and shifted routing rules to cluster-level Ingress controllers. Deployment pipelines shipped code and routing policy together.</p>
					</div>
					<div class="event-detail__notes">
						<p>Ingress absorbed layer 7 routing and TLS termination into Kubernetes objects, reinforcing the line between application runtime and platform traffic control. Spring Boot or Tomcat containers now rely on Ingress controllers and service meshes for modern traffic patterns.</p>
					</div>
				</section>
			</article>
		</template>

		<button type="button" class="scroll-top" data-scroll-top aria-label="Scroll to top" hidden>↑</button>

		<script src="assets/js/main.js" defer></script>
		<script type="text/javascript" src="https://wcs.pstatic.net/wcslog.js"></script>
		<script type="text/javascript">
			if (!window.wcs_add) window.wcs_add = {};
			window.wcs_add["wa"] = "134f4c428765360";
			if (window.location.protocol !== 'file:' && window.wcs) {
				wcs_do();
			}
		</script>
	</body>
</html>
