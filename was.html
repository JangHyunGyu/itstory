<!DOCTYPE html>
<html lang="ko">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>ArcherLab IT Story · 웹 서버 연대기</title>
		<meta name="description" content="CERN httpd에서 Tomcat, Spring Boot, 서버리스까지 웹 서버(WAS)의 진화를 사건 중심으로 정리했습니다." />
		<meta property="og:title" content="ArcherLab IT Story · Web Server Timeline" />
		<meta property="og:description" content="첫 웹 서버부터 Nginx, Spring Boot, Lambda, Ingress까지 백엔드 요청 흐름을 바꾼 순간을 따라가 보세요." />
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700;800&family=Space+Grotesk:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500;600&display=swap" rel="stylesheet">
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css">
		<link rel="stylesheet" href="assets/css/style.css">
		<link rel="alternate" hreflang="ko" href="https://itstory.archerlab.dev/was.html" />
		<link rel="alternate" hreflang="en" href="https://itstory.archerlab.dev/was-en.html" />
		<link rel="alternate" hreflang="x-default" href="https://itstory.archerlab.dev/was-en.html" />
		<script async src="https://www.googletagmanager.com/gtag/js?id=G-MTBCHM8DYM"></script>
		<script src="assets/js/ga.js"></script>
	</head>
	<body>
		<div class="page">
			<header class="page__header" role="banner">
				<div class="page__header-left">
					<a class="page__brand" href="https://archerlab.dev" target="_blank" rel="noopener">
						<img src="assets/images/archerlab_mini_logo.png" alt="ArcherLab" class="page__brand-logo" loading="lazy">
						<span class="page__brand-label">ArcherLab Chronicle</span>
					</a>
					<nav class="page__topic-nav" aria-label="주제 전환">
						<a href="index.html">홈 허브</a>
						<a href="networks.html">네트워크 연대기</a>
						<a href="computers.html">컴퓨터 연대기</a>
						<div class="page__topic-nav-group" role="group" aria-label="웹 제작 연대기">
							<span class="page__topic-nav-label">웹 제작 연대기</span>
							<a href="web.html" data-topic-role="parent">웹 제작 연대기 허브</a>
							<a href="web-structure.html" data-topic-role="child">웹 문서 설계 연대기</a>
							<a href="web-styling.html" data-topic-role="child">스타일링 진화 연대기</a>
							<a href="web-interaction.html" data-topic-role="child">브라우저 인터랙션 연대기</a>
							<a href="web-tools.html" data-topic-role="child">웹 제작 도구 연대기</a>
						</div>
						<a href="was.html" class="is-current">웹 서버 연대기</a>
						<a href="databases.html">데이터베이스 연대기</a>
					</nav>
				</div>
				<nav class="page__nav" aria-label="섹션 탐색">
					<a href="#timeline">연도 보기</a>
					<a href="#sources">참고</a>
					<div class="language-switch">
						<label class="sr-only" for="language-select-was">언어 선택</label>
						<select id="language-select-was" data-language-switch>
							<option value="was.html" data-language-code="ko" selected>한국어</option>
							<option value="was-en.html" data-language-code="en">English</option>
						</select>
					</div>
				</nav>
			</header>

			<main class="page__main" id="main" role="main">
				<section class="timeline-hero" aria-labelledby="timeline-title">
					<div class="timeline-hero__head">
						<p class="hero__eyebrow">Web Server Story for Backend Builders</p>
						<h1 class="timeline-hero__title" id="timeline-title">서블릿부터 서버리스까지, 웹 서버가 요청을 책임져 온 방법을 따라가세요</h1>
						<p class="timeline-hero__lede">
							처음에는 정적 HTML을 돌려주던 웹 서버가 “사용자마다 다른 응답을 보내 주세요”라는 요구를 듣는 순간부터 이야기가 달라졌습니다.
							서블릿 사양이 요청·응답 흐름을 정리했고, Tomcat과 같은 컨테이너가 세션과 스레드를 맡으면서 운영팀의 삶이 조금씩 바뀌었습니다.
						</p>
						<p class="timeline-hero__lede">
							이 타임라인에서는 CERN httpd 같은 초창기 웹 서버, SSL로 연결을 암호화한 순간, mod_proxy와 LVS로 앞단을 분리한 전략, HttpSession과 Memcached로 상태를 공유한 기법, 웹 서버(WAS) 컨테이너의 탄생, 프레임워크의 경량화, Nginx와 서버리스가 가져온 배포 혁신까지 이어집니다.
							웹 연대기에서 만난 사건과 연결되어 있으니, 프론트엔드와 서버가 어떻게 역할을 나눴는지도 함께 돌아보세요.
						</p>
					</div>
				</section>

				<section class="timeline-grid" id="timeline" aria-labelledby="timeline-title" aria-describedby="timeline-instructions">
					<p class="timeline-grid__instructions sr-only" id="timeline-instructions">연도 버튼을 누르면 새 창 없이 팝업 대화 상자가 열리고, 그 자리에서 자세한 이야기를 이어서 읽을 수 있습니다.</p>

					<section class="timeline-group" aria-labelledby="decade-1990-webserver topic-1990-webserver">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1990-webserver">1990–1995</p>
							<h3 class="timeline-group__topic" id="topic-1990-webserver">첫 웹 서버와 오픈소스 확산</h3>
							<p class="timeline-group__summary">팀 버너스-리가 만든 CERN httpd는 링크와 HTML을 이해하는 첫 웹 서버였고, NCSA HTTPd와 Apache HTTP Server가 잇달아 공개되며 누구나 내려받아 커뮤니티와 함께 고칠 수 있는 오픈소스 서버 붐이 일었습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1990-cern-httpd">
								<span class="timeline-event__year">1990</span>
								<span class="timeline-event__label">CERN httpd 시범 운영</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1993-ncsa-httpd">
								<span class="timeline-event__year">1993</span>
								<span class="timeline-event__label">NCSA HTTPd 공개</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1995-apache-httpd">
								<span class="timeline-event__year">1995</span>
								<span class="timeline-event__label">Apache HTTP Server 1.0</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-1994-infra topic-1994-infra">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1994-infra">1994–1998</p>
							<h3 class="timeline-group__topic" id="topic-1994-infra">보안과 트래픽 제어의 토대</h3>
							<p class="timeline-group__summary">SSL로 암호화된 연결을 열고, Apache mod_proxy와 Linux Virtual Server 같은 도구로 프록시와 로드밸런싱을 일반화하며 “웹 서버와 애플리케이션 서버를 나눠 운영한다”는 시대가 열렸습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1994-ssl">
								<span class="timeline-event__year">1994</span>
								<span class="timeline-event__label">Netscape SSL 2.0 시범 적용</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1996-mod-proxy">
								<span class="timeline-event__year">1996</span>
								<span class="timeline-event__label">Apache mod_proxy 도입</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1998-lvs">
								<span class="timeline-event__year">1998</span>
								<span class="timeline-event__label">Linux Virtual Server 프로젝트</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-1990-was topic-1990-was">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1990-was">1997–1999</p>
							<h3 class="timeline-group__topic" id="topic-1990-was">서블릿과 컨테이너의 출발선</h3>
							<p class="timeline-group__summary">서버가 요청을 객체로 다루고, 여러 사용자의 세션을 안전하게 관리할 수 있게 하려는 시도가 이어졌습니다. 서블릿 사양이 규칙을 만들고, Tomcat이 누구나 돌려볼 수 있는 컨테이너를 제공했습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1997-servlet">
								<span class="timeline-event__year">1997</span>
								<span class="timeline-event__label">Servlet 1.0 사양</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1997-httpsession">
								<span class="timeline-event__year">1997</span>
								<span class="timeline-event__label">HttpSession 표준화</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1999-tomcat">
								<span class="timeline-event__year">1999</span>
								<span class="timeline-event__label">Apache Tomcat 공개</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-2000-was topic-2000-was">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-2000-was">2003</p>
							<h3 class="timeline-group__topic" id="topic-2000-was">경량 프레임워크의 등장</h3>
							<p class="timeline-group__summary">EJB 중심의 무거운 구조 대신, 단순 자바 클래스로 구성해도 트랜잭션과 보안을 다룰 수 있다는 실험이 Spring 1.0에서 현실이 됐습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="2003-spring">
								<span class="timeline-event__year">2003</span>
								<span class="timeline-event__label">Spring 1.0 발표</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-2005-session topic-2005-session">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-2005-session">2005</p>
							<h3 class="timeline-group__topic" id="topic-2005-session">세션 공유와 캐시의 시대</h3>
							<p class="timeline-group__summary">Memcached 같은 인메모리 캐시가 세션과 데이터를 외부 저장소에 보관하는 방식을 확산시키며 다중 WAS를 손쉽게 확장할 수 있는 토대를 마련했습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="2005-memcached">
								<span class="timeline-event__year">2005</span>
								<span class="timeline-event__label">Memcached 공개</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-2010-was topic-2010-was">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-2010-was">2011–2015</p>
							<h3 class="timeline-group__topic" id="topic-2010-was">프록시, 자동 설정, 서버리스, 클러스터 게이트웨이</h3>
							<p class="timeline-group__summary">Nginx가 가벼운 프록시 전략을 증명했고, Spring Boot는 설정을 줄였으며, AWS Lambda는 아예 서버를 관리하지 않는 방식을 제시했습니다. Kubernetes Ingress는 컨테이너 클러스터에서 HTTP 트래픽을 일관되게 돌보는 관문으로 자리 잡았습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="2011-nginx">
								<span class="timeline-event__year">2011</span>
								<span class="timeline-event__label">Nginx 1.0 안정화</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2014-spring-boot">
								<span class="timeline-event__year">2014</span>
								<span class="timeline-event__label">Spring Boot 1.0</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2014-lambda">
								<span class="timeline-event__year">2014</span>
								<span class="timeline-event__label">AWS Lambda 출시</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2015-k8s-ingress">
								<span class="timeline-event__year">2015</span>
								<span class="timeline-event__label">Kubernetes Ingress 리소스</span>
							</button>
						</div>
					</section>
				</section>

				<section class="sources" id="sources" aria-labelledby="sources-title">
					<div class="section__head">
						<h2 id="sources-title">참고 자료</h2>
						<p>사양 문서, 배포 공지, 그리고 운영팀의 회고를 모았습니다. 원문을 읽어 보면 웹 서버(WAS)가 어떤 문제를 해결하려고 태어났는지 더 분명하게 들어옵니다.</p>
					</div>
					<ul class="source-list">
						<li><a href="https://www.w3.org/History/1991-WWW-NeXT/Implementation/" target="_blank" rel="noopener">W3C History · CERN httpd Implementation Notes</a></li>
						<li><a href="https://archive.ncsa.illinois.edu/General/Internet/wwwserver.html" target="_blank" rel="noopener">NCSA Archives · NCSA HTTPd Web Server</a></li>
						<li><a href="https://httpd.apache.org/ABOUT_APACHE.html" target="_blank" rel="noopener">Apache HTTP Server Project · About Apache HTTP Server</a></li>
						<li><a href="https://web.archive.org/web/19970222044424/http://home.netscape.com/eng/security/SSL_2.html" target="_blank" rel="noopener">Netscape · SSL 2.0 Technical Overview (1994 아카이브)</a></li>
						<li><a href="https://httpd.apache.org/docs/1.3/mod/mod_proxy.html" target="_blank" rel="noopener">Apache HTTP Server 1.3 Docs · mod_proxy</a></li>
						<li><a href="http://www.linuxvirtualserver.org/history.html" target="_blank" rel="noopener">Linux Virtual Server · Project History</a></li>
						<li><a href="https://docs.oracle.com/javaee/1.3/api/javax/servlet/http/HttpSession.html" target="_blank" rel="noopener">Java Servlet API · HttpSession Interface</a></li>
						<li><a href="https://memcached.org/about" target="_blank" rel="noopener">memcached.org · About Memcached</a></li>
						<li><a href="https://jakarta.ee/specifications/servlet/" target="_blank" rel="noopener">Jakarta EE · Servlet Specification</a></li>
						<li><a href="https://tomcat.apache.org/whichversion.html" target="_blank" rel="noopener">Apache Tomcat · Release History</a></li>
						<li><a href="https://spring.io/blog/2004/03/24/announcing-spring-framework-1-0" target="_blank" rel="noopener">Spring Blog · Announcing Spring Framework 1.0</a></li>
						<li><a href="https://nginx.org/en/announcements.html" target="_blank" rel="noopener">NGINX · Announcements Archive</a></li>
						<li><a href="https://spring.io/blog/2014/04/01/spring-boot-1-0-available-now" target="_blank" rel="noopener">Spring Blog · Spring Boot 1.0 Available Now</a></li>
						<li><a href="https://aws.amazon.com/blogs/aws/aws-lambda-event-driven-code-in-the-cloud/" target="_blank" rel="noopener">AWS News Blog · AWS Lambda Announcement</a></li>
						<li><a href="https://kubernetes.io/blog/2015/11/introducing-ingress-resource/" target="_blank" rel="noopener">Kubernetes Blog · Introducing the Ingress Resource</a></li>
					</ul>
				</section>
			</main>

			<footer class="page__footer" role="contentinfo">
				<p>© 2025 ArcherLab · Stories on how web servers learned to scale.</p>
				<a class="page__footer-link" href="https://archerlab.dev" target="_blank" rel="noopener">archerlab.dev</a>
			</footer>
		</div>

		<div class="modal" id="event-modal" role="dialog" aria-modal="true" hidden>
			<div class="modal__overlay" data-modal-close></div>
			<div class="modal__window" role="document" tabindex="-1">
				<button class="modal__close" type="button" aria-label="레이어 닫기" data-modal-close>&times;</button>
				<div class="modal__content"></div>
			</div>
		</div>

		<template id="event-1990-cern-httpd">
			<article class="event-detail" aria-labelledby="event-1990-cern-httpd-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1990</p>
					<h2 id="event-1990-cern-httpd-title">CERN httpd 시범 운영</h2>
					<p class="event-detail__summary">팀 버너스-리는 스위스 CERN 연구소에서 HTML과 HTTP를 처리하는 첫 웹 서버인 CERN httpd를 구축해 연구자들이 내부 문서를 링크로 주고받게 했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>1990년 말, 버너스-리는 NeXT 컴퓨터 한 대에 <code>httpd</code> 데몬을 띄우고 “브라우저가 GET을 보내면 여기서 HTML 파일을 찾아 돌려줘요”라고 동료에게 설명했습니다. CERN 인트라넷에 첫 페이지가 열리자, 연구자들은 새 문서를 올릴 때마다 링크를 달아 서로의 실험 노트를 연결했습니다.</p>
						<p>초기 소스는 연구소 내부에서만 공유됐지만, 1991년 여름에는 외부 메일링 리스트에 배포되어 다른 연구기관도 같은 서버를 시험하기 시작했습니다. “HTTP는 가볍고 HTML은 쓰기 쉽다”는 입소문이 퍼지면서 웹 서버라는 개념이 현실이 되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>CERN httpd는 정적 파일을 서비스했지만, 디렉토리 리스팅과 간단한 실행 스크립트를 지원해 이후 CGI가 자리 잡는 발판이 되었습니다. “요청을 받아 해석한 뒤 응답을 돌려준다”는 서버의 기본 틀이 이때 마련되었고, 훗날 WAS가 등장해 로직을 맡을 수 있었던 것도 이 구조 덕분입니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1993-ncsa-httpd">
			<article class="event-detail" aria-labelledby="event-1993-ncsa-httpd-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1993</p>
					<h2 id="event-1993-ncsa-httpd-title">NCSA HTTPd 공개</h2>
					<p class="event-detail__summary">일리노이 NCSA 팀은 누구나 다운로드해 쓸 수 있는 HTTP 서버를 공개하며 대학과 기업에 웹을 빠르게 퍼뜨렸습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>마크 안드리센과 에릭 빈나는 Mosaic 브라우저를 만들면서 “서버도 쉽게 설치할 수 있게 하자”고 결정했습니다. 1993년 11월, 그들은 <code>httpd_1.0.tar.Z</code> 파일을 FTP에 올리고 설치 방법을 README로 안내했습니다. 대학 연구실과 커뮤니티는 하루가 멀다 하고 패치를 올려 기능을 보강했습니다.</p>
						<p>NCSA HTTPd는 접근 제어, 로그, CGI 훅을 내장해 상용 서비스에도 적합했습니다. 넷스케이프는 이 코드를 바탕으로 상업용 서버를 출시했고, Apache httpd 프로젝트도 NCSA HTTPd의 패치 킷에서 출발했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>오픈소스 HTTP 서버가 널리 쓰이면서 “서버는 누구나 설치하고 고칠 수 있다”는 문화가 탄생했습니다. 이후 Apache httpd가 시장을 장악하고, 그 위에 CGI와 모듈이 얹히며 웹 애플리케이션 서버가 맡는 역할과 프록시·정적 서버의 경계가 명확해졌습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1995-apache-httpd">
			<article class="event-detail" aria-labelledby="event-1995-apache-httpd-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1995</p>
					<h2 id="event-1995-apache-httpd-title">Apache HTTP Server 1.0</h2>
					<p class="event-detail__summary">NCSA 패치 모임에서 출발한 Apache HTTP Server 1.0이 공개되면서 커뮤니티 주도의 모듈형 웹 서버가 표준으로 자리잡았습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>1995년 초, NCSA httpd의 유지보수가 느려지자 브라이언 벨렌도프와 로이 필딩은 패치 기여자들을 모아 “아파치(Apache) 그룹”을 만들고 공동 저장소를 열었습니다. 같은 해 12월 1.0 버전을 발표하며 “모듈 시스템으로 필요한 기능만 켜고 끄세요”라고 안내했고, 전 세계 운영자들이 메일링 리스트에서 즉시 피드백을 주고받았습니다.</p>
						<p>SSL, 프록시, 로드밸런싱 모듈이 빠르게 추가되면서 아파치는 ISP와 포털의 기본 선택지가 되었습니다. 넷크래프트 통계는 “웹 서버 시장의 50% 이상이 아파치”라는 사실을 반복적으로 보여 주었고, 오픈소스가 상업적 배포와 어깨를 나란히 할 수 있다는 자신감을 심어 주었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Apache는 MPM, 모듈 구조, 설정 파일을 통해 웹 서버를 확장 가능하게 만들었습니다. 이후 CGI와 mod_php 같은 동적 모듈이 늘어나며 WAS와 웹 서버의 경계가 분명해졌고, 톰캣·JBoss 같은 애플리케이션 서버를 앞단 아파치가 리버스 프록시로 묶는 아키텍처가 업계 표준이 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1994-ssl">
			<article class="event-detail" aria-labelledby="event-1994-ssl-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1994</p>
					<h2 id="event-1994-ssl-title">Netscape SSL 2.0 시범 적용</h2>
					<p class="event-detail__summary">넷스케이프는 Secure Sockets Layer를 적용한 브라우저·서버 베타를 배포하며 “웹에서도 안전한 결제를 하자”는 목표를 내걸었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>1994년 넷스케이프 엔지니어 팀은 SSL 2.0 프로토콜 초안을 만들고, Navigator와 Commerce 서버 베타 버전에 “https://” 실험 기능을 넣었습니다. 시연에서는 브라우저 주소창에 자물쇠 아이콘이 나타나고, 신용카드 정보가 암호화되어 전송되는 모습을 보여주었습니다.</p>
						<p>전자상거래를 준비하던 기업들은 “고객의 카드 정보를 보호할 수 있다면 웹 결제를 열어 보자”고 반응했고, 은행과 결제사도 공개키 인증서와 루트 CA 체계를 논의하기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>SSL은 TCP 위에 암호화, 무결성, 인증 계층을 더해 HTTP 통신을 보호했습니다. 이후 1996년 SSL 3.0, 1999년 TLS 1.0으로 이어지며 오늘날 HTTPS가 기본이 되었습니다. 웹 서버는 인증서 관리를 맡고, WAS는 민감한 데이터를 평문으로 다루지 않아도 되면서 보안 책임이 명확히 나뉘게 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1996-mod-proxy">
			<article class="event-detail" aria-labelledby="event-1996-mod-proxy-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1996</p>
					<h2 id="event-1996-mod-proxy-title">Apache mod_proxy 도입</h2>
					<p class="event-detail__summary">Apache HTTP Server는 mod_proxy 모듈을 도입해 리버스 프록시, 캐시, 로드밸런싱을 모듈 한 개로 구성할 수 있게 만들었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>1996년 아파치 코어 팀은 1.1 릴리스 노트에 “mod_proxy가 들어갑니다. 다른 서버로 요청을 넘기거나 캐시 서버를 만들 수 있어요.”라고 적었습니다. 운영자는 <code>ProxyPass</code> 지시어를 몇 줄 추가해 백엔드 CGI나 애플리케이션 서버로 트래픽을 전달할 수 있었습니다.</p>
						<p>호스팅 업체는 정적 콘텐츠는 아파치가 직접 처리하고, 동적 요청은 별도로 관리되는 애플리케이션 서버로 전달하는 패턴을 빠르게 채택했습니다. SSL 종료, 접근 제어, 캐시 정책을 모든 요청 앞단에서 제어할 수 있게 된 것입니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>mod_proxy는 리버스 프록시를 설정 파일로 정의할 수 있게 했고, 이후 mod_proxy_balancer, mod_jk 같은 확장 모듈이 등장해 WAS(Tomcat, JBoss, WebLogic)와의 연동을 표준화했습니다. 프론트 웹 서버와 백엔드 애플리케이션 서버를 분리하는 3계층 구조가 실무 표준이 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1998-lvs">
			<article class="event-detail" aria-labelledby="event-1998-lvs-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1998</p>
					<h2 id="event-1998-lvs-title">Linux Virtual Server 프로젝트</h2>
					<p class="event-detail__summary">중국의 장원송은 Linux Virtual Server를 공개해 리눅스 커널에서 L4 로드밸런싱을 구현했고, 저비용으로 대규모 트래픽을 분산할 수 있는 길을 열었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>1998년 5월 장원송은 메일링 리스트에 “리눅스 커널에서 IPVS를 이용해 여러 서버로 트래픽을 분산시키는 패치를 만들었습니다”라며 LVS 프로젝트를 발표했습니다. 간단한 라스베리파이 사이즈의 PC가 수천 개의 HTTP 연결을 여러 대의 백엔드로 나눠 주는 데 성공했습니다.</p>
						<p>운영자들은 값비싼 하드웨어 대신 리눅스 박스 두세 대를 엮어 고가용성 로드밸런서를 구성했고, Keepalived 같은 도구와 결합해 가상 IP를 이용한 이중화까지 구현했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>LVS는 IPVS 모듈과 ipvsadm 유틸리티로 네트워크 계층에서 요청을 분산시켰습니다. 세션 스티키, 헬스 체크가 더해지면서 WAS 인스턴스를 여러 대로 늘려도 사용자 경험을 유지할 수 있었고, 이후 HAProxy, Nginx, 클라우드 로드밸런서가 이어 받는 분산 구조의 기초가 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1997-httpsession">
			<article class="event-detail" aria-labelledby="event-1997-httpsession-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1997</p>
					<h2 id="event-1997-httpsession-title">HttpSession 표준화</h2>
					<p class="event-detail__summary">Servlet 1.0 사양은 `HttpSession` API를 정의해, 쿠키와 세션 저장소를 컨테이너가 일괄 관리하도록 표준화했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>서블릿 1.0 초안에는 <code>HttpSession</code> 인터페이스와 <code>getSession()</code> 메서드가 포함돼 있었습니다. 개발자는 `session.setAttribute("cart", items)` 처럼 키-값을 저장하고, 컨테이너는 세션 쿠키 생성과 타임아웃, 클러스터 동기화를 맡았습니다.</p>
						<p>은행·커머스 사이트는 로그인 상태와 장바구니를 HttpSession에 저장하며 “HTTP는 무상태지만, 우리 애플리케이션은 사용자를 기억한다”는 경험을 구현했습니다. 복잡한 세션 관리 코드를 직접 작성할 필요가 줄어든 순간입니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>HttpSession은 쿠키 기반 세션 ID, URL 리라이팅, 분산 세션 스토리지 등 다양한 확장 전략을 지원했습니다. 이후 PHP, ASP, Rails 등도 비슷한 세션 API를 제공하며 WAS와 프레임워크가 사용자 상태를 책임지고, 프론트엔드는 쿠키만 전달하는 구조가 확산되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2005-memcached">
			<article class="event-detail" aria-labelledby="event-2005-memcached-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2005</p>
					<h2 id="event-2005-memcached-title">Memcached 공개</h2>
					<p class="event-detail__summary">LiveJournal는 Memcached를 오픈소스로 공개해 세션과 캐시를 네트워크 분산 메모리에 저장하는 방식을 대중화했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>2003년 LiveJournal에서 탄생한 Memcached는 2005년 소스포지에 공개되며 “TCP 포트를 열고 <code>set</code>/<code>get</code> 명령으로 메모리를 공유하세요”라는 간단한 API를 제시했습니다. 많은 웹 서비스가 세션과 쿼리 결과를 Memcached에 저장해 DB 부하를 줄이기 시작했습니다.</p>
						<p>2005년부터 Flickr, YouTube, Facebook 등이 “새로고침을 눌러도 빠른 이유는 Memcached 덕분입니다”라고 발표하면서, 캐시 클러스터를 운영하는 방식이 대규모 서비스의 필수 전략이 되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Memcached는 키-값 인메모리 저장소로, 애플리케이션 서버 여러 대에서 같은 캐시를 공유하게 해 줍니다. 세션 데이터를 외부 캐시에 저장하면 로드밸런서가 어느 WAS로 보내든 상태를 유지할 수 있고, 백엔드는 읽기 부하를 줄이며 수평 확장을 쉽게 할 수 있습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1997-servlet">
			<article class="event-detail" aria-labelledby="event-1997-servlet-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1997</p>
					<h2 id="event-1997-servlet-title">Servlet 1.0 사양</h2>
					<p class="event-detail__summary">Sun은 자바 서블릿 사양을 발표해 “HTTP 요청을 클래스로 처리하자”는 공통 규칙을 제시했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Sun 개발자 회의에서 발표자는 <code>HttpServlet</code> 클래스를 띄우며 “doGet과 doPost 안에서 필요한 일을 하세요”라고 설명했습니다. 시연에서 사용자가 폼을 제출하자, 서블릿이 주문 데이터를 읽고 새로운 HTML을 만들어 돌려줬습니다.</p>
						<p>은행과 공공기관은 “동시에 많은 요청을 다루는 표준이 드디어 생겼다”며 서블릿 컨테이너 도입을 검토했습니다. 자바 진영은 공용 API를 중심으로 WAS를 발전시킬 발판을 마련했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>서블릿 사양은 요청·응답 객체, 필터, 라이프사이클 메서드 같은 개념을 정의했습니다. 덕분에 개발자는 어떤 컨테이너에서 실행하든 같은 코드를 사용할 수 있었고, WAS 벤더는 세션, 스레드, 보안 같은 공통 기능을 책임지게 되었습니다. 이는 이후 JSP, Tomcat, Spring 같은 기술이 함께 돌아가게 만든 토대였습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1999-tomcat">
			<article class="event-detail" aria-labelledby="event-1999-tomcat-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1999</p>
					<h2 id="event-1999-tomcat-title">Apache Tomcat 공개</h2>
					<p class="event-detail__summary">Sun은 서블릿·JSP 레퍼런스 구현을 Apache 재단에 기증하며 Tomcat을 오픈소스로 공개했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>자바원 행사장에서 제임스 던컨 데이비슨은 노트북을 열고 <code>startup.sh</code>를 실행했습니다. 콘솔에 고양이 로고가 뜨자 청중이 웃었고, 곧바로 브라우저에서 JSP가 새 HTML을 만들어 응답하는 장면이 재현됐습니다.</p>
						<p>Sun은 “표준은 개방형 구현이 있어야 널리 쓰입니다”라며 코드를 Apache에 넘겼습니다. 개발자들은 Tomcat을 내려받아 <code>webapps</code> 폴더에 WAR 파일을 복사하는 것만으로 서블릿 애플리케이션을 배포할 수 있게 됐습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Tomcat은 커넥터, 스레드 풀, JSP 컴파일러를 내장해 개발용 WAS의 사실상 표준이 되었습니다. 덕분에 팀은 동일한 컨테이너 위에서 개발·운영 환경을 맞출 수 있었고, 이후 Spring, Struts 같은 프레임워크와 자연스럽게 통합되었습니다. Tomcat의 오픈소스 모델은 Jetty, JBoss 등 다른 WAS의 등장을 자극했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2003-spring">
			<article class="event-detail" aria-labelledby="event-2003-spring-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2003</p>
					<h2 id="event-2003-spring-title">Spring 1.0 발표</h2>
					<p class="event-detail__summary">Spring 1.0은 “EJB 없이도 견고한 서버를 만들 수 있다”는 해법을 제시하며 자바 백엔드 구조를 가볍게 바꿨습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Rod Johnson은 《Expert One-on-One J2EE》에서 무거운 EJB 사용기를 털어놓은 뒤, 컨퍼런스에서 “객체를 단순 자바 클래스로 유지하고 외부에서 주입하면 됩니다”라며 Spring 1.0을 선보였습니다.</p>
						<p>데모에서는 XML 설정으로 서비스 객체와 DAO를 연결하고, 테스트에서는 컨테이너 없이도 단위 테스트가 돌아갔습니다. 기업 개발팀은 “경량 컨테이너로도 트랜잭션과 보안을 처리할 수 있네”라며 도입을 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Spring은 IoC 컨테이너와 AOP로 의존성을 주입하고 트랜잭션을 선언적으로 관리하게 했습니다. 덕분에 백엔드는 얇은 서비스 계층을 유지하면서도 확장성과 테스트 용이성을 갖출 수 있었고, 프론트엔드는 안정적인 API를 기대할 수 있었습니다. 이후 Spring MVC, Spring Security, Spring Boot가 같은 철학을 이어갑니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2011-nginx">
			<article class="event-detail" aria-labelledby="event-2011-nginx-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2011</p>
					<h2 id="event-2011-nginx-title">Nginx 1.0 안정화</h2>
					<p class="event-detail__summary">Nginx 1.0은 이벤트 기반 웹 서버를 안정판으로 공개하며 “가볍고 빠른 리버스 프록시” 시대를 열었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>2011년 4월, 이고르 시소예프는 메일링 리스트에 “Nginx 1.0이 나왔습니다. 이제 생산 환경에서 마음껏 쓰세요”라는 짧은 공지를 남겼습니다. 벤치마크에서는 수만 개의 동시 연결을 적은 메모리로 처리하는 모습이 잡혔습니다.</p>
						<p>스타트업은 정적 파일을 Nginx로 서빙하고, 백엔드 애플리케이션 앞단에는 리버스 프록시로 배치했습니다. 운영팀은 <code>nginx.conf</code>에 로드밸런싱과 캐시 설정을 적으며 “서버 한 대로도 많은 사용자를 버틴다”고 보고했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Nginx는 비동기 이벤트 루프, 비차단 I/O, 설정 기반 리버스 프록시를 제공했습니다. 덕분에 백엔드는 WAS와 API 서버를 여러 대로 쪼개고, 앞단에서는 Nginx가 트래픽을 분산했습니다. 이 구조는 이후 마이크로서비스, 컨테이너 오케스트레이션에서도 기본 패턴이 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2014-spring-boot">
			<article class="event-detail" aria-labelledby="event-2014-spring-boot-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2014</p>
					<h2 id="event-2014-spring-boot-title">Spring Boot 1.0</h2>
					<p class="event-detail__summary">Spring Boot 1.0은 “설정 대신 실행”을 내세우며 스프링 백엔드를 몇 분 만에 띄울 수 있게 했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>2014년 Pivotal 개발자 필 웹은 무대에서 <code>spring init --dependencies=web demo</code>를 실행했습니다. IDE에서 <code>DemoApplication.java</code>를 열고 바로 실행하자 Tomcat이 내장된 애플리케이션이 5초 만에 떠올랐습니다.</p>
						<p>팀은 “설정 XML을 어디에 둬야 하지?” 같은 고민 대신 <code>application.properties</code>에 필요한 옵션만 적고 배포 파이프라인에 Jar 파일을 올렸습니다. 마이크로서비스 전환을 계획하던 조직은 “서비스 하나당 스프링 부트 하나”라는 전략을 채택했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Spring Boot는 자동 설정, 스타터 의존성, 내장 Tomcat/Jetty를 제공해 배포 단위를 Jar 파일로 단순화했습니다. 백엔드는 마이크로서비스와 CI/CD에 맞춰 작은 모듈을 빠르게 만들 수 있었고, 프론트엔드는 일관된 REST/GraphQL API를 더 쉽게 받을 수 있었습니다. 이 접근은 이후 Spring Cloud, Kubernetes 배포 모델과 자연스럽게 이어집니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2014-lambda">
			<article class="event-detail" aria-labelledby="event-2014-lambda-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2014</p>
					<h2 id="event-2014-lambda-title">AWS Lambda 출시</h2>
					<p class="event-detail__summary">AWS는 Lambda를 내놓으며 “서버를 직접 돌리지 말고, 필요한 코드만 올려 두세요”라는 메시지를 현실로 만들었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>AWS re:Invent 무대에서 발표자가 “이제 서버를 예약하지 않아도 됩니다”라며 Lambda를 소개했습니다. 개발자 앨리스가 콘솔에 짧은 함수를 저장하자, 곧바로 웹훅 주소가 생겨 요청을 받아들였습니다.</p>
						<p>스타트업들은 로그인, 알림, 이미지 처리 등을 Lambda로 옮겨 운영 부담을 줄였고, 백엔드는 점점 더 작은 함수와 이벤트 중심 구조로 나뉘기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>서버리스 모델은 확장과 비용을 자동으로 처리해 줍니다. 백엔드는 서버 관리 대신 핵심 로직에 집중할 수 있고, 프론트엔드는 정적 자산을 CDN에 올린 뒤 필요한 기능만 API로 호출하는 패턴을 손쉽게 실행할 수 있게 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2015-k8s-ingress">
			<article class="event-detail" aria-labelledby="event-2015-k8s-ingress-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2015</p>
					<h2 id="event-2015-k8s-ingress-title">Kubernetes Ingress 리소스</h2>
					<p class="event-detail__summary">Kubernetes 1.1은 Ingress 리소스를 도입해 “클러스터 안 여러 서비스로 향하는 HTTP(S)를 한 관문에서 통제하자”고 제안했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>2015년 가을 Kubernetes 팀은 블로그에 “YAML 몇 줄로 TLS 종료와 가상 호스트를 정의하세요”라며 Ingress를 소개했습니다. 데모에서는 <code>host: api.example.com</code>이라는 설정만 추가해도 엣지 프록시가 자동으로 백엔드 서비스로 트래픽을 넘겼습니다.</p>
						<p>운영팀은 컨테이너마다 Nginx 인스턴스를 직접 관리하던 습관을 버리고, 클러스터 차원의 Ingress 컨트롤러에 규칙을 맡기기 시작했습니다. 배포 파이프라인은 애플리케이션 코드와 함께 라우팅 정책을 선언적으로 배포하도록 바뀌었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Ingress는 L7 라우팅과 TLS 종료를 Kubernetes 오브젝트로 흡수해 “WAS는 애플리케이션을 실행하고, 프록시는 플랫폼이 책임진다”는 경계를 다시 그었습니다. 덕분에 Spring Boot나 Tomcat을 컨테이너로 묶어 배포할 때에도, 트래픽 분배와 정책은 Ingress 컨트롤러·서비스 메시가 대신 맡는 현대적 패턴이 자리 잡았습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<button type="button" class="scroll-top" data-scroll-top aria-label="맨 위로 이동" hidden>↑</button>

		<script src="assets/js/main.js" defer></script>
	</body>
</html>
