<!DOCTYPE html>
<html lang="ko">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>ArcherLab IT Story · 운영체제 연대기</title>
		<meta name="description" content="배치 모니터에서 모바일·클라우드 런타임까지 운영체제가 하드웨어와 사용자를 어떻게 연결해 왔는지 살펴봅니다." />
		<meta property="og:title" content="ArcherLab IT Story · Operating Systems Timeline" />
		<meta property="og:description" content="하드웨어를 배분하고 사용자 경험을 바꾼 운영체제의 결정적 장면을 연대순으로 정리했습니다." />
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700;800&family=Space+Grotesk:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500;600&display=swap" rel="stylesheet">
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css">
		<link rel="stylesheet" href="assets/css/style.css">
		<link rel="alternate" hreflang="ko" href="https://itstory.archerlab.dev/os.html" />
		<link rel="alternate" hreflang="en" href="https://itstory.archerlab.dev/os-en.html" />
		<link rel="alternate" hreflang="x-default" href="https://itstory.archerlab.dev/os-en.html" />
		<link rel="canonical" href="https://itstory.archerlab.dev/os.html" />
		<!-- Google tag (gtag.js) -->
		<script async src="https://www.googletagmanager.com/gtag/js?id=G-EDBPXC8PL7"></script>
		<script defer src="assets/js/ga.js"></script>
	</head>
	<body>
		<div class="page">
			<header class="page__header" role="banner">
				<div class="page__header-left">
					<a class="page__brand" href="https://archerlab.dev" target="_blank" rel="noopener">
						<img src="assets/images/archerlab_mini_logo.png" alt="ArcherLab" class="page__brand-logo" loading="lazy">
						<span class="page__brand-label">ArcherLab Chronicle</span>
					</a>
					<nav class="page__topic-nav" aria-label="주제 전환">
						<a href="index.html">홈 허브</a>
						<a href="computers.html">컴퓨터 연대기</a>
						<a href="networks.html">네트워크 연대기</a>
						<a href="databases.html">데이터베이스 연대기</a>
						<a href="os.html" class="is-current">운영체제 연대기</a>
						<div class="page__topic-nav-group" role="group" aria-label="웹 제작 연대기">
							<span class="page__topic-nav-label">웹 제작 연대기</span>
							<a href="web.html" data-topic-role="parent">웹 제작 연대기 허브</a>
							<a href="web-structure.html" data-topic-role="child">웹 문서 설계 연대기</a>
							<a href="web-styling.html" data-topic-role="child">스타일링 진화 연대기</a>
							<a href="web-interaction.html" data-topic-role="child">브라우저 인터랙션 연대기</a>
							<a href="web-tools.html" data-topic-role="child">웹 제작 도구 연대기</a>
						</div>
						<a href="was.html">웹 서버 연대기</a>
					</nav>
				</div>
				<nav class="page__nav" aria-label="섹션 탐색">
					<a href="#timeline">연도 보기</a>
					<a href="#sources">참고</a>
					<div class="language-switch">
						<label class="sr-only" for="language-select-os">언어 선택</label>
						<select id="language-select-os" data-language-switch>
							<option value="os.html" data-language-code="ko" selected>한국어</option>
							<option value="os-en.html" data-language-code="en">English</option>
						</select>
					</div>
				</nav>
			</header>

			<main class="page__main" id="main" role="main">
				<section class="timeline-hero" aria-labelledby="timeline-title">
					<div class="timeline-hero__head">
						<p class="hero__eyebrow">Operating System Story for Builders</p>
						<h1 class="timeline-hero__title" id="timeline-title">배치 모니터에서 주머니 속 운영체제까지, 사람이 원하는 경험을 지켜 온 이야기</h1>
						<p class="timeline-hero__lede">
							1948년 맨체스터 연구팀은 Baby라는 시험 컴퓨터에 몇 줄짜리 시작 명령만 넣어도 기계가 스스로 다음 프로그램을 읽어 들인다는 사실을 보여 줬습니다. 얼마 지나지 않아 GM 야간 조 직원들은 “테이프만 갈다가 새벽이 다 간다”고 하소연했고, GM-NAA I/O와 FMS 같은 모니터 프로그램이 작업을 자동으로 이어 주면서 모두가 같은 절차를 공유하기 시작했습니다. 이어 NASA 공장과 대학 연구실은 시간을 잘게 나눠 여러 사람이 한 컴퓨터를 함께 쓰는 실험을 이어 갔습니다.
						</p>
						<p class="timeline-hero__lede">
							System/360은 “기종이 달라도 같은 운영체제를 쓰게 해 드리겠다”는 약속으로 호환성을 내세웠고, 벨 연구소의 UNIX는 “작은 프로그램을 이어 붙이자”는 습관을 널리 퍼뜨렸습니다. 1980~1990년대에는 MS-DOS와 Macintosh, Windows 95가 집과 사무실에 PC를 퍼뜨렸고, 리눅스 커뮤니티는 전 세계 개발자가 하나의 커널을 함께 고치는 방식을 정착시켰습니다. 2000년대 이후에는 Mac OS X와 iPhone OS, Android가 손안의 컴퓨터를 열었고, Docker와 Kubernetes는 클라우드에서 프로그램을 마음껏 배포하게 도왔습니다. 지금은 맞춤형 칩과 하이브리드 업무 환경이 “어디에서 실행되든 같은 경험”을 요구하고 있습니다.
						</p>
						<p class="timeline-hero__lede">
							아래 연도를 눌러 그 시절 사람들이 어떤 문제를 걱정했고 운영체제가 어떤 아이디어로 해결했는지 살펴보세요. 낯선 용어가 보이더라도, 각 모달이 사람과 상황을 중심으로 천천히 풀어 주니 가볍게 읽으셔도 괜찮습니다.
						</p>
					</div>
				</section>

				<section class="timeline-grid" id="timeline" aria-labelledby="timeline-title" aria-describedby="timeline-instructions">
					<p class="timeline-grid__instructions sr-only" id="timeline-instructions">버튼을 선택하면 같은 화면에서 자세한 이야기를 읽을 수 있습니다.</p>

					<section class="timeline-group" aria-labelledby="decade-1940 topic-1940">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1940">1940s</p>
							<h3 class="timeline-group__topic" id="topic-1940">저장 프로그램 시대를 여는 첫 부트스트랩</h3>
							<p class="timeline-group__summary">릴레이 배선 대신 짧은 초기 명령을 메모리에 실어 올려, 전자식 컴퓨터가 스스로 프로그램을 불러오고 반복 실행할 수 있는 기반을 만들었습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1948-manchester">
								<span class="timeline-event__year">1948</span>
								<span class="timeline-event__label">Manchester Baby 부트스트랩</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1949-edsac">
								<span class="timeline-event__year">1949</span>
								<span class="timeline-event__label">EDSAC 초기 명령</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-1950 topic-1950">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1950">1950s</p>
							<h3 class="timeline-group__topic" id="topic-1950">야간 조를 도운 배치 모니터</h3>
							<p class="timeline-group__summary">메인프레임 운영자들은 테이프를 갈아 끼우지 않아도 되도록 작업을 자동으로 줄 세우고, 공통 절차를 모니터 프로그램에 담았습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1956-gmnaa">
								<span class="timeline-event__year">1956</span>
								<span class="timeline-event__label">GM-NAA I/O 모니터</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1959-fms">
								<span class="timeline-event__year">1959</span>
								<span class="timeline-event__label">Fortran Monitor System</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-1960 topic-1960">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1960">1960s</p>
							<h3 class="timeline-group__topic" id="topic-1960">타임셰어링과 이식성 실험</h3>
							<p class="timeline-group__summary">System/360은 “하드웨어가 달라도 같은 OS”를 약속했고, UNIX는 작은 도구를 조합하며 이식성이 있는 커널을 선보였습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1964-os360">
								<span class="timeline-event__year">1964</span>
								<span class="timeline-event__label">IBM OS/360 발표</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1969-unix">
								<span class="timeline-event__year">1969</span>
								<span class="timeline-event__label">UNIX 커널 공개</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-1970 topic-1970">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1970">1970s</p>
							<h3 class="timeline-group__topic" id="topic-1970">마이크로컴퓨터와 가상 메모리 확장</h3>
							<p class="timeline-group__summary">작은 컴퓨터도 디스크와 여러 작업을 다룰 수 있게 CP/M과 VMS가 공통 인터페이스와 가상 메모리를 보급했습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1974-cpm">
								<span class="timeline-event__year">1974</span>
								<span class="timeline-event__label">CP/M 확산</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1978-vms">
								<span class="timeline-event__year">1978</span>
								<span class="timeline-event__label">VAX/VMS 출시</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-1980 topic-1980">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1980">1980s</p>
							<h3 class="timeline-group__topic" id="topic-1980">PC 보급과 그래픽 데스크톱</h3>
							<p class="timeline-group__summary">MS-DOS가 공통 규칙을 세우고, 매킨토시가 아이콘과 마우스를 대중화하며 PC가 일상 도구가 되었습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1981-msdos">
								<span class="timeline-event__year">1981</span>
								<span class="timeline-event__label">MS-DOS 1.0</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1984-system1">
								<span class="timeline-event__year">1984</span>
								<span class="timeline-event__label">맥킨토시 System 1</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-1990 topic-1990">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1990">1990s</p>
							<h3 class="timeline-group__topic" id="topic-1990">오픈소스와 일상형 OS</h3>
							<p class="timeline-group__summary">리눅스 커뮤니티가 커널을 함께 고쳤고, Windows 95는 스타트 버튼으로 가정과 사무실 모두를 겨냥했습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1991-linux">
								<span class="timeline-event__year">1991</span>
								<span class="timeline-event__label">리눅스 커널 발표</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1995-win95">
								<span class="timeline-event__year">1995</span>
								<span class="timeline-event__label">Windows 95 출시</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-2000 topic-2000">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-2000">2000s</p>
							<h3 class="timeline-group__topic" id="topic-2000">UNIX 감성과 모바일 도약</h3>
							<p class="timeline-group__summary">Mac OS X는 UNIX와 디자인을 묶었고, iPhone OS와 Android는 터치와 앱 생태계를 운영체제 수준에서 설계했습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="2001-macosx">
								<span class="timeline-event__year">2001</span>
								<span class="timeline-event__label">Mac OS X 출시</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2007-ios">
								<span class="timeline-event__year">2007</span>
								<span class="timeline-event__label">iPhone OS 1 공개</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2008-android">
								<span class="timeline-event__year">2008</span>
								<span class="timeline-event__label">Android 1.0 공개</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-2010 topic-2010">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-2010">2010s</p>
							<h3 class="timeline-group__topic" id="topic-2010">컨테이너와 클러스터 운영</h3>
							<p class="timeline-group__summary">Docker와 Kubernetes가 “이미지를 묶어 옮기고, 원하는 상태를 선언하면 제어 루프가 맞춰 준다”는 발상을 일상 도구로 만들었습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="2013-docker">
								<span class="timeline-event__year">2013</span>
								<span class="timeline-event__label">Docker 오픈소스화</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2015-kubernetes">
								<span class="timeline-event__year">2015</span>
								<span class="timeline-event__label">Kubernetes 1.0</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-2020 topic-2020">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-2020">2020s</p>
							<h3 class="timeline-group__topic" id="topic-2020">실리콘 전환과 하이브리드 경험</h3>
							<p class="timeline-group__summary">맞춤형 칩, 가상 데스크톱, 클라우드 PC를 한 화면에서 조율하며 “어디에서 실행돼도 같은 느낌”을 주려는 운영체제가 등장했습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="2020-big-sur">
								<span class="timeline-event__year">2020</span>
								<span class="timeline-event__label">Apple Silicon과 macOS Big Sur</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2021-windows11">
								<span class="timeline-event__year">2021</span>
								<span class="timeline-event__label">Windows 11 출시</span>
							</button>
						</div>
					</section>
				</section>

				<section class="sources" id="sources" aria-labelledby="sources-title">
					<div class="section__head">
						<h2 id="sources-title">더 깊이 읽을 거리</h2>
						<p>운영체제가 배치 작업, 타임셰어링, 모바일과 클라우드를 품어 가는 과정을 기록한 1차 자료와 회고를 모았습니다.</p>
					</div>
					<ul class="source-list">
						<li><a href="https://www.cs.manchester.ac.uk/about-us/history/baby/" target="_blank" rel="noopener">University of Manchester · Baby SSEM</a></li>
						<li><a href="https://www.cl.cam.ac.uk/conference/edsac50/" target="_blank" rel="noopener">University of Cambridge · EDSAC Initial Orders</a></li>
						<li><a href="https://www.computerhistory.org/revolution/mainframe-computers/7/169" target="_blank" rel="noopener">Computer History Museum · GM-NAA I/O</a></li>
						<li><a href="https://www.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP105.html" target="_blank" rel="noopener">IBM Archives · System/360</a></li>
						<li><a href="https://www.bell-labs.com/usr/dmr/www/hist.html" target="_blank" rel="noopener">Bell Labs · UNIX History</a></li>
						<li><a href="https://computerhistory.org/blog/the-rise-and-fall-of-digital-research/" target="_blank" rel="noopener">Computer History Museum · CP/M Story</a></li>
						<li><a href="https://android-developers.googleblog.com/2008/09/android-10-launched.html" target="_blank" rel="noopener">Android Developers Blog · Android 1.0</a></li>
						<li><a href="https://www.apple.com/kr/newsroom/2020/11/apple-unleashes-m1/" target="_blank" rel="noopener">Apple Newsroom · Apple Silicon</a></li>
					</ul>
				</section>
			</main>

			<footer class="page__footer" role="contentinfo">
				<p>© 2025 ArcherLab · 운영체제를 기록합니다.</p>
				<a class="page__footer-link" href="https://archerlab.dev" target="_blank" rel="noopener">archerlab.dev</a>
			</footer>
		</div>

		<div class="modal" id="event-modal" role="dialog" aria-modal="true" hidden>
			<div class="modal__overlay" data-modal-close></div>
			<div class="modal__window" role="document" tabindex="-1">
				<button class="modal__close" type="button" aria-label="레이어 닫기" data-modal-close>&times;</button>
				<div class="modal__content"></div>
			</div>
		</div>

		<template id="event-1948-manchester">
			<article class="event-detail" aria-labelledby="event-1948-manchester-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1948</p>
					<h2 id="event-1948-manchester-title">Manchester Baby, 저장 프로그램 부트스트랩을 증명하다</h2>
					<p class="event-detail__summary">맨체스터 팀은 "부트스트랩 몇 줄만 올리면 기계가 스스로 프로그램을 읽는다"는 사실을 SSEM(Baby) 첫 실행으로 입증했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>프레더릭 윌리엄스와 톰 킬번은 윌리엄스-킬번 관에 32워드 메모리를 저장한 뒤, 가장 큰 약수를 찾는 시험 프로그램을 1948년 6월 21일에 실행했습니다. 수동으로 토글한 짧은 초기 명령이 테이프 없이도 코드를 메모리에 적재하고 결과를 읽어냈습니다.</p>
						<p>Baby는 단순한 데모였지만, 전자식 컴퓨터가 "데이터와 명령을 같은 저장장치에 둔다"는 폰 노이만 구조를 실전에서 증명했습니다. 연구자들은 이제 새로운 알고리즘을 배선 대신 소프트웨어로 교체할 수 있다는 확신을 얻었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>짧은 부트스트랩이 본체 코드를 불러오는 방식은 곧 "초기 로더"라는 개념으로 자리 잡았고, 후대 운영체제가 부팅 과정에서 작은 모니터를 먼저 실행한 뒤 커널을 적재하는 전통으로 이어졌습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1949-edsac">
			<article class="event-detail" aria-labelledby="event-1949-edsac-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1949</p>
					<h2 id="event-1949-edsac-title">EDSAC Initial Orders, 표준 부트스트랩과 루틴을 묶다</h2>
					<p class="event-detail__summary">케임브리지 EDSAC 팀은 31개 명령으로 구성된 Initial Orders를 만들어, 종이테이프에서 프로그램을 자동으로 적재하고 공용 서브루틴을 호출하도록 했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>모리스 윌크스와 동료들은 전원을 올린 뒤 스위치를 조작해 Initial Orders를 메모리에 적재했습니다. 이 짧은 부트스트랩은 입력 장치를 초기화하고, 이어지는 테이프에서 목적 프로그램을 메모리로 복사한 후 실행까지 이어 줬습니다.</p>
						<p>EDSAC 운영팀은 라이브러리 테이프에 제곱근, 로그, 트리거함수 같은 서브루틴을 모아두고 필요할 때 Initial Orders가 불러오게 했습니다. 연구자들은 수학 공식을 직접 코딩하지 않아도 계산을 반복할 수 있게 되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Initial Orders와 서브루틴 라이브러리는 "부트스트랩 → 로더 → 공용 루틴"이라는 구조를 정착시켜, 후대 모니터 프로그램과 운영체제가 장치 초기화와 라이브러리 호출을 일관되게 처리하는 출발점이 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1956-gmnaa">
			<article class="event-detail" aria-labelledby="event-1956-gmnaa-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1956</p>
					<h2 id="event-1956-gmnaa-title">GM-NAA I/O, 배치 작업을 자동으로 넘기다</h2>
					<p class="event-detail__summary">GM과 North American Aviation은 펀치카드 프로그램을 끊김 없이 이어 주는 GM-NAA I/O를 IBM 704에 올려 초기 운영체제의 모습을 보여 줬습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>GM 연구소는 계산 작업이 끝날 때마다 다음 카드 덱을 사람이 직접 올려야 하는 비효율에 지쳐 있었습니다. GM-NAA I/O는 제어 카드와 모니터 루틴을 두어 한 작업이 끝나면 자동으로 다음 작업을 적재하고 프린터·테이프 장치를 초기화했습니다.</p>
						<p>연속 실행이 가능해지자 야간 배치 시간을 확보할 수 있었고, 운영 요원은 장치를 전환하거나 오류를 수집하는 데 집중했습니다. 사용자는 “카드만 맞게 주면 순서대로 결과가 나온다”는 믿음을 갖게 되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>GM-NAA I/O는 모니터 프로그램 개념을 확립해 이후 IBSYS, OS/360 같은 배치형 운영체제의 기반이 되었고, 작업 제어 언어(JCL)의 전신을 제공했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1959-fms">
			<article class="event-detail" aria-labelledby="event-1959-fms-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1959</p>
					<h2 id="event-1959-fms-title">Fortran Monitor System, 코드 재사용을 지원하다</h2>
					<p class="event-detail__summary">IBM은 Fortran Monitor System(FMS)을 통해 컴파일·링크·실행을 한 번에 처리하고, 매크로 라이브러리를 공유하는 배치 운영 환경을 상품화했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>FMS는 사용자가 카드 덱 앞부분에 제어 문장을 붙여두면 컴파일과 링크, 실행 결과 출력까지 자동으로 이어지는 흐름을 제공했습니다. 반복되는 라이브러리는 공용 테이프에 등록해 여러 프로젝트가 공유했습니다.</p>
						<p>이 덕분에 과학자와 공업 엔지니어는 카드 덱만 준비하면 밤새 계산 작업을 맡길 수 있었고, 오류 메시지는 표준 형식으로 모여 다음 배치 전에 수정할 수 있었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>FMS에서 쓰인 작업 제어 카드와 라이브러리 관리 방식은 이후 IBSYS와 OS/360의 JCL, 유틸리티 프로그램 설계에 직접적인 영향을 주었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1964-os360">
			<article class="event-detail" aria-labelledby="event-1964-os360-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1964</p>
					<h2 id="event-1964-os360-title">System/360, 하나의 OS로 가족 제품을 지원하다</h2>
					<p class="event-detail__summary">IBM은 “메인프레임을 바꿔도 같은 OS를 쓰게 해드릴게요”라고 약속했고, 그 답으로 OS/360을 선보였습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>기존 고객은 새 기계를 도입할 때마다 프로그램을 다시 작성해야 했습니다. OS/360은 커널, I/O 제어, 장치 드라이버를 층으로 나눠 하드웨어가 달라도 같은 인터페이스를 보장했습니다.</p>
						<p>출시 초기에 버그와 지연이 많았지만, 한 번 만든 프로그램을 다른 360 기종으로 옮겨도 된다는 약속이 지켜지며 호환성이 운영체제의 핵심 가치가 되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>OS/360은 안정적 API와 장기 지원을 약속하는 관행을 남겨 오늘날 기업용 운영체제가 호환성을 최우선으로 삼는 계열 전략의 출발점이 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1969-unix">
			<article class="event-detail" aria-labelledby="event-1969-unix-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1969</p>
					<h2 id="event-1969-unix-title">UNIX, 작은 도구를 조합하는 철학을 심다</h2>
					<p class="event-detail__summary">벨 연구소 연구자들은 “작은 도구를 파이프로 엮자”는 생각으로 커널을 C 언어로 다시 써 이식성과 단순함을 챙겼습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>켄 톰프슨과 데니스 리치는 “모든 것을 파일처럼 다룰 수 있게 하자”는 목표로 커널을 다시 썼습니다. 파이프가 생기면서 한 프로그램의 출력이 다른 프로그램의 입력이 되었고, 작은 도구를 이어 붙이는 문화가 자리 잡았습니다.</p>
						<p>소스 코드가 공개돼 대학과 연구소가 직접 포팅을 시도했고, C 언어 덕분에 다른 하드웨어로 옮기기도 쉬웠습니다. 필요한 기능을 얹어 자신만의 UNIX를 만드는 흐름이 자연스럽게 퍼졌습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>UNIX의 “모든 것은 파일” 철학은 POSIX 표준, 쉘 파이프라인, 현대 리눅스 커널 구조로 이어져 오늘 개발 도구와 서버 운영 방식의 뿌리가 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1974-cpm">
			<article class="event-detail" aria-labelledby="event-1974-cpm-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1974</p>
					<h2 id="event-1974-cpm-title">CP/M, 마이크로컴퓨터용 표준 OS</h2>
					<p class="event-detail__summary">게리 킬달은 “디스크 호출만 맞추면 다 돌아간다”는 발상으로 마이크로컴퓨터를 위한 공통 운영체제 CP/M을 만들었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>마이크로컴퓨터 제조사는 저마다 다른 디스크 컨트롤러를 썼습니다. CP/M은 하드웨어에 붙는 BIOS와 공통 기능을 담당하는 BDOS를 분리해 제조사가 바꿔야 할 부분을 최소화했습니다.</p>
						<p>WordStar, VisiCalc 같은 프로그램이 여러 기기에서 같은 모습으로 돌아갔고, 기업은 “하드웨어가 달라도 같은 일을 할 수 있다”는 확신을 갖고 마이크로컴퓨터를 도입했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>BIOS와 BDOS로 나눈 구조는 오늘날 운영체제가 커널과 드라이버를 나누어 설계하는 방식, 하드웨어 추상화 계층(HAL)의 전신으로 평가됩니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1978-vms">
			<article class="event-detail" aria-labelledby="event-1978-vms-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1978</p>
					<h2 id="event-1978-vms-title">VAX/VMS, 가상 메모리와 클러스터를 대중화</h2>
					<p class="event-detail__summary">DEC는 “중형 컴퓨터만으로도 24시간 돌아갑니다”라며 가상 메모리와 클러스터 기능을 갖춘 VMS를 소개했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>VMS는 메모리를 페이지로 나누고 디스크를 임시 메모리처럼 쓰는 방식을 중형 컴퓨터에 도입했습니다. 덕분에 프로그램은 실제 메모리 용량을 크게 신경 쓰지 않고 데이터를 다뤘습니다.</p>
						<p>VMScluster는 여러 대 장비를 하나처럼 묶어 한 대가 멈추면 다른 장비가 곧바로 업무를 이어받았습니다. 병원과 연구소는 메인프레임 없이도 24시간 서비스를 유지할 수 있었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>VMS의 보안 링, RMS 파일 서비스, 클러스터 API는 훗날 Windows NT와 오늘날 하이퍼바이저 설계의 참고 자료가 됐습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1981-msdos">
			<article class="event-detail" aria-labelledby="event-1981-msdos-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1981</p>
					<h2 id="event-1981-msdos-title">MS-DOS, IBM PC 생태계를 단단히 묶다</h2>
					<p class="event-detail__summary">마이크로소프트는 OEM 라이선스를 무기로 MS-DOS를 배포해 IBM PC 호환기종이 공통 운영체제를 공유하도록 만들었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>MS-DOS는 간결한 커맨드 라인과 BIOS 호출 규칙만으로 구성돼, 하드웨어 제조사가 자신의 기기에 빠르게 이식할 수 있었습니다. `CONFIG.SYS`와 `AUTOEXEC.BAT`로 드라이버와 환경을 설정하자 부품이 달라도 같은 명령을 쓸 수 있었습니다.</p>
						<p>워드프로세서, 스프레드시트, 회계 프로그램이 DOS를 표준 플랫폼으로 삼으면서 “IBM PC 호환” 로고만 있으면 업무용 소프트웨어가 돌아가는 시장이 열렸습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>MS-DOS의 OEM 계약과 앱 호환성 생태계는 PC 산업을 급속히 확장시켰고, 이후 Windows 3.x와 95로 이어지는 GUI 전환의 기반을 마련했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1984-system1">
			<article class="event-detail" aria-labelledby="event-1984-system1-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1984</p>
					<h2 id="event-1984-system1-title">맥킨토시 System 1, 그래픽 UI 대중화</h2>
					<p class="event-detail__summary">애플은 “필요 없으면 쓰레기통에 버리세요”라고 말하며 System 1으로 그래픽 데스크톱을 친숙하게 소개했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>System 1은 “버튼을 누른다” 대신 “종이 아이콘을 쓰레기통에 버린다” 같은 현실 은유를 곳곳에 심었습니다. 마우스를 움직이면 커서가 따라오고, 메뉴는 화면 위에 고정돼 길을 잃을 일이 줄었습니다.</p>
						<p>애플은 휴먼 인터페이스 가이드라인을 배포해 외부 개발자도 같은 규칙을 따르도록 했습니다. 처음 컴퓨터를 접한 사람도 짧은 데모만 보고 기능을 이해할 수 있었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>리소스 매니저, 퀵드로 그래픽 API, 메뉴·대화상자 패턴은 이후 데스크톱 UI 프레임워크의 기본 설계서가 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1991-linux">
			<article class="event-detail" aria-labelledby="event-1991-linux-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1991</p>
					<h2 id="event-1991-linux-title">리눅스, 누구나 커널에 기여하는 시대</h2>
					<p class="event-detail__summary">헬싱키의 학생이 “GNU 없는 UNIX를 같이 만들자”는 글을 올리자 전 세계 개발자가 리눅스 커널에 합류했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>리누스 토르발스는 386 PC에서 돌아갈 미니 커널을 자습 프로젝트로 만들다가 “같이 고쳐 보자”는 글을 올렸습니다. 메일링 리스트에는 스케줄러 개선, 파일시스템 추가, 네트워크 스택 제안이 올라오고 커뮤니티가 직접 코드를 손봤습니다.</p>
						<p>GNU 도구와 결합하면서 리눅스는 완전한 운영체제가 되었고, 소스가 공개돼 누구나 읽고 수정하고 다시 배포할 수 있었습니다. 이 자유도가 전 세계 개발자를 끌어들였습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>GPL 라이선스가 “수정하면 다시 공개한다”는 규칙을 강제했고, 패치 리뷰와 배포판 중심 릴리스 주기가 오늘날 오픈소스 운영체제 개발의 기본 모델이 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1995-win95">
			<article class="event-detail" aria-labelledby="event-1995-win95-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1995</p>
					<h2 id="event-1995-win95-title">Windows 95, 시작 버튼으로 생활을 묶다</h2>
					<p class="event-detail__summary">마이크로소프트는 “시작 버튼만 누르면 됩니다”라며 Windows 95를 출시해 가정과 사무실 모두가 같은 OS를 쓰기 시작했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Windows 95는 32비트 그래픽 인터페이스, 플러그앤플레이, 긴 파일 이름 지원을 한꺼번에 제공했습니다. 시작 버튼 한 곳에서 프로그램, 설정, 전원을 찾을 수 있다는 점을 TV 광고로 강조했습니다.</p>
						<p>회사에서는 네트워크 드라이브를 쓰고, 집에서는 사진 정리나 게임을 같은 화면에서 처리했습니다. 운영체제가 일상과 업무를 잇는 대중적 순간이었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Windows 95의 셸 통합, 레지스트리, Win32 구조는 이후 Windows NT 계열에도 이어져 지금까지 유지되고 있습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2001-macosx">
			<article class="event-detail" aria-labelledby="event-2001-macosx-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2001</p>
					<h2 id="event-2001-macosx-title">Mac OS X, UNIX 안정성과 디자인 결합</h2>
					<p class="event-detail__summary">애플은 “예쁜데 UNIX예요”라는 메시지로 Mac OS X를 소개하며 Aqua 인터페이스와 Darwin 커널을 묶었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>NeXTSTEP 기반 커널 위에 Aqua 그래픽을 얹어 프리엠프티브 멀티태스킹과 보호 메모리를 기본으로 제공했습니다. 앱 하나가 멈춰도 시스템 전체는 버텼습니다.</p>
						<p>Quartz, Carbon, Cocoa API를 정리해 개발자가 단계적으로 새 환경으로 옮겨올 수 있도록 했습니다. 애플은 WWDC에서 “크래시가 줄었다”는 그래프를 보여 주며 안정성과 디자인을 동시에 잡았다고 강조했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Mac OS X는 인증받은 UNIX 데스크톱으로 자리 잡아 이후 iOS와 watchOS까지 이어지는 애플 운영체제의 공통 기반이 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2007-ios">
			<article class="event-detail" aria-labelledby="event-2007-ios-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2007</p>
					<h2 id="event-2007-ios-title">iPhone OS 1, 터치 퍼스트 인터페이스</h2>
					<p class="event-detail__summary">스티브 잡스는 “스타일러스는 필요 없어요”라며 iPhone OS 1을 소개했고, 멀티터치 제스처가 모바일 OS 표준이 되었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>iPhone OS는 손가락 탭, 핀치, 스와이프를 전제로 한 UI를 제시했습니다. 홈 화면 아이콘과 커버 플로우 같은 요소가 곧 사용법이 되었습니다.</p>
						<p>당시 스마트폰은 물리 키보드나 스타일러스를 기본으로 했지만, 애플은 소프트 키보드를 표준으로 두고 자동 완성을 더해 손가락만으로 타이핑하도록 했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>멀티터치 제스처와 앱 샌드박스 구조는 이후 iOS SDK와 App Store 보안 모델의 기초가 되어 모바일 OS 전반이 터치 UX를 채택하게 만들었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2008-android">
			<article class="event-detail" aria-labelledby="event-2008-android-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2008</p>
					<h2 id="event-2008-android-title">Android 1.0, 오픈 모바일 플랫폼</h2>
					<p class="event-detail__summary">구글은 “모든 제조사가 같은 SDK를 씁니다”라며 Android 1.0을 공개해 오픈소스로 모바일 OS 선택지를 넓혔습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Android 1.0은 오픈핸드셋얼라이언스 제조사가 함께 쓰는 SDK와 앱 마켓(안드로이드 마켓)을 제공했습니다. 알 수 없는 출처 앱 설치도 허용해 실험적 앱을 배포하기 쉬웠습니다.</p>
						<p>Dalvik VM은 자바와 비슷한 언어로 앱을 작성하게 했고, 기기마다 사양이 달라도 같은 앱을 실행할 수 있도록 공통 바이트코드를 두었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Dalvik, APK 패키징, 오픈소스 정책은 제조사가 자체 스킨과 서비스를 얹어도 호환을 유지하는 토대가 되어 모바일 생태계를 다변화했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2013-docker">
			<article class="event-detail" aria-labelledby="event-2013-docker-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2013</p>
					<h2 id="event-2013-docker-title">Docker, 컨테이너를 일상 도구로</h2>
					<p class="event-detail__summary">dotCloud는 “이미지 한 통에 앱을 담아 어디서나 실행해 보세요”라며 Docker로 컨테이너를 대중화했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Docker는 “컨테이너”를 택배 상자에 비유하며 필요한 파일과 설정을 이미지로 묶었습니다. `docker run` 한 줄이면 어디서든 같은 환경을 꺼내 쓸 수 있었습니다.</p>
						<p>개발자와 운영팀은 “내 컴퓨터에서는 되는데”라는 말을 줄였고, 클라우드 업체는 관리형 컨테이너 서비스를 빠르게 제공했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Docker 레지스트리, 레이어드 파일시스템, Compose 워크플로는 DevOps와 플랫폼 엔지니어링 문화가 자리 잡는 핵심 도구가 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2015-kubernetes">
			<article class="event-detail" aria-labelledby="event-2015-kubernetes-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2015</p>
					<h2 id="event-2015-kubernetes-title">Kubernetes 1.0, 선언형 클러스터 운영</h2>
					<p class="event-detail__summary">구글·레드햇·CoreOS는 “원하는 상태를 선언하세요, 우리가 유지할게요”라며 Kubernetes 1.0을 CNCF에 기증했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Kubernetes는 컨테이너를 Pod로 묶고 ReplicaSet이 원하는 수를 유지하며, 서비스가 트래픽을 분산했습니다. 운영자는 YAML로 “이 이미지를 몇 개 띄워라”만 적으면 제어 루프가 상태를 맞춰 줬습니다.</p>
						<p>오픈소스화 이후 클라우드와 기업이 Kubernetes를 도입해 컨테이너 배포의 공통 언어로 삼았습니다. DevOps 팀은 롤링 업데이트와 셀프 힐링을 기본 기능처럼 활용했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>CNCF는 Kubernetes를 중심으로 Prometheus, Envoy, gRPC 등을 묶어 클라우드 네이티브 표준 스택을 만들었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2020-big-sur">
			<article class="event-detail" aria-labelledby="event-2020-big-sur-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2020</p>
					<h2 id="event-2020-big-sur-title">macOS Big Sur, Apple Silicon 전환의 교두보</h2>
					<p class="event-detail__summary">애플은 “칩이 바뀌어도 앱은 그대로 쓰세요”라며 M1, macOS Big Sur, Rosetta 2를 묶어 부드러운 전환을 이뤘습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>애플은 macOS를 ARM 기반 M1 칩에 맞춰 다시 빌드하면서도 인텔용 앱을 Rosetta 2가 실시간 변환해 실행하도록 했습니다. 사용자는 별도 설정 없이 기존 앱을 그대로 열 수 있었습니다.</p>
						<p>Xcode는 유니버설 바이너리를 지원해 한 번 빌드로 두 아키텍처용 실행 파일을 만들게 했습니다. 긴 배터리 수명과 즉시 깨우기 경험은 하드웨어와 운영체제를 함께 설계할 때 얻는 이점을 보여 줬습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Big Sur의 호환 계층과 시스템 확장 보안 모델은 맞춤형 실리콘과 OS를 결합해 경험을 차별화해야 한다는 신호가 됐습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2021-windows11">
			<article class="event-detail" aria-labelledby="event-2021-windows11-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2021</p>
					<h2 id="event-2021-windows11-title">Windows 11, 로컬과 클라우드를 잇는 데스크톱</h2>
					<p class="event-detail__summary">마이크로소프트는 “집이든 클라우드든 같은 데스크톱을 쓰세요”라며 Windows 11에 새 셸, 기본 보안, WSLg·Windows 365 연동을 담았습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Windows 11은 작업 표시줄과 설정 앱을 다시 디자인해 PC와 태블릿을 오가도 익숙한 조작감을 유지했습니다. 동시에 TPM과 보안 부팅을 기본값으로 바꿔 하드웨어 단계부터 공격을 막았습니다.</p>
						<p>WSLg는 리눅스 GUI 앱을 윈도우 창 옆에 띄워 개발 환경을 통합했고, Windows 365는 회사를 클라우드 PC와 이어 줬습니다. 운영체제가 로컬 기기와 원격 리소스를 한 화면에서 조율하는 모습이 현실이 됐습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Windows 11의 기본 보안과 WSLg·Windows 365 통합은 하이브리드 시대 운영체제가 갖춰야 할 “보안 기본값 + 다중 환경 연결성” 기준을 제시했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<button type="button" class="scroll-top" data-scroll-top aria-label="맨 위로" hidden>↑</button>

		<script src="assets/js/main.js" defer></script>
		<script type="text/javascript" src="https://wcs.pstatic.net/wcslog.js"></script>
		<script type="text/javascript">
			if (!window.wcs_add) window.wcs_add = {};
			window.wcs_add["wa"] = "134f4c428765360";
			if (window.location.protocol !== 'file:' && window.wcs) {
				wcs_do();
			}
		</script>
	</body>
</html>
