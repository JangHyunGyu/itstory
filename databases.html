<!DOCTYPE html>
<html lang="ko">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>ArcherLab IT Story · 데이터를 맡기는 기술의 여정</title>
		<meta name="description" content="1890년대 천공 카드에서 2020년대 벡터 검색까지, 데이터를 안전하게 저장하고 꺼내 쓰게 만든 순간을 타임라인으로 정리했습니다." />
		<meta property="og:title" content="ArcherLab IT Story · Database Timeline" />
		<meta property="og:description" content="관계형 모델, NoSQL, 레이크하우스, 벡터 검색까지 이어지는 데이터베이스 역사를 따라가 보세요." />
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700;800&family=Space+Grotesk:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500;600&display=swap" rel="stylesheet">
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css">
		<link rel="stylesheet" href="assets/css/style.css">
	</head>
	<body>
		<div class="page">
			<header class="page__header" role="banner">
				<div class="page__header-left">
					<a class="page__brand" href="https://archerlab.dev" target="_blank" rel="noopener">
						<img src="assets/images/archerlab_mini_logo.png" alt="ArcherLab" class="page__brand-logo" loading="lazy">
						<span class="page__brand-label">ArcherLab Chronicle</span>
					</a>
					<nav class="page__topic-nav" aria-label="주제 전환">
						<a href="index.html">홈 허브</a>
						<a href="networks.html">네트워크 연대기</a>
						<a href="computers.html">컴퓨터 연대기</a>
						<div class="page__topic-nav-group" role="group" aria-label="웹 제작 연대기">
							<span class="page__topic-nav-label">웹 제작 연대기</span>
							<a href="web.html" data-topic-role="parent">웹 제작 연대기 허브</a>
							<a href="web-structure.html" data-topic-role="child">웹 문서 설계 연대기</a>
							<a href="web-styling.html" data-topic-role="child">스타일링 진화 연대기</a>
							<a href="web-interaction.html" data-topic-role="child">브라우저 인터랙션 연대기</a>
							<a href="web-tools.html" data-topic-role="child">웹 제작 도구 연대기</a>
						</div>
						<a href="was.html">웹 서버 연대기</a>
						<a href="databases.html" class="is-current">데이터베이스 연대기</a>
					</nav>
				</div>
				<nav class="page__nav" aria-label="섹션 탐색">
					<a href="#timeline">연도 보기</a>
					<a href="#sources">참고</a>
				</nav>
			</header>

			<main class="page__main" id="main" role="main">
				<section class="timeline-hero" aria-labelledby="timeline-title">
					<div class="timeline-hero__head">
						<p class="hero__eyebrow">Database Story for Curious Builders</p>
						<h1 class="timeline-hero__title" id="timeline-title">천공 카드와 자기 디스크, 관계형 모델, 레이크하우스까지. 데이터를 믿고 맡길 수 있게 만든 고민을 따라가 보세요</h1>
						<p class="timeline-hero__lede">
							1890년 미국 인구조사를 재빨리 끝내기 위해 펀치 카드가 등장했고, 1960년대에는 로켓 조립 공장이 서로 다른 부품 데이터를 정리하려고 IMS를 썼습니다.
							한편 연구자들은 “모든 데이터를 표로 정리하면 어떨까?”라며 관계형 모델을 제안했고, 2000년대에는 “수천 대의 서버에서 동시에 데이터를 읽자”라는 분산 저장 실험이 이어졌습니다.
						</p>
						<p class="timeline-hero__lede">
							1970년 E.F. Codd의 관계형 모델, 1976년 Peter Chen의 ER 다이어그램, 1979년 Oracle V2 같은 사건을 차례로 따라가면 SQL이 어떻게 실무에 뿌리내렸는지 보입니다. 이어서 1996년 PostgreSQL과 2009년 MongoDB가 오픈소스의 폭을 넓혔고, 2012년 Spanner와 2023년 벡터 DB는 글로벌 트랜잭션과 생성형 AI 시대의 요구를 채워 주었습니다.
						</p>
						<p class="timeline-hero__lede">
							연도 버튼을 누르면 각 세대가 어떤 문제를 풀려고 했는지, 그 선택이 다음 시대에 어떤 힌트를 남겼는지 쉽게 읽을 수 있습니다.
							SQL과 NoSQL, 레이크하우스, 벡터 검색 같은 용어가 낯설어도 괜찮아요. 팝업 안에서 바로 풀어 설명해 드립니다.
						</p>
					</div>
				</section>

				<section class="timeline-grid" id="timeline" aria-labelledby="timeline-title" aria-describedby="timeline-instructions">
					<p class="timeline-grid__instructions sr-only" id="timeline-instructions">연도 버튼을 누르면 새 창 없이 팝업 대화 상자가 열리고, 그 자리에서 자세한 이야기를 이어서 읽을 수 있습니다.</p>

					<section class="timeline-group" aria-labelledby="decade-1890 topic-1890">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1890">1890s</p>
							<h3 class="timeline-group__topic" id="topic-1890">기록 자동화의 첫걸음</h3>
							<p class="timeline-group__summary">펀치 카드와 전기식 표집계기가 등장하며, 종이에 적던 데이터를 기계가 직접 세기 시작했습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1890-hollerith">
								<span class="timeline-event__year">1890</span>
								<span class="timeline-event__label">홀러리스 천공 카드 시스템</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-1950 topic-1950">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1950">1950s</p>
							<h3 class="timeline-group__topic" id="topic-1950">자기 디스크와 프로그램 설계</h3>
							<p class="timeline-group__summary">자기 디스크가 등장해 데이터를 바로 수정할 수 있게 되었고, 조직들은 파일과 레코드를 어떻게 나눌지 논의하기 시작했습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1956-ramac">
								<span class="timeline-event__year">1956</span>
								<span class="timeline-event__label">IBM 305 RAMAC</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1959-codasyl">
								<span class="timeline-event__year">1959</span>
								<span class="timeline-event__label">CODASYL DB 위원회 발족</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-1960 topic-1960">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1960">1960s</p>
							<h3 class="timeline-group__topic" id="topic-1960">기업용 데이터 모델을 실험하다</h3>
							<p class="timeline-group__summary">우주 개발과 은행 업무가 커지면서 계층·네트워크 모델이 등장했고, 대량 데이터를 실시간으로 맞추기 위한 설계 논쟁이 이어졌습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1966-ims">
								<span class="timeline-event__year">1966</span>
								<span class="timeline-event__label">IBM IMS 가동</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1969-ids">
								<span class="timeline-event__year">1969</span>
								<span class="timeline-event__label">IDS 네트워크 모델</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-1970 topic-1970">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1970">1970s</p>
							<h3 class="timeline-group__topic" id="topic-1970">관계형 모델과 언어의 탄생</h3>
							<p class="timeline-group__summary">데이터를 표(table)로 표현하고, 자연어에 가까운 질의 언어로 조회하자는 아이디어가 설득력을 얻었습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1970-codd">
								<span class="timeline-event__year">1970</span>
								<span class="timeline-event__label">E.F. Codd 관계형 논문</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1976-ermodel">
								<span class="timeline-event__year">1976</span>
								<span class="timeline-event__label">Peter Chen ER 모델</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1979-oracle">
								<span class="timeline-event__year">1979</span>
								<span class="timeline-event__label">Oracle V2 SQL DB</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-1980 topic-1980">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1980">1980s</p>
							<h3 class="timeline-group__topic" id="topic-1980">표준과 고성능 시스템</h3>
							<p class="timeline-group__summary">대형 은행과 제조사가 관계형 DB를 채택하면서 SQL 표준과 대규모 병렬 처리 엔진이 속속 등장했습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1981-db2">
								<span class="timeline-event__year">1981</span>
								<span class="timeline-event__label">IBM DB2 베타</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1986-sql-standard">
								<span class="timeline-event__year">1986</span>
								<span class="timeline-event__label">ANSI SQL-86 채택</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1988-teradata">
								<span class="timeline-event__year">1988</span>
								<span class="timeline-event__label">Teradata DBC/1012</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-1990 topic-1990">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1990">1990s</p>
							<h3 class="timeline-group__topic" id="topic-1990">웹과 오픈소스, 데이터 웨어하우스</h3>
							<p class="timeline-group__summary">웹 서비스와 전자상거래가 성장하며 오픈소스 DB가 등장했고, 경영 보고를 위한 데이터 웨어하우스 개념이 자리 잡았습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1995-mysql">
								<span class="timeline-event__year">1995</span>
								<span class="timeline-event__label">MySQL 공개</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1996-postgres95">
								<span class="timeline-event__year">1996</span>
								<span class="timeline-event__label">PostgreSQL 6 미리보기</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1998-datawarehouse">
								<span class="timeline-event__year">1998</span>
								<span class="timeline-event__label">데이터 웨어하우스 참고 모델</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-2000 topic-2000">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-2000">2000s</p>
							<h3 class="timeline-group__topic" id="topic-2000">빅데이터와 분산 저장 실험</h3>
							<p class="timeline-group__summary">인터넷 기업들이 거대한 로그를 다루기 위해 MapReduce와 Dynamo 같은 분산 설계를 선보였고, 문서 지향 NoSQL이 등장했습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="2004-mapreduce">
								<span class="timeline-event__year">2004</span>
								<span class="timeline-event__label">Google MapReduce 논문</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2006-dynamo">
								<span class="timeline-event__year">2006</span>
								<span class="timeline-event__label">Amazon Dynamo 설계</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2009-mongodb">
								<span class="timeline-event__year">2009</span>
								<span class="timeline-event__label">MongoDB 1.0</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-2010 topic-2010">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-2010">2010s</p>
							<h3 class="timeline-group__topic" id="topic-2010">클라우드 네이티브와 글로벌 일관성</h3>
							<p class="timeline-group__summary">전 세계 데이터센터를 하나처럼 다루기 위한 일관성, 그리고 스트리밍 데이터 파이프라인이 주목받았습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="2012-spanner">
								<span class="timeline-event__year">2012</span>
								<span class="timeline-event__label">Google Spanner 논문</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2014-kafka">
								<span class="timeline-event__year">2014</span>
								<span class="timeline-event__label">Apache Kafka 0.8</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2018-snowflake">
								<span class="timeline-event__year">2018</span>
								<span class="timeline-event__label">Snowflake 전역 출시</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-2020 topic-2020">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-2020">2020s</p>
							<h3 class="timeline-group__topic" id="topic-2020">레이크하우스와 벡터 검색</h3>
							<p class="timeline-group__summary">데이터 레이크와 웨어하우스를 합친 레이크하우스 개념이 확산됐고, 생성형 AI를 돕는 벡터 데이터베이스가 실무에 자리 잡기 시작했습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="2020-lakehouse">
								<span class="timeline-event__year">2020</span>
								<span class="timeline-event__label">레이크하우스 전략 발표</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2023-vector">
								<span class="timeline-event__year">2023</span>
								<span class="timeline-event__label">벡터 DB 상용화</span>
							</button>
						</div>
					</section>
				</section>

				<section class="sources" id="sources" aria-labelledby="sources-title">
					<div class="section__head">
						<h2 id="sources-title">참고 자료</h2>
						<p>
							관계형 이론, 분산 DB 설계, 레이크하우스 전략을 소개한 대표 문헌을 모았습니다. 원문을 읽어 보면 당시 엔지니어가 어떤 제약을 풀려고 했는지 더 잘 느낄 수 있습니다.
						</p>
					</div>
					<ul class="source-list">
						<li><a href="https://www.ibm.com/ibm/history/ibm100/us/en/icons/ramac/" target="_blank" rel="noopener">IBM Archives · RAMAC Story</a></li>
						<li><a href="https://archive.computerhistory.org/resources/text/People/CODASYL/CODASYL.CommitteeMinutes.1959.102653978.pdf" target="_blank" rel="noopener">Computer History Museum · CODASYL Minutes</a></li>
						<li><a href="https://dl.acm.org/doi/10.1145/362384.362685" target="_blank" rel="noopener">E.F. Codd · A Relational Model</a></li>
						<li><a href="https://dl.acm.org/doi/10.1145/320434.320440" target="_blank" rel="noopener">Peter Chen · The Entity-Relationship Model</a></li>
						<li><a href="https://www.oracle.com/database/technologies/oracle-database-history.html" target="_blank" rel="noopener">Oracle · Database History</a></li>
						<li><a href="https://www.postgresql.org/about/history/" target="_blank" rel="noopener">PostgreSQL · Project History</a></li>
						<li><a href="https://research.google/pubs/spanner-google-globally-distributed-database/" target="_blank" rel="noopener">Google Research · Spanner Paper</a></li>
						<li><a href="https://research.google/pubs/pub62/" target="_blank" rel="noopener">Google Research · MapReduce</a></li>
						<li><a href="https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf" target="_blank" rel="noopener">Amazon · Dynamo Paper</a></li>
						<li><a href="https://www.mongodb.com/blog/post/mongodb-10" target="_blank" rel="noopener">MongoDB · 1.0 Release Note</a></li>
						<li><a href="https://www.databricks.com/blog/2020/01/30/what-is-a-data-lakehouse.html" target="_blank" rel="noopener">Databricks · Lakehouse Explained</a></li>
						<li><a href="https://www.snowflake.com/en/data-warehouse-architecture/" target="_blank" rel="noopener">Snowflake · Cloud Data Warehouse Architecture</a></li>
						<li><a href="https://www.pinecone.io/learn/vector-database/" target="_blank" rel="noopener">Pinecone · Vector Database Guide</a></li>
					</ul>
				</section>
			</main>

			<footer class="page__footer" role="contentinfo">
				<p>© 2025 ArcherLab · Stories on data through time.</p>
				<a class="page__footer-link" href="https://archerlab.dev" target="_blank" rel="noopener">archerlab.dev</a>
			</footer>
		</div>

		<div class="modal" id="event-modal" role="dialog" aria-modal="true" hidden>
			<div class="modal__overlay" data-modal-close></div>
			<div class="modal__window" role="document" tabindex="-1">
				<button class="modal__close" type="button" aria-label="레이어 닫기" data-modal-close>&times;</button>
				<div class="modal__content"></div>
			</div>
		</div>

		<template id="event-1890-hollerith">
			<article class="event-detail" aria-labelledby="event-1890-hollerith-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1890</p>
					<h2 id="event-1890-hollerith-title">홀러리스 천공 카드 시스템</h2>
					<p class="event-detail__summary">제시간에 인구조사를 끝내야 했던 미국 통계국이 펀치 카드를 도입하면서, 데이터가 처음으로 전기 기계를 타고 흘렀습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>정부는 1880년 인구조사 집계를 끝내는 데 7년을 써버렸습니다. 통계관 헬렌은 “이대로 가면 다음 조사 결과가 나오기도 전에 또 조사를 해야 해요.”라며 한숨을 쉬었습니다. 통계청을 드나들던 허먼 홀러리스는 수레에 전기식 카운터와 펀치 카드를 싣고 와 직접 시연했습니다.</p>
						<p>“구멍이 뚫린 위치를 바늘로 읽으면 숫자를 자동으로 더할 수 있습니다.”라는 설명이 끝나자, 헬렌은 스위치를 눌러 카운터가 돌아가는 모습을 보며 미소를 지었습니다. 덕분에 1890년 인구조사 결과는 2년 만에 발표될 수 있었고, 통계국은 데이터를 기계에 맡기면 시간이 크게 줄어든다는 사실을 체감했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>펀치 카드는 각 칸을 구멍으로 표현해 숫자와 속성을 기록했습니다. 전극이 구멍을 통과하면 전류가 흐르고, 그 신호를 계수 장치가 집계했습니다. 오늘날의 행(row)과 열(column)을 구멍 위치로 표현한 셈입니다. 매뉴얼에는 어떤 질문이 어느 열에 대응되는지 적혀 있어, 모든 조사원이 같은 규칙으로 데이터를 입력할 수 있었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1956-ramac">
			<article class="event-detail" aria-labelledby="event-1956-ramac-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1956</p>
					<h2 id="event-1956-ramac-title">IBM 305 RAMAC · 자기 디스크 도입</h2>
					<p class="event-detail__summary">회계팀은 테이프를 갈아 끼울 시간조차 아까웠습니다. 회전하는 디스크에 데이터를 저장하자 “바로 수정”이라는 개념이 탄생했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>샌프란시스코의 은행 창구는 점심시간마다 줄이 끝이 없었습니다. 회계원 로버트는 “현금 카드 기록만 빨리 갱신하면 줄이 줄 텐데…”라며 이마에 땀을 닦았습니다. IBM이 들고 온 RAMAC은 냉장고만 한 덩치를 자랑했지만, 데이터를 저장한 디스크가 초당 수백 회 회전하면서 원하는 레코드를 즉시 읽어 들였습니다.</p>
						<p>로버트가 카드 번호를 입력하자, 기계는 거대한 암을 움직여 디스크의 정확한 위치를 찾고 “처리 완료”라는 불빛을 켰습니다. 그는 “드디어 대기표를 줄일 수 있겠어.”라며 환하게 웃었습니다. 자기 디스크 덕분에 파일을 순서대로 읽지 않아도 되는 시대가 열렸고, 기업은 실시간 처리에 눈을 뜨기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>RAMAC은 50장의 금속 디스크를 쌓아 5MB의 데이터를 저장했습니다. 테이프처럼 처음부터 끝까지 읽지 않고, 헤드를 이동해 바로 원하는 블록을 찾을 수 있었습니다. 이 <abbr title="온라인 트랜잭션 처리">OLTP</abbr> 방식은 고객 계좌나 재고처럼 즉시 수정해야 하는 데이터를 처리하는 데 필수가 되었고, 이후 데이터베이스 시스템이 디스크를 기본 저장소로 채택하는 계기가 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1959-codasyl">
			<article class="event-detail" aria-labelledby="event-1959-codasyl-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1959</p>
					<h2 id="event-1959-codasyl-title">CODASYL DB 위원회</h2>
					<p class="event-detail__summary">보험사와 제조사가 “회사마다 파일 구조가 달라서 곤란하다”며 모여, 레코드와 링크를 표준화하려고 논의했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>뉴욕의 회의실에는 10여 개 기업 대표가 둘러앉았습니다. “우리 시스템은 고객 레코드 뒤에 바로 계약 레코드를 붙입니다.”, “우리는 반대로 링크를 따로 저장해요.” 서로 다른 설명이 이어지자, 의장 베티는 칠판에 “RECORD · SET · LINK”를 적었습니다.</p>
						<p>밤늦게까지 이어진 회의에서 “링크 이름을 표준화하면 다른 시스템에서도 읽을 수 있어요.”라는 합의가 나왔고, 참석자들은 초안 문서를 집으로 가져가 테스트하기로 했습니다. CODASYL 보고서는 계층형·네트워크형 데이터 모델의 기초가 되었고, 기업들이 대형 프로젝트를 추진할 때 참고서 역할을 했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>CODASYL 모델은 레코드 타입, 세트(set), 오너(owner), 멤버(member)를 정의해 여러 레코드를 포인터로 연결했습니다. 애플리케이션은 포인터를 따라가며 데이터를 탐색해야 했으므로, 개발자는 데이터를 저장하는 순서와 관계를 미리 설계해야 했습니다. 이 노력은 후에 관계형 모델이 제시됐을 때 “선언형으로 데이터를 다루자”는 주장의 배경이 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1966-ims">
			<article class="event-detail" aria-labelledby="event-1966-ims-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1966</p>
					<h2 id="event-1966-ims-title">IMS · 아폴로 부품을 추적하다</h2>
					<p class="event-detail__summary">수천 개 부품을 가진 로켓을 조립하려면, 어떤 공정에서 어떤 부품이 필요한지 즉시 알아야 했습니다. IMS가 그 복잡한 계층을 정리했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>아폴로 계획에 참여한 록웰 공장의 엔지니어들은 “조립 라인에서 볼트 하나라도 없으면 일정이 미뤄집니다.”라며 걱정했습니다. IBM과 협력해 만든 IMS는 조립 단계별로 필요한 부품을 계층 구조로 저장했습니다. 작업자 앤젤라는 터미널에 공정 번호를 입력해 필요한 부품 목록을 즉시 확인했습니다.</p>
						<p>IMS 덕분에 부품 부족이 줄어들자 현장 감독은 “이제는 창고를 뒤지느라 시간을 낭비하지 않아도 된다.”라고 말했습니다. 이후 은행과 항공사도 IMS를 도입해 고객 계좌와 예약 정보를 관리했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>IMS는 계층형 데이터베이스입니다. 루트 세그먼트(예: 프로젝트) 아래에 자식 세그먼트(예: 부품, 공급업체)를 둡니다. 응용 프로그램은 루트에서 자식으로 내려가며 데이터를 읽었습니다. 이러한 구조는 대량의 반복 데이터를 빠르게 처리하지만, 새로운 질의 요구가 생기면 프로그램을 수정해야 했습니다. 이 한계 때문에 관계형 모델의 유연함이 더 돋보이게 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1969-ids">
			<article class="event-detail" aria-labelledby="event-1969-ids-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1969</p>
					<h2 id="event-1969-ids-title">IDS 네트워크 모델</h2>
					<p class="event-detail__summary">항공기 제조사가 “부품이 여러 제품에 동시에 쓰일 때를 표현하고 싶다”고 요청하자, 네트워크형 모델이 등장했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>제너럴 일렉트릭의 개발자 찰스 바크만은 “한 부품이 여러 조립품에 쓰일 때 계층 구조로는 너무 복잡합니다.”라며 고민했습니다. 그가 만든 IDS는 `공급자 → 부품`, `부품 → 제품`처럼 다양한 관계를 포인터로 연결했습니다.</p>
						<p>시연 자리에서 엔지니어 리사는 “이제는 부품이 어느 제품에 쓰이는지 역방향으로도 추적할 수 있네요.”라며 감탄했습니다. IDS는 데이터베이스 설계가 단순 저장을 넘어 탐색을 돕는 도구가 되어야 한다는 인식을 심어 주었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>네트워크형 모델은 레코드를 여러 세트에 연결할 수 있도록 허용합니다. 조인 연산을 명시적으로 작성해야 했지만, 그래프처럼 유연한 연결을 표현할 수 있었습니다. 이 경험은 “질의 언어가 연결을 대신해 주면 얼마나 편할까?”라는 질문을 남겼고, SQL의 필요성을 뚜렷하게 만들었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1970-codd">
			<article class="event-detail" aria-labelledby="event-1970-codd-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1970</p>
					<h2 id="event-1970-codd-title">관계형 모델 논문</h2>
					<p class="event-detail__summary">E.F. Codd는 “데이터를 표로 표현하고 수학적 연산으로 다루자”라고 제안했습니다. 덕분에 개발자는 포인터 대신 선언형 <abbr title="Structured Query Language">SQL</abbr>로 질의를 날릴 수 있게 되었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Codd는 IBM 연구소에서 메인프레임 로그를 분석하며, 포인터와 물리 저장 방식에 얽매인 기존 시스템에 답답함을 느꼈습니다. 그는 “데이터를 집합으로 보고, 필요한 조건만 말하면 시스템이 나머지를 알아서 처리하도록 하자”고 주장했습니다.</p>
						<p>논문이 발표되자 동료 연구원 메리는 “이렇게 하면 새로운 보고서를 만들 때마다 프로그램을 다시 짜지 않아도 되겠네요.”라고 말했습니다. 관계형 모델은 데이터베이스를 단순한 파일 관리가 아니라, 논리적 구조로 바라보는 전환점이 되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>관계형 모델은 릴레이션(테이블), 튜플(행), 속성(열)이라는 개념을 도입했습니다. 선택, 투영, 조인 같은 연산은 수학적 집합 이론을 기반으로 정의되어, 다른 구현에서도 일관되게 사용할 수 있었습니다. ACID 원칙(원자성, 일관성, 독립성, 지속성)을 적용한 트랜잭션 개념도 이후 관계형 DB의 핵심이 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1976-ermodel">
			<article class="event-detail" aria-labelledby="event-1976-ermodel-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1976</p>
					<h2 id="event-1976-ermodel-title">Peter Chen의 ER 모델</h2>
					<p class="event-detail__summary">“업무를 그림으로 그려 봅시다.” Chen은 개체와 관계 다이어그램을 제안해 비기술자도 데이터 모델을 이해하도록 도왔습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>컨설턴트 리즈는 회의실에서 마커를 들고 “고객은 계약을 하나 이상 가진다”라는 문장을 화살표로 표현했습니다. 엔지니어들은 “이제 요구사항을 그림으로 합의할 수 있겠네요.”라며 고개를 끄덕였습니다.</p>
						<p>ER 다이어그램 덕분에 분석가와 개발자가 같은 언어로 이야기하게 되었고, 데이터 모델링이 프로젝트 초반에 논의돼야 할 주제가 되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>ER 모델은 개체(Entity), 관계(Relationship), 속성(Attribute)를 정의해 관계형 스키마 설계에 앞서 개념 모델을 만드는 절차를 정착시켰습니다. 다중성(1:N, M:N)을 다이어그램으로 표현하면서, 실제 테이블 구조로 변환하기 전 잠재적 문제를 조기에 발견할 수 있게 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1979-oracle">
			<article class="event-detail" aria-labelledby="event-1979-oracle-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1979</p>
					<h2 id="event-1979-oracle-title">Oracle V2 · 상용 SQL 데이터베이스</h2>
					<p class="event-detail__summary">“SQL은 연구 프로젝트일 뿐”이라는 회의론이 있었지만, Oracle은 상용 제품으로 내놓아 관계형 DB의 실용성을 입증했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Oracle 직원들은 미 국방부 프로젝트에 참여하며 실험용 SQL 엔진을 다듬었습니다. 배포 첫날, 고객 지원팀은 “SELECT 문장이 이렇게 간단하다니 믿기지 않네요!”라는 전화를 받았습니다.</p>
						<p>성능은 완벽하지 않았지만, 업데이트를 반복하면서 기업 고객을 확보했고 다른 업체들도 관계형 DB 시장에 뛰어들었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Oracle은 SQL 문법을 상용 제품에 적용하고, <abbr title="온라인 트랜잭션 처리">OLTP</abbr> 환경에서 트랜잭션을 지원했습니다. 표준이 정립되기 전이었지만, 관계형 모델을 실제 비즈니스에 적용할 수 있다는 확신을 시장에 심어 주었습니다. 이후 IBM, Microsoft 등도 경쟁 제품을 내놓으며 생태계가 빠르게 성장했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1981-db2">
			<article class="event-detail" aria-labelledby="event-1981-db2-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1981</p>
					<h2 id="event-1981-db2-title">IBM DB2 베타</h2>
					<p class="event-detail__summary">관계형 DB를 메인프레임 주력 제품에 도입하면서, 대기업 업무의 표준으로 자리잡기 시작했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>IBM 고객사 파일럿 현장에서 회계 책임자 수잔은 “복잡한 조인도 SQL 하나로 되네요.”라며 놀랐습니다. DB2는 기존 VSAM 파일을 대체하면서도 성능을 지키기 위해 옵티마이저와 버퍼 풀 기술을 도입했습니다.</p>
						<p>베타 테스트가 성공하자, 은행과 보험사는 본격적으로 관계형 DB로 이주하기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>DB2는 비용 기반 옵티마이저를 도입해 SQL 실행 계획을 자동으로 선택했습니다. 또한 <abbr title="Structure Query Language">SQL</abbr> 표준화 논의를 주도하며 이후 ANSI 표준을 수용했습니다. 기업 고객이 ACID 트랜잭션과 SQL을 본격적으로 채택하는 계기가 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1986-sql-standard">
			<article class="event-detail" aria-labelledby="event-1986-sql-standard-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1986</p>
					<h2 id="event-1986-sql-standard-title">ANSI SQL-86</h2>
					<p class="event-detail__summary">벤더마다 다르던 SQL이 공식 표준을 갖게 되면서, 개발자는 데이터베이스를 바꿔도 익숙한 문법을 유지할 수 있게 되었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>위원회 회의에서 기술자 마크는 “SELECT에서 JOIN을 어떻게 표준화할 것인지 정해야 합니다.”라며 칠판에 문법 후보를 적었습니다. 여러 업체가 타협을 거듭한 끝에, 오늘날 우리가 알고 있는 기본 SQL 문법이 확정되었습니다.</p>
						<p>표준이 발표되자 컨설턴트들은 “이제 고객이 다른 DB로 갈아타도 되겠네요.”라며 안도했습니다. 상호 운용성은 데이터베이스 시장 확대를 촉진했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>SQL-86은 데이터 정의 언어(DDL), 데이터 조작 언어(DML), 트랜잭션 제어를 명확히 구분했습니다. 이 표준 덕분에 JDBC, ODBC 같은 드라이버가 서로 다른 DB를 연결할 수 있게 되었고, 산업 전반에 SQL 교육과 도구가 확산되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1988-teradata">
			<article class="event-detail" aria-labelledby="event-1988-teradata-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1988</p>
					<h2 id="event-1988-teradata-title">Teradata DBC/1012</h2>
					<p class="event-detail__summary">30대 이상의 노드를 병렬로 묶어 초대량 데이터를 처리하면서, 대형 기업의 분석 업무가 새 속도를 얻었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>소매업 분석팀은 매주 수십억 건의 거래 데이터를 집계하느라 서버를 밤새 돌렸습니다. Teradata 시스템이 도입되자, 직원 줄리는 “이제는 새벽에 와서 결과를 확인할 수 있다”며 눈을 반짝였습니다. 여러 노드가 데이터를 나눠 가져가 동시에 처리했기 때문입니다.</p>
						<p>병렬 처리 개념은 이후 데이터 웨어하우스 설계의 기본 원칙이 되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Teradata의 공유-없음(Shared-nothing) 아키텍처는 각 노드에 데이터를 분산 저장하고, <abbr title="Massively Parallel Processing">MPP</abbr> 방식으로 질의를 수행했습니다. 균형 잡힌 파티셔닝과 조인 전략이 필요한 만큼, 데이터 모델링이 더욱 중요해졌습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1995-mysql">
			<article class="event-detail" aria-labelledby="event-1995-mysql-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1995</p>
					<h2 id="event-1995-mysql-title">MySQL 공개</h2>
					<p class="event-detail__summary">웹 개발자들은 가볍고 무료인 데이터베이스를 원했습니다. MySQL은 LAMP 스택의 핵심으로 자리 잡았습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>스타트업 개발자 안나는 “비싼 라이선스를 살 돈이 없어요.”라며 오픈소스 DB를 찾아 헤맸습니다. MySQL은 설치와 설정이 쉬웠고, PHP에서 바로 쿼리를 실행할 수 있었습니다.</p>
						<p>커뮤니티가 빠르게 성장하면서 수많은 튜토리얼과 GUI 툴이 등장했고, 블로그와 쇼핑몰이 MySQL을 중심으로 구축되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>MySQL은 초기에는 MyISAM 스토리지를 사용해 빠른 읽기 성능을 제공했습니다. 이후 InnoDB를 도입해 <abbr title="원자성, 일관성, 독립성, 지속성">ACID</abbr> 트랜잭션과 외래 키를 지원했습니다. 오픈소스 라이선스는 커뮤니티의 빠른 확산을 이끌었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1996-postgres95">
			<article class="event-detail" aria-labelledby="event-1996-postgres95-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1996</p>
					<h2 id="event-1996-postgres95-title">PostgreSQL 6 프리뷰</h2>
					<p class="event-detail__summary">캘리포니아 버클리 연구진이 이어 온 POSTGRES 프로젝트가 커뮤니티와 만나면서, 확장 가능한 오픈소스 DB가 탄생했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>개발자 마이클은 메일링 리스트에서 “사용자 정의 타입을 추가해 봤어요.”라는 글을 발견했습니다. PostgreSQL은 소스 코드를 공개하고 누구나 기능을 확장할 수 있도록 했습니다.</p>
						<p>덕분에 지리 정보, 검색 확장 등 다양한 확장 모듈이 생겨났고, 기업이 필요에 맞게 DB를 조정할 수 있는 옵션이 생겼습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>PostgreSQL은 MVCC(다중 버전 동시성 제어)를 기반으로 동시성을 관리했습니다. 커스텀 함수, 데이터 타입, 인덱스 메서드를 지원해 도메인 특화 기능을 구현하기 쉬웠습니다. 오픈 거버넌스 모델이 장기적인 발전을 가능하게 했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1998-datawarehouse">
			<article class="event-detail" aria-labelledby="event-1998-datawarehouse-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1998</p>
					<h2 id="event-1998-datawarehouse-title">데이터 웨어하우스 참고 모델</h2>
					<p class="event-detail__summary">랄프 킴벌과 빌 인몬의 방법론이 자리 잡으면서, 기업은 경영 보고를 위한 별도 저장소를 설계하기 시작했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>제조업 분석가 지나는 “실시간 시스템에 복잡한 분석 쿼리를 돌리면 느려져요.”라며 고민했습니다. 컨설턴트는 스타 스킴과 ETL 파이프라인을 제안하며, 운영 데이터와 분석 데이터를 분리하자고 설명했습니다.</p>
						<p>이후 조직마다 데이터 웨어하우스 팀이 생겼고, BI(비즈니스 인텔리전스) 도구가 빠르게 보급되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>데이터 웨어하우스는 사실 테이블과 차원 테이블로 나누어 집계 작업을 최적화했습니다. ETL(추출·변환·적재) 과정이 정례화되면서, 데이터 품질과 거버넌스에 대한 조직적 관심이 높아졌습니다. 이는 이후 데이터 레이크, 레이크하우스의 전신이 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2004-mapreduce">
			<article class="event-detail" aria-labelledby="event-2004-mapreduce-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2004</p>
					<h2 id="event-2004-mapreduce-title">Google MapReduce 논문</h2>
					<p class="event-detail__summary">웹 페이지를 색인하려면 수천 대 서버가 필요했습니다. MapReduce는 작업을 작은 조각으로 나누고 자동으로 통합하는 방법을 제시했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>엔지니어 샌디는 야간 배포가 끝나면 실패한 작업을 수동으로 재시작하느라 밤을 새우곤 했습니다. MapReduce 프레임워크가 도입되자, 작업이 자동으로 노드에 분배되고 실패 시 재시도되었습니다.</p>
						<p>이 아이디어는 하둡(Hadoop)으로 구현되어 대규모 로그 분석의 표준 도구가 되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>MapReduce는 map, shuffle, reduce라는 단계를 정의해 분산 처리를 단순화했습니다. 개발자는 데이터를 블록으로 나누고 함수만 작성하면, 프레임워크가 분산 실행과 장애 복구를 담당했습니다. 이는 데이터 레이크 개념과 클라우드 기반 분석의 토대를 닦았습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2006-dynamo">
			<article class="event-detail" aria-labelledby="event-2006-dynamo-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2006</p>
					<h2 id="event-2006-dynamo-title">Amazon Dynamo 설계</h2>
					<p class="event-detail__summary">쇼핑 카트 데이터가 절대 사라지면 안 됐습니다. Dynamo는 분산 시스템에서의 가용성과 일관성 사이 균형을 설명했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>블랙프라이데이 전날, 아마존 엔지니어들은 “어떤 서버가 꺼져도 카트는 살아 있어야 한다.”라는 목표를 세웠습니다. Dynamo는 데이터를 여러 노드에 복제하고, 버전 충돌을 클라이언트에서 해소하는 모델을 택했습니다.</p>
						<p>쇼핑 카트가 한 번도 사라지지 않았다는 보고가 올라오자, 팀은 “우리 목표 달성!”이라며 서로를 격려했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Dynamo는 일관성(consistency), 가용성(availability), 파티션 허용성(partition tolerance) 중 어떤 요소를 선택할지 설명하며 <abbr title="분산 시스템에서 일관성과 가용성의 절충 관계를 설명하는 이론">CAP 정리</abbr> 논의를 촉진했습니다. 키-값 저장소는 이후 NoSQL 시스템의 대표적인 형태가 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2009-mongodb">
			<article class="event-detail" aria-labelledby="event-2009-mongodb-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2009</p>
					<h2 id="event-2009-mongodb-title">MongoDB 1.0</h2>
					<p class="event-detail__summary">웹 서비스는 매일 새로운 필드를 추가해야 했습니다. MongoDB는 스키마를 유연하게 유지하면서도 문서 단위로 데이터를 저장했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>스타트업 엔지니어 재나는 “오늘은 주소에 우편번호가 없고, 내일은 소셜 로그인 정보가 추가됩니다.”라며 고민했습니다. MongoDB는 JSON과 비슷한 BSON 문서로 데이터를 저장해 필드를 자유롭게 추가할 수 있었습니다.</p>
						<p>덕분에 빠르게 변하는 제품 실험을 데이터 모델이 따라갈 수 있게 되었고, NoSQL 열풍이 본격적으로 시작되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>MongoDB는 컬렉션에 문서를 저장하고, 인덱스를 설정해 빠른 조회를 지원했습니다. 강한 스키마가 필요할 때는 유효성 검사를 추가할 수 있지만, 기본적으로 개발 속도를 우선시했습니다. 이는 SQL과 NoSQL을 상황에 따라 선택하는 하이브리드 전략을 탄생시켰습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2012-spanner">
			<article class="event-detail" aria-labelledby="event-2012-spanner-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2012</p>
					<h2 id="event-2012-spanner-title">Spanner · 글로벌 일관성</h2>
					<p class="event-detail__summary">Google은 전 세계 데이터센터에서 하나의 트랜잭션을 실행하기 위해 원자 시계를 도입했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Google 결제팀은 “도쿄와 시카고 서버가 동시에 잔액을 수정하면 어떻게 되나?”라는 질문을 던졌습니다. Spanner는 TrueTime API로 시계 오차를 관리하며, 전역 트랜잭션을 가능하게 했습니다.</p>
						<p>덕분에 글로벌 서비스를 운영하는 기업도 <abbr title="원자성, 일관성, 독립성, 지속성">ACID</abbr> 보장을 유지한 채 대륙 간 복제를 활용할 수 있게 되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Spanner는 다중 버전 복제와 2단계 커밋을 사용했으며, TrueTime이 제공하는 시간 범위를 이용해 직렬화 가능한 순서를 결정했습니다. 이 접근은 클라우드 기반 NewSQL 데이터베이스의 모델이 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2014-kafka">
			<article class="event-detail" aria-labelledby="event-2014-kafka-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2014</p>
					<h2 id="event-2014-kafka-title">Apache Kafka 0.8</h2>
					<p class="event-detail__summary">실시간 이벤트 스트림을 저장하고 다시 재생할 수 있는 플랫폼이 등장하면서, 데이터 파이프라인의 뼈대가 바뀌었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>온라인 서비스 운영자는 “분당 수백만 건의 로그를 안정적으로 받아야 한다”고 호소했습니다. Kafka는 파티션을 여러 브로커에 분산하고, 소비자가 읽은 위치를 기억해 처리 속도를 자유롭게 조절할 수 있게 했습니다.</p>
						<p>덕분에 데이터 웨어하우스, 스트리밍 분석, 마이크로서비스가 Kafka를 중심으로 연결되는 아키텍처가 탄생했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Kafka는 로그를 append-only 구조로 저장하고, 소비자가 원하는 시점부터 다시 읽을 수 있게 했습니다. <abbr title="읽기, 쓰기 작업을 다루는 처리 방식">OLTP</abbr> 시스템과 분석 시스템 사이를 잇는 버퍼가 생기면서, 데이터 지연을 줄이고 마이크로서비스 이벤트 흐름을 표준화할 수 있었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2018-snowflake">
			<article class="event-detail" aria-labelledby="event-2018-snowflake-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2018</p>
					<h2 id="event-2018-snowflake-title">Snowflake 전역 출시</h2>
					<p class="event-detail__summary">스토리지와 컴퓨팅을 분리한 클라우드 데이터 웨어하우스가 대중화되면서, 조직은 필요할 때만 컴퓨팅을 켜서 분석할 수 있게 되었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>분석가 조나는 “보고서 하나 돌릴 때마다 팀 전체가 기다려야 했어요.”라며 웃었습니다. Snowflake는 여러 가상 웨어하우스를 동시에 띄워 서로 간섭 없이 쿼리를 실행하게 했습니다.</p>
						<p>사용한 만큼 비용을 내는 모델 덕분에 중소기업도 고급 분석 인프라를 손쉽게 구축할 수 있었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Snowflake는 스토리지 계층을 중앙화하고, 컴퓨팅 클러스터를 독립적으로 확장할 수 있게 설계했습니다. 세미 구조화 데이터(JSON, Parquet)를 그대로 저장하고 질의할 수 있어, 데이터 레이크와 웨어하우스의 경계를 허물었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2020-lakehouse">
			<article class="event-detail" aria-labelledby="event-2020-lakehouse-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2020</p>
					<h2 id="event-2020-lakehouse-title">레이크하우스 전략</h2>
					<p class="event-detail__summary">데이터 레이크의 유연함과 웨어하우스의 관리 기능을 합치자는 제안이 등장하며, ACID 트랜잭션을 지원하는 데이터 레이크가 확산되었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>분석팀은 “데이터 레이크는 싸지만 신뢰하기 어렵고, 웨어하우스는 비싸요.”라고 푸념했습니다. Databricks는 Delta Lake를 통해 <abbr title="원자성, 일관성, 독립성, 지속성">ACID</abbr> 트랜잭션과 스키마 진화를 지원하며 두 세계를 잇는 전략을 제시했습니다.</p>
						<p>기업은 이제 동일한 저장소에서 배치 분석과 스트리밍 처리를 동시에 실행할 수 있습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>레이크하우스는 테이블 형식 메타데이터와 트랜잭션 로그를 두어 데이터 레이크에 품질 관리 기능을 부여합니다. <abbr title="데이터 레이크">데이터 레이크</abbr>의 확장성과 웨어하우스의 거버넌스를 결합해, 엔지니어링 팀과 분석 팀이 하나의 저장소를 공유할 수 있게 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2023-vector">
			<article class="event-detail" aria-labelledby="event-2023-vector-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2023</p>
					<h2 id="event-2023-vector-title">벡터 데이터베이스 상용화</h2>
					<p class="event-detail__summary">생성형 AI가 등장하자, 문서를 벡터로 변환해 유사도를 빠르게 찾는 데이터베이스가 필요해졌습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>컨택센터 자동화를 맡은 팀은 “질문과 비슷한 답변을 몇 초 안에 찾아서 AI에게 전달해야 해요.”라고 요청했습니다. Pinecone, Weaviate 같은 벡터 DB는 고차원 벡터를 저장하고 근사 최근접 검색을 제공합니다.</p>
						<p>AI 어시스턴트가 답변을 구성하는 데 필요한 맥락을 벡터 DB에서 즉시 가져오자, 팀은 “이제는 답변 품질이 훨씬 안정적이네요.”라고 평가했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>벡터 데이터베이스는 코사인 유사도, 내적 등 벡터 연산을 빠르게 실행하고, HNSW 같은 인덱스를 이용해 대규모 데이터에서도 실시간 검색을 지원합니다. RAG(검색 증강 생성) 파이프라인이 확산되면서 필수 구성 요소로 자리잡았습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<button type="button" class="scroll-top" data-scroll-top aria-label="맨 위로 이동" hidden>↑</button>

		<script src="assets/js/main.js" defer></script>
	</body>
</html>
