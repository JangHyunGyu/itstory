<!DOCTYPE html>
<html lang="ko">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>ArcherLab IT Story · 데이터를 맡기는 기술의 여정</title>
		<meta name="description" content="1890년대 천공 카드에서 2020년대 벡터 검색까지, 데이터를 안전하게 저장하고 꺼내 쓰게 만든 순간을 타임라인으로 정리했습니다." />
		<meta property="og:title" content="ArcherLab IT Story · Database Timeline" />
		<meta property="og:description" content="관계형 모델, NoSQL, 레이크하우스, 벡터 검색까지 이어지는 데이터베이스 역사를 따라가 보세요." />
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700;800&family=Space+Grotesk:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500;600&display=swap" rel="stylesheet">
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css">
		<link rel="stylesheet" href="assets/css/style.css">
		<link rel="alternate" hreflang="ko" href="https://itstory.archerlab.dev/databases.html" />
		<link rel="alternate" hreflang="en" href="https://itstory.archerlab.dev/databases-en.html" />
		<link rel="alternate" hreflang="x-default" href="https://itstory.archerlab.dev/databases-en.html" />
		<link rel="canonical" href="https://itstory.archerlab.dev/databases.html" />
		<script async src="https://www.googletagmanager.com/gtag/js?id=G-EDBPXC8PL7"></script>
		<script defer src="assets/js/ga.js"></script>
	</head>
	<body>
		<div class="page">
			<header class="page__header" role="banner">
				<div class="page__header-left">
					<a class="page__brand" href="https://archerlab.dev" target="_blank" rel="noopener">
						<img src="assets/images/archerlab_mini_logo.png" alt="ArcherLab" class="page__brand-logo" loading="lazy">
						<span class="page__brand-label">ArcherLab Chronicle</span>
					</a>
					<nav class="page__topic-nav" aria-label="주제 전환">
						<a href="index.html">홈 허브</a>
						<a href="computers.html">컴퓨터 연대기</a>
						<a href="networks.html">네트워크 연대기</a>
						<a href="databases.html" class="is-current">데이터베이스 연대기</a>
						<a href="os.html">운영체제 연대기</a>
						<div class="page__topic-nav-group" role="group" aria-label="웹 제작 연대기">
							<span class="page__topic-nav-label">웹 제작 연대기</span>
							<a href="web.html" data-topic-role="parent">웹 제작 연대기 허브</a>
							<a href="web-structure.html" data-topic-role="child">웹 문서 설계 연대기</a>
							<a href="web-styling.html" data-topic-role="child">스타일링 진화 연대기</a>
							<a href="web-interaction.html" data-topic-role="child">브라우저 인터랙션 연대기</a>
							<a href="web-tools.html" data-topic-role="child">웹 제작 도구 연대기</a>
						</div>
						<a href="was.html">웹 서버 연대기</a>
					</nav>
				</div>
				<nav class="page__nav" aria-label="섹션 탐색">
					<a href="#timeline">연도 보기</a>
					<a href="#sources">참고</a>
					<div class="language-switch">
						<label class="sr-only" for="language-select-databases">언어 선택</label>
						<select id="language-select-databases" data-language-switch>
							<option value="databases.html" data-language-code="ko" selected>한국어</option>
							<option value="databases-en.html" data-language-code="en">English</option>
						</select>
					</div>
				</nav>
			</header>

			<main class="page__main" id="main" role="main">
				<section class="timeline-hero" aria-labelledby="timeline-title">
					<div class="timeline-hero__head">
						<p class="hero__eyebrow">Database Story for Curious Builders</p>
						<h1 class="timeline-hero__title" id="timeline-title">펀치 카드부터 레이크하우스까지, 데이터를 맡기는 법을 찾아 온 기록</h1>
						<p class="timeline-hero__lede">
							1890년 미국 통계국 서기들은 인구조사 표를 제때 끝내지 못해 애를 먹었습니다. 허먼 홀러리스가 펀치 카드 기계를 들고 와 “구멍으로 답을 세어 보죠”라고 제안하면서 데이터가 처음 전기 장비를 타고 흘렀습니다. 몇십 년 뒤에는 은행 창구 직원과 로켓 조립 관리자도 “기록 좀 빨리 찾게 해 주세요”라며 자기 디스크와 계층형 모델을 시험했습니다.
						</p>
						<p class="timeline-hero__lede">
							1970년대 E.F. Codd와 Peter Chen은 데이터를 표와 그림으로 설명하는 법을 정리했고, Oracle 같은 팀이 “현장에서도 통한다”는 걸 보여 줬습니다. 1990년대 MySQL과 PostgreSQL은 오픈소스 선택지를 넓혔고, 2000년대 Dynamo와 MongoDB는 분산 웹 서비스를 위해 새로운 저장 방식을 탐색했습니다.
						</p>
						<p class="timeline-hero__lede">
							연도 버튼을 누르면 각 세대가 어떤 문제를 풀고 싶었는지, 그 해법이 오늘날 서비스에 어떻게 이어졌는지 차근차근 만나 볼 수 있습니다. 낯선 용어가 나와도 괜찮아요. 사람과 상황 중심으로 쉽게 풀어 드릴게요.
						</p>
					</div>
				</section>

				<section class="timeline-grid" id="timeline" aria-labelledby="timeline-title" aria-describedby="timeline-instructions">
					<p class="timeline-grid__instructions sr-only" id="timeline-instructions">연도 버튼을 누르면 새 창 없이 팝업 대화 상자가 열리고, 그 자리에서 자세한 이야기를 이어서 읽을 수 있습니다.</p>

					<section class="timeline-group" aria-labelledby="decade-1890 topic-1890">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1890">1890s</p>
							<h3 class="timeline-group__topic" id="topic-1890">인구조사와 펀치 카드 실험</h3>
							<p class="timeline-group__summary">통계국 서기와 엔지니어가 종이 표 대신 펀치 카드와 전기 집계기를 들여와 반복 계산을 기계에 맡겼습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1890-hollerith">
								<span class="timeline-event__year">1890</span>
								<span class="timeline-event__label">홀러리스 천공 카드 시스템</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-1950 topic-1950">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1950">1950s</p>
							<h3 class="timeline-group__topic" id="topic-1950">자기 디스크와 실시간 업데이트</h3>
							<p class="timeline-group__summary">은행과 보험사 팀은 테이프를 갈아 끼우는 시간 대신, 회전하는 디스크로 “필요할 때 바로 고치자”는 새 흐름을 열었습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1956-ramac">
								<span class="timeline-event__year">1956</span>
								<span class="timeline-event__label">IBM 305 RAMAC</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1959-codasyl">
								<span class="timeline-event__year">1959</span>
								<span class="timeline-event__label">CODASYL DB 위원회 발족</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-1960 topic-1960">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1960">1960s</p>
							<h3 class="timeline-group__topic" id="topic-1960">로켓과 은행이 그린 계층 지도</h3>
							<p class="timeline-group__summary">아폴로 부품과 항공 예약처럼 복잡한 정보를 다루던 팀은 데이터를 층층이 쌓거나 링크로 묶는 모델을 실험했습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1966-ims">
								<span class="timeline-event__year">1966</span>
								<span class="timeline-event__label">IBM IMS 가동</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1969-ids">
								<span class="timeline-event__year">1969</span>
								<span class="timeline-event__label">IDS 네트워크 모델</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-1970 topic-1970">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1970">1970s</p>
							<h3 class="timeline-group__topic" id="topic-1970">관계형 사고와 그림 언어</h3>
							<p class="timeline-group__summary">연구자와 설계자는 “조건만 말하면 원하는 표를 보자”는 목표로 SQL과 ER 다이어그램을 정착시켰습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1970-codd">
								<span class="timeline-event__year">1970</span>
								<span class="timeline-event__label">E.F. Codd 관계형 논문</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1976-ermodel">
								<span class="timeline-event__year">1976</span>
								<span class="timeline-event__label">Peter Chen ER 모델</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1979-oracle">
								<span class="timeline-event__year">1979</span>
								<span class="timeline-event__label">Oracle V2 SQL DB</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-1980 topic-1980">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1980">1980s</p>
							<h3 class="timeline-group__topic" id="topic-1980">표준화와 병렬 엔진의 확장</h3>
							<p class="timeline-group__summary">대형 은행과 제조사가 관계형 DB를 기본 도구로 삼자 SQL 표준과 대규모 병렬 엔진이 빠르게 보급됐습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1981-db2">
								<span class="timeline-event__year">1981</span>
								<span class="timeline-event__label">IBM DB2 베타</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1986-sql-standard">
								<span class="timeline-event__year">1986</span>
								<span class="timeline-event__label">ANSI SQL-86 채택</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1988-teradata">
								<span class="timeline-event__year">1988</span>
								<span class="timeline-event__label">Teradata DBC/1012</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-1990 topic-1990">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1990">1990s</p>
							<h3 class="timeline-group__topic" id="topic-1990">오픈소스와 데이터 웨어하우스</h3>
							<p class="timeline-group__summary">웹 서비스와 전자상거래 팀이 가볍고 무료인 DB를 고르고, 경영진은 분석을 위한 별도 창고를 세웠습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1995-mysql">
								<span class="timeline-event__year">1995</span>
								<span class="timeline-event__label">MySQL 공개</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1996-postgres95">
								<span class="timeline-event__year">1996</span>
								<span class="timeline-event__label">PostgreSQL 6 미리보기</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1998-datawarehouse">
								<span class="timeline-event__year">1998</span>
								<span class="timeline-event__label">데이터 웨어하우스 참고 모델</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-2000 topic-2000">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-2000">2000s</p>
							<h3 class="timeline-group__topic" id="topic-2000">웹 규모와 NoSQL 실험</h3>
				<p class="event-detail__summary">MySQL이 무료로 공개되면서 웹 개발자가 손쉽게 설치할 수 있는 데이터베이스가 생겼습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="2004-mapreduce">
					<p>몬티 비데니우스와 데이비드 악스마크는 “작고 빠른 데이터베이스가 필요하다”는 메일에 답하며 MySQL 소스 코드를 공개했습니다. 설치 방법이 담긴 README와 함께 tarball을 게시하자 전 세계 개발자가 내려받기 시작했습니다.</p>
					<p>웹마스터들은 호스팅 서버에 MySQL을 올리고 PHP, Perl 스크립트와 연결했습니다. 방명록과 게시판이 쉽게 돌아가자 “무료인데도 충분히 빠르다”는 입소문이 퍼졌습니다.</p>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2006-dynamo">
					<p>MySQL은 가벼운 스토리지 엔진과 <abbr title="Structured Query Language">SQL</abbr> 인터페이스를 결합했고, LAMP 스택(리눅스·아파치·MySQL·PHP)의 핵심이 되었습니다. 이후 복제와 InnoDB 트랜잭션 엔진이 추가되며 규모가 커졌습니다.</p>
								<span class="timeline-event__label">Amazon Dynamo 설계</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2009-mongodb">
								<span class="timeline-event__year">2009</span>
								<span class="timeline-event__label">MongoDB 1.0</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-2010 topic-2010">
				<p class="event-detail__summary">캘리포니아 버클리 팀이 Postgres95를 PostgreSQL로 이름 바꾸고 표준 SQL 호환성을 강화했습니다.</p>
							<p class="timeline-group__decade" id="decade-2010">2010s</p>
							<h3 class="timeline-group__topic" id="topic-2010">전 세계 일관성과 스트리밍 파이프라인</h3>
							<p class="timeline-group__summary">다국적 서비스는 지구 반대편에서도 같은 데이터를 보려 했고, 이벤트 스트림을 흘려보내며 실시간 분석을 준비했습니다.</p>
					<p>버클리 연구실의 학생들은 마이클 스톤브레이커가 남겨둔 Postgres 코드를 정리해 ‘Postgres95’라는 이름으로 배포했습니다. 곧이어 “SQL 지원을 더 키우자”는 요청이 쏟아지자, 커뮤니티는 PostgreSQL이라는 새 이름과 함께 6.0 프리뷰를 내놓았습니다.</p>
					<p>기여자들은 메일링 리스트에서 타입 확장, MVCC 구현, ODBC 호환성 등을 밤새 논의했습니다. “이제 상용 DB 못지않은 기능을 갖추자”는 목표가 분명해졌습니다.</p>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2012-spanner">
								<span class="timeline-event__year">2012</span>
					<p>PostgreSQL은 확장 가능한 타입, 함수, 인덱스 인터페이스와 MVCC 동시성 제어를 제공했습니다. 커뮤니티 주도 개발 모델이 자리 잡으면서 기업 환경에서도 믿고 쓰는 오픈소스 DB로 성장했습니다.</p>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2014-kafka">
								<span class="timeline-event__year">2014</span>
								<span class="timeline-event__label">Apache Kafka 0.8</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2018-snowflake">
								<span class="timeline-event__year">2018</span>
								<span class="timeline-event__label">Snowflake 전역 출시</span>
							</button>
						</div>
				<p class="event-detail__summary">경영진이 하루치 실적을 한눈에 보고 싶어 하자, 스타 스키마와 ETL을 묶은 데이터 웨어하우스 모델이 확산됐습니다.</p>

					<section class="timeline-group" aria-labelledby="decade-2020 topic-2020">
						<header class="timeline-group__head">
					<p>컨설턴트는 회의실 화이트보드에 별 모양 구조를 그리며 “중앙 사실 테이블에 매출을 담고, 주변에 지점을 두면 매출 분석이 쉬워집니다.”라고 설명했습니다. 경영진은 전날 매출과 재고를 아침 회의 전에 보고 싶어 했고, IT팀은 야간 ETL 파이프라인을 짰습니다.</p>
					<p>보고서는 “데이터 마트를 표준화된 버스로 연결하라”는 가이드와 함께 배포됐고, 기업들은 경쟁하듯 웨어하우스를 구축했습니다. 백업 테이프 대신 SQL로 분석 자료를 뽑는 시대가 열린 셈입니다.</p>
							<p class="timeline-group__summary">데이터 레이크와 웨어하우스를 잇는 설계가 확산되고, 생성형 AI를 돕는 벡터 데이터베이스가 업무에 들어오기 시작했습니다.</p>
						</header>
					<p>스타 스키마는 사실 테이블과 차원 테이블을 구분해 반복 분석을 빠르게 합니다. ETL(추출·변환·적재) 프로세스가 함께 소개되며 운영 DB와 분석 DB를 분리하는 관행이 자리 잡았습니다.</p>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2020-lakehouse">
								<span class="timeline-event__year">2020</span>
								<span class="timeline-event__label">레이크하우스 전략 발표</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2023-vector">
								<span class="timeline-event__year">2023</span>
								<span class="timeline-event__label">벡터 DB 상용화</span>
							</button>
						</div>
					</section>
				<p class="event-detail__summary">구글은 MapReduce 논문을 통해 “맵 함수와 리듀스 함수만 작성하면 수천 대 서버가 나머지를 처리한다”고 소개했습니다.</p>

				<section class="sources" id="sources" aria-labelledby="sources-title">
					<div class="section__head">
					<p>구글 엔지니어들은 웹 색인을 만드는 배치 작업이 서버 수천 대에 흩어져 있다는 사실을 논문으로 공개했습니다. 개발자는 입력을 분해하는 맵 함수와 결과를 합치는 리듀스 함수만 작성하면 되고, 분산과 장애 복구는 프레임워크가 맡는다고 설명했습니다.</p>
					<p>논문이 발표되자 대학과 스타트업은 이를 본떠 하둡을 만들고, 로그 분석과 추천 엔진을 개발했습니다. “대용량 처리가 거창한 장비 없이도 가능하다”는 인식이 퍼졌습니다.</p>
							관계형 이론, 분산 DB 설계, 레이크하우스 전략을 소개한 대표 문헌을 모았습니다. 원문을 읽어 보면 당시 엔지니어가 어떤 제약을 풀려고 했는지 더 잘 느낄 수 있습니다.
						</p>
					<p>MapReduce는 키-값 쌍을 기반으로 Map 단계에서 데이터를 분산하고 Reduce 단계에서 집계합니다. 자동 재시도와 데이터 지역성 최적화 개념이 소개되며 분산 데이터 처리의 기본 패턴이 되었습니다.</p>
					<ul class="source-list">
						<li><a href="https://www.ibm.com/ibm/history/ibm100/us/en/icons/ramac/" target="_blank" rel="noopener">IBM Archives · RAMAC Story</a></li>
						<li><a href="https://archive.computerhistory.org/resources/text/People/CODASYL/CODASYL.CommitteeMinutes.1959.102653978.pdf" target="_blank" rel="noopener">Computer History Museum · CODASYL Minutes</a></li>
						<li><a href="https://dl.acm.org/doi/10.1145/362384.362685" target="_blank" rel="noopener">E.F. Codd · A Relational Model</a></li>
						<li><a href="https://dl.acm.org/doi/10.1145/320434.320440" target="_blank" rel="noopener">Peter Chen · The Entity-Relationship Model</a></li>
						<li><a href="https://www.oracle.com/database/technologies/oracle-database-history.html" target="_blank" rel="noopener">Oracle · Database History</a></li>
						<li><a href="https://www.postgresql.org/about/history/" target="_blank" rel="noopener">PostgreSQL · Project History</a></li>
						<li><a href="https://research.google/pubs/spanner-google-globally-distributed-database/" target="_blank" rel="noopener">Google Research · Spanner Paper</a></li>
						<li><a href="https://research.google/pubs/pub62/" target="_blank" rel="noopener">Google Research · MapReduce</a></li>
						<li><a href="https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf" target="_blank" rel="noopener">Amazon · Dynamo Paper</a></li>
				<p class="event-detail__summary">아마존은 카트가 절대 비지 않도록 이런저런 장애를 견디는 Dynamo 설계를 공개했습니다.</p>
						<li><a href="https://www.databricks.com/blog/2020/01/30/what-is-a-data-lakehouse.html" target="_blank" rel="noopener">Databricks · Lakehouse Explained</a></li>
						<li><a href="https://www.snowflake.com/en/data-warehouse-architecture/" target="_blank" rel="noopener">Snowflake · Cloud Data Warehouse Architecture</a></li>
						<li><a href="https://www.pinecone.io/learn/vector-database/" target="_blank" rel="noopener">Pinecone · Vector Database Guide</a></li>
					<p>프라임 데이를 앞둔 아마존 엔지니어들은 “서버 한 대가 멈춰도 쇼핑카트는 살아 있어야 한다.”고 강조했습니다. 그 결과 노드마다 키 공간을 분담하고, 값이 여러 노드에 복제되는 Dynamo 설계가 탄생했습니다.</p>
					<p>내부 발표가 끝난 뒤 쇼핑카트 팀은 “장애 중에도 바로 응답이 오네요.”라며 안도했습니다. 이후 이 설계는 Cassandra와 Riak 같은 오픈소스 프로젝트에 영감을 주었습니다.</p>
			</main>

					<p>Dynamo는 일관된 해싱, 버전 벡터, 가십 프로토콜을 사용해 확장성과 가용성을 확보했습니다. 강한 일관성 대신 최종 일관성을 선택해 고객 경험을 우선시한 사례입니다.</p>
				<p>© 2025 ArcherLab · Stories on data through time.</p>
				<a class="page__footer-link" href="https://archerlab.dev" target="_blank" rel="noopener">archerlab.dev</a>
			</footer>
		</div>

		<div class="modal" id="event-modal" role="dialog" aria-modal="true" hidden>
			<div class="modal__overlay" data-modal-close></div>
			<div class="modal__window" role="document" tabindex="-1">
				<button class="modal__close" type="button" aria-label="레이어 닫기" data-modal-close>&times;</button>
				<div class="modal__content"></div>
				<p class="event-detail__summary">MongoDB 1.0은 JSON과 비슷한 문서 형식을 그대로 저장해 “스키마를 당장 정하지 않아도 된다”는 자유를 줬습니다.</p>
						<p class="event-detail__summary">E.F. 코드가 “데이터를 표로 생각하고 조건만 적자”는 관계형 모델을 발표했습니다.</p>

		<template id="event-1890-hollerith">
					<p>10gen 팀은 개발자 밋업에서 “MongoDB는 JSON 비슷한 BSON 문서를 그대로 넣을 수 있어요.”라고 소개했습니다. 스타트업 엔지니어들은 빠르게 변하는 제품 스펙을 반영하기 위해 스키마 변경 없이 필드를 추가해 보는 속도에 매력을 느꼈습니다.</p>
					<p>처음에는 작은 프로젝트에 도입됐지만, 곧 로그 수집과 콘텐츠 관리 시스템으로 확산됐습니다. “문서를 그대로 저장하고 바로 꺼내 쓸 수 있다”는 단순함이 힘이었습니다.</p>
							<p>논문이 발표되자 동료들은 화이트보드에 ‘SELECT…WHERE…’를 적어 가며 실험했습니다. 프로토타입 질의기가 금방 등장했고, 포인터를 직접 다루던 개발자들도 “조건만 적으면 결과가 나오네!”라며 고개를 끄덕였습니다.</p>
					<h2 id="event-1890-hollerith-title">홀러리스 천공 카드 시스템</h2>
					<p>MongoDB는 BSON 문서, 동적 스키마, 컬렉션 단위 인덱스, 샤딩을 제공합니다. 개발 속도를 우선하는 서비스에서 초기 스토리지로 사랑받았고, 이후 트랜잭션과 강한 일관성 기능도 추가됐습니다.</p>
							<p>관계형 모델은 테이블, 튜플, 속성 개념과 선택·조인 같은 연산을 정의했습니다. 데이터와 연산을 분리했기 때문에 저장 방식이 바뀌어도 질의 언어는 그대로 둘 수 있었습니다.</p>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>1880년 인구조사 결과를 내는 데 7년이 걸리자 통계국 직원들은 “다음 조사 전에 결과를 못 낼지도 몰라요.”라며 초조해했습니다. 홀러리스는 시연 장비를 가득 실은 수레를 끌고 와 점퍼선을 연결하고, 구멍 뚫린 카드를 기계에 꽂아 보였습니다.</p>
						<p>스위치를 켜자 카운터가 빠르게 숫자를 더했고, 직원들은 “정말 기계가 대신 세 주네요.”라며 놀랐습니다. 새 도구 덕분에 1890년 결과는 2년 만에 발표됐고, 통계국은 반복 계산을 기계에 맡길 수 있다는 자신감을 얻었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>펀치 카드는 행과 열을 구멍 위치로 표현해 전류가 흐르면 숫자가 올라가도록 설계됐습니다. 어떤 질문이 어느 열에 대응되는지 적은 책자를 배포해 전국 사무소가 같은 규칙으로 카드를 뚫을 수 있었습니다.</p>
					</div>
				</section>
				<p class="event-detail__summary">구글은 원자 시계와 GPS 시간을 묶어 지구 어디서나 같은 데이터를 보여 주는 Spanner 구조를 공개했습니다.</p>
						<p class="event-detail__summary">피터 첸이 엔티티-관계(ER) 다이어그램을 소개해 데이터 구조를 그림으로 설명할 수 있게 했습니다.</p>

		<template id="event-1956-ramac">
					<p>구글 데이터센터 엔지니어들은 서버 랙 옆에 작은 원자 시계와 GPS 수신기를 설치했습니다. “TrueTime이라고 부르는 시간 범위만 믿으면 전 세계에 있는 노드가 같은 순서로 트랜잭션을 처리할 수 있어요.”라는 발표가 이어졌습니다.</p>
					<p>전자상거래나 광고 시스템처럼 전 세계 지점이 동시에 데이터를 수정해야 하는 팀에겐 희소식이었습니다. “이제 지역을 넘나드는 은행 계좌도 실시간으로 맞춰질 수 있다”는 기대가 커졌습니다.</p>
							<p>회사 설계자들은 “이 그림만 공유하면 모두가 같은 모델을 떠올리겠네요.”라며 반겼습니다. ER 다이어그램은 요구 사항 회의에서 공통 언어가 되었고, 설계와 구축 단계 사이의 오해를 줄여 주었습니다.</p>
					<h2 id="event-1956-ramac-title">IBM 305 RAMAC · 자기 디스크 도입</h2>
					<p>Spanner는 TrueTime API, Paxos 기반 복제, 2단계 커밋을 조합해 글로벌 트랜잭션을 제공합니다. 강한 일관성과 수평 확장성을 동시에 추구한 대표 사례입니다.</p>
							<p>ER 다이어그램은 엔티티(사각형), 관계(마름모), 속성(타원)으로 구성됩니다. 관계의 방향과 수량을 표기해 개발자와 현업이 같은 구조를 공유할 수 있게 했습니다.</p>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>점심시간이면 은행 창구 줄이 문 밖까지 이어졌습니다. “계좌 잔액만 빨리 확인할 수 있다면…” 직원들이 한숨을 쉬는 사이 IBM 기술자가 냉장고만 한 RAMAC을 설치했습니다. 회전하는 디스크에서 데이터가 바로 튀어나오도록 만든 장치였습니다.</p>
						<p>계좌 번호를 입력하자 금속 팔이 특정 위치로 움직였고, 몇 초 뒤 “처리 완료” 불빛이 켜졌습니다. 창구 직원은 “고객이 더 이상 줄 서다 돌아가지 않겠다.”며 안도했습니다. 기업은 이 경험을 계기로 데이터를 실시간으로 고칠 수 있는 시스템 설계를 꿈꾸기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>RAMAC은 50장의 금속 디스크에 5MB를 담고, 헤드를 옮겨 바로 원하는 블록을 읽어냈습니다. 테이프처럼 처음부터 끝까지 감지 않아도 되어 온라인 트랜잭션 처리(<abbr title="온라인 트랜잭션 처리">OLTP</abbr>) 개념이 자리 잡는 출발점이 되었습니다.</p>
					</div>
				</section>
				<p class="event-detail__summary">카프카 0.8은 파티션 복제를 안정화해 스트리밍 파이프라인을 운영 환경으로 끌어올렸습니다.</p>
						<p class="event-detail__summary">오라클 팀이 V2를 내놓으며 “현장에서도 SQL이 통한다”는 사실을 증명했습니다.</p>

		<template id="event-1959-codasyl">
					<p>링크트인 팀은 0.8 릴리스를 준비하며 “리더가 다운돼도 팔로워가 바로 이어받도록 하자”고 목표를 세웠습니다. 배포 후 운영자는 토픽을 파티션별로 모니터링하며 스트림이 끊기지 않는지 확인했습니다.</p>
					<p>이 버전 이후 기업들은 로그, 이벤트, 지표를 카프카로 모으고, 실시간 정제 파이프라인을 꾸렸습니다. “데이터를 메시지처럼 흘려보내자”는 발상이 주류가 되었습니다.</p>
							<p>첫 고객사가 시험 운용을 마치자 관리자에게서 전화가 왔습니다. “터미널에서 바로 질의하니 보고서가 금방 나오네요.” 이 피드백은 상용 SQL 데이터베이스가 실무에서도 충분히 버틸 수 있다는 자신감을 심어 주었습니다.</p>
					<h2 id="event-1959-codasyl-title">CODASYL DB 위원회</h2>
					<p>카프카는 파티션, 오프셋, 소비자 그룹 개념으로 확장성과 재처리를 보장합니다. 0.8 버전의 복제와 컨트롤러 기능은 이후 스트리밍 생태계(ksqlDB, Flink 연동)의 토대가 되었습니다.</p>
							<p>Oracle V2는 SQL을 표준 질의 언어로 내세운 첫 상용 데이터베이스 중 하나였습니다. 이 경험을 바탕으로 트랜잭션, 잠금, 백업 같은 운영 기능이 빠르게 다듬어졌습니다.</p>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>뉴욕 회의실에 모인 대표들은 서로 다른 파일 구조를 설명하느라 진땀을 뺐습니다. “우리는 고객 다음에 계약서를 붙여요.” “우리는 링크를 따로 둡니다.” 이야기가 엇갈리자 의장이 칠판에 RECORD, SET, LINK를 적으며 기준을 정하자고 제안했습니다.</p>
						<p>밤늦게까지 토론한 끝에 “링크 이름과 방향만 맞추면 서로 이해할 수 있다.”는 합의가 나왔고, 초안 문서를 갖고 돌아가 각자 시스템에 적용해 보기로 했습니다. 이렇게 정리된 보고서는 계층형과 네트워크형 데이터베이스 설계의 기본 교과서가 되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>CODASYL 모델은 레코드 타입과 세트, 오너, 멤버 개념으로 포인터를 연결했습니다. 개발자가 직접 포인터를 따라가야 했기 때문에 저장 순서와 탐색 경로를 미리 설계해야 했고, 이 경험이 나중에 “조건만 적으면 되면 좋겠다”는 관계형 사고로 이어졌습니다.</p>
					</div>
				</section>
				<p class="event-detail__summary">Snowflake는 “스토리지와 컴퓨팅을 분리했다”는 콘셉트로 클라우드 데이터 웨어하우스 시장을 흔들었습니다.</p>
						<p class="event-detail__summary">IBM은 메인프레임 고객에게 DB2 베타를 배포해 SQL 기반 업무 처리를 시험했습니다.</p>

		<template id="event-1966-ims">
					<p>데이터 팀은 “서버 관리 없이 테이블만 만들면 된다”는 데모를 보고 Snowflake 계정을 열었습니다. CSV와 JSON을 올린 뒤 가상 웨어하우스를 켜면 몇 분 만에 분석이 가능했습니다.</p>
					<p>사용량 기반 요금제 덕분에 스타트업도 부담 없이 시작했고, 필요할 때만 컴퓨팅 클러스터를 키우는 방식을 배웠습니다. 글로벌 리전 확장과 복제가 기본으로 제공된 것도 큰 매력으로 꼽혔습니다.</p>
							<p>시범 운영을 마친 고객사는 “야간 배치 시간을 줄일 수 있겠어요.”라는 소감을 전했습니다. IBM은 수집된 피드백을 바탕으로 옵티마이저와 잠금 전략을 다듬어 정식 출시 준비에 속도를 냈습니다.</p>
					<h2 id="event-1966-ims-title">IMS · 아폴로 부품을 추적하다</h2>
					<p>Snowflake는 중앙 스토리지 레이어와 독립적인 컴퓨팅 웨어하우스를 분리해 동시성을 높였습니다. 자동 최적화와 공유 기능으로 여러 팀이 같은 데이터를 안전하게 reuse할 수 있었습니다.</p>
							<p>DB2는 메인프레임 운영체제 MVS 위에서 돌아갔으며, SQL 옵티마이저와 버퍼 풀 관리기를 제공했습니다. 기존 IMS와 VSAM 환경에서 관계형 DB로 전환할 수 있는 가교 역할을 했습니다.</p>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>록웰 공장의 엔지니어들은 “볼트 하나만 없으면 로켓 일정이 미뤄져요.”라며 머리를 싸맸습니다. IBM과 함께 만든 IMS는 공정 → 하위 공정 → 부품 순으로 정보를 저장해 터미널 번호만 입력하면 필요한 목록을 보여 줬습니다.</p>
						<p>부품 부족 알람이 줄자 현장 감독은 “창고를 뒤지느라 밤을 새지 않아도 되겠네.”라며 웃었습니다. 은행과 항공사도 IMS를 도입해 계좌와 예약 정보를 비슷한 방식으로 관리했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>IMS는 루트 세그먼트 아래에 자식 세그먼트를 두는 계층형 구조입니다. 반복 처리는 빠르지만 새로운 조회 방식이 필요하면 프로그램을 새로 짜야 했고, 이런 불편이 관계형 모델의 장점을 부각시켰습니다.</p>
					</div>
				</section>
				<p class="event-detail__summary">데이터브릭스는 “데이터 레이크와 웨어하우스를 합치자”며 레이크하우스 전략을 소개했습니다.</p>
						<p class="event-detail__summary">ANSI와 ISO가 첫 SQL 표준을 확정해 “SELECT-FROM-WHERE” 문법을 공식 언어로 인정했습니다.</p>

		<template id="event-1969-ids">
					<p>데이터 과학팀은 “데이터 레이크엔 원본이 있지만, 쿼리를 하려면 웨어하우스로 옮겨야 한다”며 이중 유지 비용에 지쳤습니다. 레이크하우스 제안은 파일 위에 테이블 계층을 올리고, 트랜잭션 로그로 일관성을 지키자는 아이디어였습니다.</p>
					<p>시연에서 데이터브릭스는 버저닝된 Delta 테이블을 롤백하는 모습을 보여 주었고, 분석가들은 “복잡한 파이프라인 없이도 신뢰할 수 있겠다”고 반응했습니다. 경쟁 솔루션도 비슷한 방향을 채택했습니다.</p>
							<p>합의가 이뤄진 뒤에는 “이제 고객이 다른 DB로 옮겨도 질의가 돌아가겠군요.”라는 안도감이 퍼졌습니다. 교육 교재와 도구도 표준 문법을 기준으로 다시 집필됐습니다.</p>
					<h2 id="event-1969-ids-title">IDS 네트워크 모델</h2>
					<p>레이크하우스는 오픈 테이블 포맷(Delta Lake, Apache Iceberg, Apache Hudi)을 사용해 ACID 트랜잭션과 스키마 진화를 지원합니다. 머신러닝, BI, 스트리밍을 하나의 저장소에서 처리하려는 흐름을 상징합니다.</p>
							<p>SQL-86은 SELECT, INSERT, UPDATE, DELETE, 뷰 정의, 트랜잭션 제어 등을 포함했습니다. 이후 SQL-89, SQL-92로 확장되며 벤더 간 호환성을 높이는 기반이 되었습니다.</p>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>제너럴 일렉트릭의 찰스 바크만은 “같은 부품이 여러 조립품에 쓰이는데 계층 구조로는 길이 꼬입니다.”라고 토로했습니다. 그가 만든 IDS는 공급자↔부품↔제품 관계를 포인터로 연결해 원하는 방향으로 따라갈 수 있게 했습니다.</p>
						<p>시연을 보던 엔지니어는 “이제 부품이 어디에 쓰였는지 거꾸로도 찾아지네요.”라며 고개를 끄덕였습니다. IDS는 데이터베이스가 저장 창고를 넘어 탐색 도구가 되어야 한다는 생각을 퍼뜨렸습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>네트워크형 모델은 레코드가 여러 세트에 속할 수 있어 그래프처럼 유연합니다. 대신 개발자가 직접 조인 경로를 짜야 했고, 이 수고가 “언어가 대신 연결해 주면 좋겠다”는 SQL 아이디어로 이어졌습니다.</p>
					</div>
				</section>
				<p class="event-detail__summary">생성형 AI 붐과 함께 문장을 벡터로 저장해 비슷한 의미를 찾는 데이터베이스가 업무 현장에 들어왔습니다.</p>
						<p class="event-detail__summary">테라데이터는 수십 개 노드를 묶은 병렬 데이터베이스로 대형 유통사의 분석 속도를 끌어올렸습니다.</p>

		<template id="event-1970-codd">
					<p>제품 팀은 “챗봇이 회사 문서를 기억하게 하려면 어떻게 해야 할까?”라는 고민 끝에 문장을 임베딩 벡터로 변환해 저장하기 시작했습니다. 벡터 DB는 입력 문장과 가장 가까운 의미를 가진 문서를 몇 밀리초 만에 찾아줬습니다.</p>
					<p>파일럿 운영에서 상담원이 “AI가 바로 관련 매뉴얼을 보여 줘서 답변 시간이 줄었어요.”라고 말하자, 다른 부서도 관심을 보였습니다. 검색 정확도와 지연 시간을 모두 챙겨야 한다는 과제가 주어졌습니다.</p>
							<p>이틀째 되는 날 야간 배치가 끝나자 분석가는 “이전보다 네 배나 빨리 보고서를 받았어요.”라며 놀랐습니다. 병렬 엔진은 이후 금융, 통신사로 퍼져 대용량 분석의 표준이 되었습니다.</p>
					<h2 id="event-1970-codd-title">관계형 모델 논문</h2>
					<p>벡터 데이터베이스는 임베딩, 근사 최근접 탐색(ANN), 필터링을 조합해 의미 기반 검색을 제공합니다. 보안 구분과 업데이트 지연을 줄이기 위한 하이브리드 쿼리, 캐시 전략이 함께 논의되고 있습니다.</p>
							<p>DBC/1012는 공유 없음 구조에 BYNET 스위치를 더해 노드 간 데이터를 교환했습니다. 거대한 쿼리를 작은 작업으로 나눠 동시에 처리하는 MPP 패턴이 이때 자리 잡았습니다.</p>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Codd는 IBM 연구소에서 메인프레임 로그를 분석하며, 포인터와 물리 저장 방식에 얽매인 기존 시스템에 답답함을 느꼈습니다. 그는 “데이터를 집합으로 보고, 필요한 조건만 말하면 시스템이 나머지를 알아서 처리하도록 하자”고 주장했습니다.</p>
						<p>논문이 발표되자 동료 연구원은 “이렇게 하면 새로운 보고서를 만들 때마다 프로그램을 다시 짜지 않아도 되겠네요.”라고 말했습니다. 관계형 모델은 데이터베이스를 단순한 파일 관리가 아니라, 논리적 구조로 바라보는 전환점이 되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>관계형 모델은 릴레이션(테이블), 튜플(행), 속성(열)이라는 개념을 도입했습니다. 선택, 투영, 조인 같은 연산은 수학적 집합 이론을 기반으로 정의되어, 다른 구현에서도 일관되게 사용할 수 있었습니다. ACID 원칙(원자성, 일관성, 독립성, 지속성)을 적용한 트랜잭션 개념도 이후 관계형 DB의 핵심이 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1976-ermodel">
			<article class="event-detail" aria-labelledby="event-1976-ermodel-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1976</p>
					<h2 id="event-1976-ermodel-title">Peter Chen의 ER 모델</h2>
					<p class="event-detail__summary">Peter Chen은 “업무를 그림으로 설명하게 도와 줄게요”라며 개체와 관계를 나란히 보여 주는 ER 다이어그램을 발표했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>한 컨설턴트는 회의실에서 마커를 들고 “고객은 계약을 하나 이상 가진다”라는 문장을 화살표로 표현했습니다. 엔지니어들은 “이제 요구사항을 그림으로 합의할 수 있겠네요.”라며 고개를 끄덕였습니다.</p>
						<p>ER 다이어그램 덕분에 분석가와 개발자가 같은 언어로 이야기하게 되었고, 데이터 모델링이 프로젝트 초반에 논의돼야 할 주제가 되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>ER 모델은 개체(Entity), 관계(Relationship), 속성(Attribute)를 정의해 관계형 스키마 설계에 앞서 개념 모델을 만드는 절차를 정착시켰습니다. 다중성(1:N, M:N)을 다이어그램으로 표현하면서, 실제 테이블 구조로 변환하기 전 잠재적 문제를 조기에 발견할 수 있게 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1979-oracle">
			<article class="event-detail" aria-labelledby="event-1979-oracle-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1979</p>
					<h2 id="event-1979-oracle-title">Oracle V2 · 상용 SQL 데이터베이스</h2>
					<p class="event-detail__summary">Oracle은 “연구실 말고 현장에서도 관계형 DB를 쓰자”며 SQL 제품을 출시해 실용성을 증명했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Oracle 직원들은 미 국방부 프로젝트에 참여하며 실험용 SQL 엔진을 다듬었습니다. 배포 첫날, 고객 지원팀은 “SELECT 문장이 이렇게 간단하다니 믿기지 않네요!”라는 전화를 받았습니다.</p>
						<p>성능은 완벽하지 않았지만, 업데이트를 반복하면서 기업 고객을 확보했고 다른 업체들도 관계형 DB 시장에 뛰어들었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Oracle은 SQL 문법을 상용 제품에 적용하고, <abbr title="온라인 트랜잭션 처리">OLTP</abbr> 환경에서 트랜잭션을 지원했습니다. 표준이 정립되기 전이었지만, 관계형 모델을 실제 비즈니스에 적용할 수 있다는 확신을 시장에 심어 주었습니다. 이후 IBM, Microsoft 등도 경쟁 제품을 내놓으며 생태계가 빠르게 성장했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1981-db2">
			<article class="event-detail" aria-labelledby="event-1981-db2-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1981</p>
					<h2 id="event-1981-db2-title">IBM DB2 베타</h2>
					<p class="event-detail__summary">IBM은 메인프레임 고객에게 DB2를 소개하며 “대형 업무도 표 기반으로 전환할 수 있다”는 확신을 심어 줬습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>IBM 고객사 파일럿 현장에서 한 회계 책임자는 “복잡한 조인도 SQL 하나로 되네요.”라며 놀랐습니다. DB2는 기존 VSAM 파일을 대체하면서도 성능을 지키기 위해 옵티마이저와 버퍼 풀 기술을 도입했습니다.</p>
						<p>베타 테스트가 성공하자, 은행과 보험사는 본격적으로 관계형 DB로 이주하기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>DB2는 비용 기반 옵티마이저를 도입해 SQL 실행 계획을 자동으로 선택했습니다. 또한 <abbr title="Structure Query Language">SQL</abbr> 표준화 논의를 주도하며 이후 ANSI 표준을 수용했습니다. 기업 고객이 ACID 트랜잭션과 SQL을 본격적으로 채택하는 계기가 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1986-sql-standard">
			<article class="event-detail" aria-labelledby="event-1986-sql-standard-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1986</p>
					<h2 id="event-1986-sql-standard-title">ANSI SQL-86</h2>
					<p class="event-detail__summary">ANSI 승인을 받은 SQL-86 덕분에 개발자들은 제품을 바꿔도 익숙한 문법을 유지할 수 있다고 안심했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>위원회 회의에서 한 기술자는 “SELECT에서 JOIN을 어떻게 표준화할 것인지 정해야 합니다.”라며 칠판에 문법 후보를 적었습니다. 여러 업체가 타협을 거듭한 끝에, 오늘날 우리가 알고 있는 기본 SQL 문법이 확정되었습니다.</p>
						<p>표준이 발표되자 컨설턴트들은 “이제 고객이 다른 DB로 갈아타도 되겠네요.”라며 안도했습니다. 상호 운용성은 데이터베이스 시장 확대를 촉진했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>SQL-86은 데이터 정의 언어(DDL), 데이터 조작 언어(DML), 트랜잭션 제어를 명확히 구분했습니다. 이 표준 덕분에 JDBC, ODBC 같은 드라이버가 서로 다른 DB를 연결할 수 있게 되었고, 산업 전반에 SQL 교육과 도구가 확산되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1988-teradata">
			<article class="event-detail" aria-labelledby="event-1988-teradata-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1988</p>
					<h2 id="event-1988-teradata-title">Teradata DBC/1012</h2>
					<p class="event-detail__summary">Teradata의 DBC/1012는 수십 대 노드를 나란히 돌려 “이만한 데이터도 나눠서 계산할 수 있다”는 자신감을 줬습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>소매업 분석팀은 매주 수십억 건의 거래 데이터를 집계하느라 서버를 밤새 돌렸습니다. Teradata 시스템이 도입되자, 한 직원은 “이제는 새벽에 와서 결과를 확인할 수 있다”며 눈을 반짝였습니다. 여러 노드가 데이터를 나눠 가져가 동시에 처리했기 때문입니다.</p>
						<p>병렬 처리 개념은 이후 데이터 웨어하우스 설계의 기본 원칙이 되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Teradata의 공유-없음(Shared-nothing) 아키텍처는 각 노드에 데이터를 분산 저장하고, <abbr title="Massively Parallel Processing">MPP</abbr> 방식으로 질의를 수행했습니다. 균형 잡힌 파티셔닝과 조인 전략이 필요한 만큼, 데이터 모델링이 더욱 중요해졌습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1995-mysql">
			<article class="event-detail" aria-labelledby="event-1995-mysql-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1995</p>
					<h2 id="event-1995-mysql-title">MySQL 공개</h2>
					<p class="event-detail__summary">웹 개발자들은 “가볍고 공짜면 좋겠어”라고 말했고, MySQL이 LAMP 스택의 기본 선택이 되었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>한 스타트업 개발자는 “비싼 라이선스를 살 돈이 없어요.”라며 오픈소스 DB를 찾아 헤맸습니다. MySQL은 설치와 설정이 쉬웠고, PHP에서 바로 쿼리를 실행할 수 있었습니다.</p>
						<p>커뮤니티가 빠르게 성장하면서 수많은 튜토리얼과 GUI 툴이 등장했고, 블로그와 쇼핑몰이 MySQL을 중심으로 구축되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>MySQL은 초기에는 MyISAM 스토리지를 사용해 빠른 읽기 성능을 제공했습니다. 이후 InnoDB를 도입해 <abbr title="원자성, 일관성, 독립성, 지속성">ACID</abbr> 트랜잭션과 외래 키를 지원했습니다. 오픈소스 라이선스는 커뮤니티의 빠른 확산을 이끌었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1996-postgres95">
			<article class="event-detail" aria-labelledby="event-1996-postgres95-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1996</p>
					<h2 id="event-1996-postgres95-title">PostgreSQL 6 프리뷰</h2>
					<p class="event-detail__summary">버클리 POSTGRES 연구는 커뮤니티와 합쳐져 PostgreSQL이 확장 가능한 오픈소스 데이터베이스로 자리 잡게 했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>한 개발자는 메일링 리스트에서 “사용자 정의 타입을 추가해 봤어요.”라는 글을 발견했습니다. PostgreSQL은 소스 코드를 공개하고 누구나 기능을 확장할 수 있도록 했습니다.</p>
						<p>덕분에 지리 정보, 검색 확장 등 다양한 확장 모듈이 생겨났고, 기업이 필요에 맞게 DB를 조정할 수 있는 옵션이 생겼습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>PostgreSQL은 MVCC(다중 버전 동시성 제어)를 기반으로 동시성을 관리했습니다. 커스텀 함수, 데이터 타입, 인덱스 메서드를 지원해 도메인 특화 기능을 구현하기 쉬웠습니다. 오픈 거버넌스 모델이 장기적인 발전을 가능하게 했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1998-datawarehouse">
			<article class="event-detail" aria-labelledby="event-1998-datawarehouse-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1998</p>
					<h2 id="event-1998-datawarehouse-title">데이터 웨어하우스 참고 모델</h2>
					<p class="event-detail__summary">랄프 킴벌과 빌 인몬은 “운영 데이터와 보고 데이터는 다르게 다뤄야 한다”며 데이터 웨어하우스 설계를 정리했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>한 제조업 분석가는 “실시간 시스템에 복잡한 분석 쿼리를 돌리면 느려져요.”라며 고민했습니다. 컨설턴트는 스타 스킴과 ETL 파이프라인을 제안하며, 운영 데이터와 분석 데이터를 분리하자고 설명했습니다.</p>
						<p>이후 조직마다 데이터 웨어하우스 팀이 생겼고, BI(비즈니스 인텔리전스) 도구가 빠르게 보급되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>데이터 웨어하우스는 사실 테이블과 차원 테이블로 나누어 집계 작업을 최적화했습니다. ETL(추출·변환·적재) 과정이 정례화되면서, 데이터 품질과 거버넌스에 대한 조직적 관심이 높아졌습니다. 이는 이후 데이터 레이크, 레이크하우스의 전신이 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2004-mapreduce">
			<article class="event-detail" aria-labelledby="event-2004-mapreduce-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2004</p>
					<h2 id="event-2004-mapreduce-title">Google MapReduce 논문</h2>
					<p class="event-detail__summary">Google 엔지니어는 수천 대 서버에 흩어진 로그를 “나눠 계산하고 다시 합치자”며 MapReduce 모델을 선보였습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>한 엔지니어는 야간 배포가 끝나면 실패한 작업을 수동으로 재시작하느라 밤을 새우곤 했습니다. MapReduce 프레임워크가 도입되자, 작업이 자동으로 노드에 분배되고 실패 시 재시도되었습니다.</p>
						<p>이 아이디어는 하둡(Hadoop)으로 구현되어 대규모 로그 분석의 표준 도구가 되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>MapReduce는 map, shuffle, reduce라는 단계를 정의해 분산 처리를 단순화했습니다. 개발자는 데이터를 블록으로 나누고 함수만 작성하면, 프레임워크가 분산 실행과 장애 복구를 담당했습니다. 이는 데이터 레이크 개념과 클라우드 기반 분석의 토대를 닦았습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2006-dynamo">
			<article class="event-detail" aria-labelledby="event-2006-dynamo-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2006</p>
					<h2 id="event-2006-dynamo-title">Amazon Dynamo 설계</h2>
					<p class="event-detail__summary">Amazon은 “쇼핑 카트는 절대 사라지면 안 돼”라며 가용성과 일관성 균형을 설명한 Dynamo 설계를 공유했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>블랙프라이데이 전날, 아마존 엔지니어들은 “어떤 서버가 꺼져도 카트는 살아 있어야 한다.”라는 목표를 세웠습니다. Dynamo는 데이터를 여러 노드에 복제하고, 버전 충돌을 클라이언트에서 해소하는 모델을 택했습니다.</p>
						<p>쇼핑 카트가 한 번도 사라지지 않았다는 보고가 올라오자, 팀은 “우리 목표 달성!”이라며 서로를 격려했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Dynamo는 일관성(consistency), 가용성(availability), 파티션 허용성(partition tolerance) 중 어떤 요소를 선택할지 설명하며 <abbr title="분산 시스템에서 일관성과 가용성의 절충 관계를 설명하는 이론">CAP 정리</abbr> 논의를 촉진했습니다. 키-값 저장소는 이후 NoSQL 시스템의 대표적인 형태가 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2009-mongodb">
			<article class="event-detail" aria-labelledby="event-2009-mongodb-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2009</p>
					<h2 id="event-2009-mongodb-title">MongoDB 1.0</h2>
					<p class="event-detail__summary">스타트업 개발자들은 매일 바뀌는 필드를 감당하려고, 스키마를 느슨하게 다루는 MongoDB 문서 저장소를 도입했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>한 스타트업 엔지니어는 “오늘은 주소에 우편번호가 없고, 내일은 소셜 로그인 정보가 추가됩니다.”라며 고민했습니다. MongoDB는 JSON과 비슷한 BSON 문서로 데이터를 저장해 필드를 자유롭게 추가할 수 있었습니다.</p>
						<p>덕분에 빠르게 변하는 제품 실험을 데이터 모델이 따라갈 수 있게 되었고, NoSQL 열풍이 본격적으로 시작되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>MongoDB는 컬렉션에 문서를 저장하고, 인덱스를 설정해 빠른 조회를 지원했습니다. 강한 스키마가 필요할 때는 유효성 검사를 추가할 수 있지만, 기본적으로 개발 속도를 우선시했습니다. 이는 SQL과 NoSQL을 상황에 따라 선택하는 하이브리드 전략을 탄생시켰습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2012-spanner">
			<article class="event-detail" aria-labelledby="event-2012-spanner-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2012</p>
					<h2 id="event-2012-spanner-title">Spanner · 글로벌 일관성</h2>
					<p class="event-detail__summary">Google은 세계 곳곳 데이터센터에서 같은 트랜잭션이 실행되도록, 원자 시계와 정밀한 시간 동기화를 갖춘 Spanner를 구축했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Google 결제팀은 “도쿄와 시카고 서버가 동시에 잔액을 수정하면 어떻게 되나?”라는 질문을 던졌습니다. Spanner는 TrueTime API로 시계 오차를 관리하며, 전역 트랜잭션을 가능하게 했습니다.</p>
						<p>덕분에 글로벌 서비스를 운영하는 기업도 <abbr title="원자성, 일관성, 독립성, 지속성">ACID</abbr> 보장을 유지한 채 대륙 간 복제를 활용할 수 있게 되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Spanner는 다중 버전 복제와 2단계 커밋을 사용했으며, TrueTime이 제공하는 시간 범위를 이용해 직렬화 가능한 순서를 결정했습니다. 이 접근은 클라우드 기반 NewSQL 데이터베이스의 모델이 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2014-kafka">
			<article class="event-detail" aria-labelledby="event-2014-kafka-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2014</p>
					<h2 id="event-2014-kafka-title">Apache Kafka 0.8</h2>
					<p class="event-detail__summary">LinkedIn 엔지니어는 “이벤트를 한 번 쓰고 여러 팀이 나눠 듣게 하자”며 Kafka 스트리밍 플랫폼을 오픈소스로 공개했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>온라인 서비스 운영자는 “분당 수백만 건의 로그를 안정적으로 받아야 한다”고 호소했습니다. Kafka는 파티션을 여러 브로커에 분산하고, 소비자가 읽은 위치를 기억해 처리 속도를 자유롭게 조절할 수 있게 했습니다.</p>
						<p>덕분에 데이터 웨어하우스, 스트리밍 분석, 마이크로서비스가 Kafka를 중심으로 연결되는 아키텍처가 탄생했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Kafka는 로그를 append-only 구조로 저장하고, 소비자가 원하는 시점부터 다시 읽을 수 있게 했습니다. <abbr title="읽기, 쓰기 작업을 다루는 처리 방식">OLTP</abbr> 시스템과 분석 시스템 사이를 잇는 버퍼가 생기면서, 데이터 지연을 줄이고 마이크로서비스 이벤트 흐름을 표준화할 수 있었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2018-snowflake">
			<article class="event-detail" aria-labelledby="event-2018-snowflake-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2018</p>
					<h2 id="event-2018-snowflake-title">Snowflake 전역 출시</h2>
					<p class="event-detail__summary">Snowflake는 저장소와 컴퓨팅을 분리해 “필요한 순간에만 파워를 켜자”는 클라우드 데이터 웨어하우스를 확산시켰습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>한 분석가는 “보고서 하나 돌릴 때마다 팀 전체가 기다려야 했어요.”라며 웃었습니다. Snowflake는 여러 가상 웨어하우스를 동시에 띄워 서로 간섭 없이 쿼리를 실행하게 했습니다.</p>
						<p>사용한 만큼 비용을 내는 모델 덕분에 중소기업도 고급 분석 인프라를 손쉽게 구축할 수 있었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Snowflake는 스토리지 계층을 중앙화하고, 컴퓨팅 클러스터를 독립적으로 확장할 수 있게 설계했습니다. 세미 구조화 데이터(JSON, Parquet)를 그대로 저장하고 질의할 수 있어, 데이터 레이크와 웨어하우스의 경계를 허물었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2020-lakehouse">
			<article class="event-detail" aria-labelledby="event-2020-lakehouse-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2020</p>
					<h2 id="event-2020-lakehouse-title">레이크하우스 전략</h2>
					<p class="event-detail__summary">Databricks와 커뮤니티는 “호수와 창고를 잇자”며 트랜잭션을 지원하는 레이크하우스 아키텍처를 제안했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>분석팀은 “데이터 레이크는 싸지만 신뢰하기 어렵고, 웨어하우스는 비싸요.”라고 푸념했습니다. Databricks는 Delta Lake를 통해 <abbr title="원자성, 일관성, 독립성, 지속성">ACID</abbr> 트랜잭션과 스키마 진화를 지원하며 두 세계를 잇는 전략을 제시했습니다.</p>
						<p>기업은 이제 동일한 저장소에서 배치 분석과 스트리밍 처리를 동시에 실행할 수 있습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>레이크하우스는 테이블 형식 메타데이터와 트랜잭션 로그를 두어 데이터 레이크에 품질 관리 기능을 부여합니다. <abbr title="데이터 레이크">데이터 레이크</abbr>의 확장성과 웨어하우스의 거버넌스를 결합해, 엔지니어링 팀과 분석 팀이 하나의 저장소를 공유할 수 있게 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2023-vector">
			<article class="event-detail" aria-labelledby="event-2023-vector-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2023</p>
					<h2 id="event-2023-vector-title">벡터 데이터베이스 상용화</h2>
					<p class="event-detail__summary">생성형 AI 팀은 답변 품질을 높이기 위해 의미 기반 검색을 돕는 벡터 데이터베이스를 실무에 들여놓기 시작했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>컨택센터 자동화를 맡은 팀은 “질문과 비슷한 답변을 몇 초 안에 찾아서 AI에게 전달해야 해요.”라고 요청했습니다. Pinecone, Weaviate 같은 벡터 DB는 고차원 벡터를 저장하고 근사 최근접 검색을 제공합니다.</p>
						<p>AI 어시스턴트가 답변을 구성하는 데 필요한 맥락을 벡터 DB에서 즉시 가져오자, 팀은 “이제는 답변 품질이 훨씬 안정적이네요.”라고 평가했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>벡터 데이터베이스는 코사인 유사도, 내적 등 벡터 연산을 빠르게 실행하고, HNSW 같은 인덱스를 이용해 대규모 데이터에서도 실시간 검색을 지원합니다. RAG(검색 증강 생성) 파이프라인이 확산되면서 필수 구성 요소로 자리잡았습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<button type="button" class="scroll-top" data-scroll-top aria-label="맨 위로 이동" hidden>↑</button>

		<script src="assets/js/main.js" defer></script>
		<script type="text/javascript" src="https://wcs.pstatic.net/wcslog.js"></script>
		<script type="text/javascript">
			if (!window.wcs_add) window.wcs_add = {};
			window.wcs_add["wa"] = "134f4c428765360";
			if (window.location.protocol !== 'file:' && window.wcs) {
				wcs_do();
			}
		</script>
	</body>
</html>
