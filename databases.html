<!DOCTYPE html>
<html lang="ko">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>ArcherLab IT Story · 데이터를 맡기는 기술의 여정</title>
		<meta name="description" content="1890년대 천공 카드에서 2020년대 벡터 검색까지, 데이터를 안전하게 저장하고 꺼내 쓰게 만든 순간을 타임라인으로 정리했습니다." />
		<meta property="og:title" content="ArcherLab IT Story · Database Timeline" />
		<meta property="og:description" content="관계형 모델, NoSQL, 레이크하우스, 벡터 검색까지 이어지는 데이터베이스 역사를 따라가 보세요." />
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700;800&family=Space+Grotesk:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500;600&display=swap" rel="stylesheet">
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css">
		<link rel="stylesheet" href="assets/css/style.css">
		<link rel="alternate" hreflang="ko" href="https://itstory.archerlab.dev/databases.html" />
		<link rel="alternate" hreflang="en" href="https://itstory.archerlab.dev/databases-en.html" />
		<link rel="alternate" hreflang="x-default" href="https://itstory.archerlab.dev/databases-en.html" />
		<script async src="https://www.googletagmanager.com/gtag/js?id=G-MTBCHM8DYM"></script>
		<script src="assets/js/ga.js"></script>
	</head>
	<body>
		<div class="page">
			<header class="page__header" role="banner">
				<div class="page__header-left">
					<a class="page__brand" href="https://archerlab.dev" target="_blank" rel="noopener">
						<img src="assets/images/archerlab_mini_logo.png" alt="ArcherLab" class="page__brand-logo" loading="lazy">
						<span class="page__brand-label">ArcherLab Chronicle</span>
					</a>
					<nav class="page__topic-nav" aria-label="주제 전환">
						<a href="index.html">홈 허브</a>
						<a href="computers.html">컴퓨터 연대기</a>
						<a href="networks.html">네트워크 연대기</a>
						<a href="databases.html" class="is-current">데이터베이스 연대기</a>
						<a href="os.html">운영체제 연대기</a>
						<div class="page__topic-nav-group" role="group" aria-label="웹 제작 연대기">
							<span class="page__topic-nav-label">웹 제작 연대기</span>
							<a href="web.html" data-topic-role="parent">웹 제작 연대기 허브</a>
							<a href="web-structure.html" data-topic-role="child">웹 문서 설계 연대기</a>
							<a href="web-styling.html" data-topic-role="child">스타일링 진화 연대기</a>
							<a href="web-interaction.html" data-topic-role="child">브라우저 인터랙션 연대기</a>
							<a href="web-tools.html" data-topic-role="child">웹 제작 도구 연대기</a>
						</div>
						<a href="was.html">웹 서버 연대기</a>
					</nav>
				</div>
				<nav class="page__nav" aria-label="섹션 탐색">
					<a href="#timeline">연도 보기</a>
					<a href="#sources">참고</a>
					<div class="language-switch">
						<label class="sr-only" for="language-select-databases">언어 선택</label>
						<select id="language-select-databases" data-language-switch>
							<option value="databases.html" data-language-code="ko" selected>한국어</option>
							<option value="databases-en.html" data-language-code="en">English</option>
						</select>
					</div>
				</nav>
			</header>

			<main class="page__main" id="main" role="main">
				<section class="timeline-hero" aria-labelledby="timeline-title">
					<div class="timeline-hero__head">
						<p class="hero__eyebrow">Database Story for Curious Builders</p>
						<h1 class="timeline-hero__title" id="timeline-title">펀치 카드부터 레이크하우스까지, 데이터를 맡기는 법을 찾아 온 기록</h1>
						<p class="timeline-hero__lede">
							1890년 미국 통계국 서기들은 인구조사 표를 제때 끝내지 못해 애를 먹었습니다. 허먼 홀러리스가 펀치 카드 기계를 들고 와 “구멍으로 답을 세어 보죠”라고 제안하면서 데이터가 처음 전기 장비를 타고 흘렀습니다. 몇십 년 뒤에는 은행 창구 직원과 로켓 조립 관리자도 “기록 좀 빨리 찾게 해 주세요”라며 자기 디스크와 계층형 모델을 시험했습니다.
						</p>
						<p class="timeline-hero__lede">
							1970년대 E.F. Codd와 Peter Chen은 데이터를 표와 그림으로 설명하는 법을 정리했고, Oracle 같은 팀이 “현장에서도 통한다”는 걸 보여 줬습니다. 1990년대 MySQL과 PostgreSQL은 오픈소스 선택지를 넓혔고, 2000년대 Dynamo와 MongoDB는 분산 웹 서비스를 위해 새로운 저장 방식을 탐색했습니다.
						</p>
						<p class="timeline-hero__lede">
							연도 버튼을 누르면 각 세대가 어떤 문제를 풀고 싶었는지, 그 해법이 오늘날 서비스에 어떻게 이어졌는지 차근차근 만나 볼 수 있습니다. 낯선 용어가 나와도 괜찮아요. 사람과 상황 중심으로 쉽게 풀어 드릴게요.
						</p>
					</div>
				</section>

				<section class="timeline-grid" id="timeline" aria-labelledby="timeline-title" aria-describedby="timeline-instructions">
					<p class="timeline-grid__instructions sr-only" id="timeline-instructions">연도 버튼을 누르면 새 창 없이 팝업 대화 상자가 열리고, 그 자리에서 자세한 이야기를 이어서 읽을 수 있습니다.</p>

					<section class="timeline-group" aria-labelledby="decade-1890 topic-1890">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1890">1890s</p>
							<h3 class="timeline-group__topic" id="topic-1890">인구조사와 펀치 카드 실험</h3>
							<p class="timeline-group__summary">통계국 서기와 엔지니어가 종이 표 대신 펀치 카드와 전기 집계기를 들여와 반복 계산을 기계에 맡겼습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1890-hollerith">
								<span class="timeline-event__year">1890</span>
								<span class="timeline-event__label">홀러리스 천공 카드 시스템</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-1950 topic-1950">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1950">1950s</p>
							<h3 class="timeline-group__topic" id="topic-1950">자기 디스크와 실시간 업데이트</h3>
							<p class="timeline-group__summary">은행과 보험사 팀은 테이프를 갈아 끼우는 시간 대신, 회전하는 디스크로 “필요할 때 바로 고치자”는 새 흐름을 열었습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1956-ramac">
								<span class="timeline-event__year">1956</span>
								<span class="timeline-event__label">IBM 305 RAMAC</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1959-codasyl">
								<span class="timeline-event__year">1959</span>
								<span class="timeline-event__label">CODASYL DB 위원회 발족</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-1960 topic-1960">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1960">1960s</p>
							<h3 class="timeline-group__topic" id="topic-1960">로켓과 은행이 그린 계층 지도</h3>
							<p class="timeline-group__summary">아폴로 부품과 항공 예약처럼 복잡한 정보를 다루던 팀은 데이터를 층층이 쌓거나 링크로 묶는 모델을 실험했습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1966-ims">
								<span class="timeline-event__year">1966</span>
								<span class="timeline-event__label">IBM IMS 가동</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1969-ids">
								<span class="timeline-event__year">1969</span>
								<span class="timeline-event__label">IDS 네트워크 모델</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-1970 topic-1970">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1970">1970s</p>
							<h3 class="timeline-group__topic" id="topic-1970">관계형 사고와 그림 언어</h3>
							<p class="timeline-group__summary">연구자와 설계자는 “조건만 말하면 원하는 표를 보자”는 목표로 SQL과 ER 다이어그램을 정착시켰습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1970-codd">
								<span class="timeline-event__year">1970</span>
								<span class="timeline-event__label">E.F. Codd 관계형 논문</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1976-ermodel">
								<span class="timeline-event__year">1976</span>
								<span class="timeline-event__label">Peter Chen ER 모델</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1979-oracle">
								<span class="timeline-event__year">1979</span>
								<span class="timeline-event__label">Oracle V2 SQL DB</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-1980 topic-1980">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1980">1980s</p>
							<h3 class="timeline-group__topic" id="topic-1980">표준화와 병렬 엔진의 확장</h3>
							<p class="timeline-group__summary">대형 은행과 제조사가 관계형 DB를 기본 도구로 삼자 SQL 표준과 대규모 병렬 엔진이 빠르게 보급됐습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1981-db2">
								<span class="timeline-event__year">1981</span>
								<span class="timeline-event__label">IBM DB2 베타</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1986-sql-standard">
								<span class="timeline-event__year">1986</span>
								<span class="timeline-event__label">ANSI SQL-86 채택</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1988-teradata">
								<span class="timeline-event__year">1988</span>
								<span class="timeline-event__label">Teradata DBC/1012</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-1990 topic-1990">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1990">1990s</p>
							<h3 class="timeline-group__topic" id="topic-1990">오픈소스와 데이터 웨어하우스</h3>
							<p class="timeline-group__summary">웹 서비스와 전자상거래 팀이 가볍고 무료인 DB를 고르고, 경영진은 분석을 위한 별도 창고를 세웠습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1995-mysql">
								<span class="timeline-event__year">1995</span>
								<span class="timeline-event__label">MySQL 공개</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1996-postgres95">
								<span class="timeline-event__year">1996</span>
								<span class="timeline-event__label">PostgreSQL 6 미리보기</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1998-datawarehouse">
								<span class="timeline-event__year">1998</span>
								<span class="timeline-event__label">데이터 웨어하우스 참고 모델</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-2000 topic-2000">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-2000">2000s</p>
							<h3 class="timeline-group__topic" id="topic-2000">웹 규모와 NoSQL 실험</h3>
							<p class="timeline-group__summary">인터넷 기업은 수천 대 서버에 로그를 나눠 저장하고 문서형·키값 저장소를 시험하며 유연성을 확보했습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="2004-mapreduce">
								<span class="timeline-event__year">2004</span>
								<span class="timeline-event__label">Google MapReduce 논문</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2006-dynamo">
								<span class="timeline-event__year">2006</span>
								<span class="timeline-event__label">Amazon Dynamo 설계</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2009-mongodb">
								<span class="timeline-event__year">2009</span>
								<span class="timeline-event__label">MongoDB 1.0</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-2010 topic-2010">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-2010">2010s</p>
							<h3 class="timeline-group__topic" id="topic-2010">전 세계 일관성과 스트리밍 파이프라인</h3>
							<p class="timeline-group__summary">다국적 서비스는 지구 반대편에서도 같은 데이터를 보려 했고, 이벤트 스트림을 흘려보내며 실시간 분석을 준비했습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="2012-spanner">
								<span class="timeline-event__year">2012</span>
								<span class="timeline-event__label">Google Spanner 논문</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2014-kafka">
								<span class="timeline-event__year">2014</span>
								<span class="timeline-event__label">Apache Kafka 0.8</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2018-snowflake">
								<span class="timeline-event__year">2018</span>
								<span class="timeline-event__label">Snowflake 전역 출시</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-2020 topic-2020">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-2020">2020s</p>
							<h3 class="timeline-group__topic" id="topic-2020">레이크하우스와 벡터 검색 도입</h3>
							<p class="timeline-group__summary">데이터 레이크와 웨어하우스를 잇는 설계가 확산되고, 생성형 AI를 돕는 벡터 데이터베이스가 업무에 들어오기 시작했습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="2020-lakehouse">
								<span class="timeline-event__year">2020</span>
								<span class="timeline-event__label">레이크하우스 전략 발표</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2023-vector">
								<span class="timeline-event__year">2023</span>
								<span class="timeline-event__label">벡터 DB 상용화</span>
							</button>
						</div>
					</section>
				</section>

				<section class="sources" id="sources" aria-labelledby="sources-title">
					<div class="section__head">
						<h2 id="sources-title">참고 자료</h2>
						<p>
							관계형 이론, 분산 DB 설계, 레이크하우스 전략을 소개한 대표 문헌을 모았습니다. 원문을 읽어 보면 당시 엔지니어가 어떤 제약을 풀려고 했는지 더 잘 느낄 수 있습니다.
						</p>
					</div>
					<ul class="source-list">
						<li><a href="https://www.ibm.com/ibm/history/ibm100/us/en/icons/ramac/" target="_blank" rel="noopener">IBM Archives · RAMAC Story</a></li>
						<li><a href="https://archive.computerhistory.org/resources/text/People/CODASYL/CODASYL.CommitteeMinutes.1959.102653978.pdf" target="_blank" rel="noopener">Computer History Museum · CODASYL Minutes</a></li>
						<li><a href="https://dl.acm.org/doi/10.1145/362384.362685" target="_blank" rel="noopener">E.F. Codd · A Relational Model</a></li>
						<li><a href="https://dl.acm.org/doi/10.1145/320434.320440" target="_blank" rel="noopener">Peter Chen · The Entity-Relationship Model</a></li>
						<li><a href="https://www.oracle.com/database/technologies/oracle-database-history.html" target="_blank" rel="noopener">Oracle · Database History</a></li>
						<li><a href="https://www.postgresql.org/about/history/" target="_blank" rel="noopener">PostgreSQL · Project History</a></li>
						<li><a href="https://research.google/pubs/spanner-google-globally-distributed-database/" target="_blank" rel="noopener">Google Research · Spanner Paper</a></li>
						<li><a href="https://research.google/pubs/pub62/" target="_blank" rel="noopener">Google Research · MapReduce</a></li>
						<li><a href="https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf" target="_blank" rel="noopener">Amazon · Dynamo Paper</a></li>
						<li><a href="https://www.mongodb.com/blog/post/mongodb-10" target="_blank" rel="noopener">MongoDB · 1.0 Release Note</a></li>
						<li><a href="https://www.databricks.com/blog/2020/01/30/what-is-a-data-lakehouse.html" target="_blank" rel="noopener">Databricks · Lakehouse Explained</a></li>
						<li><a href="https://www.snowflake.com/en/data-warehouse-architecture/" target="_blank" rel="noopener">Snowflake · Cloud Data Warehouse Architecture</a></li>
						<li><a href="https://www.pinecone.io/learn/vector-database/" target="_blank" rel="noopener">Pinecone · Vector Database Guide</a></li>
					</ul>
				</section>
			</main>

			<footer class="page__footer" role="contentinfo">
				<p>© 2025 ArcherLab · Stories on data through time.</p>
				<a class="page__footer-link" href="https://archerlab.dev" target="_blank" rel="noopener">archerlab.dev</a>
			</footer>
		</div>

		<div class="modal" id="event-modal" role="dialog" aria-modal="true" hidden>
			<div class="modal__overlay" data-modal-close></div>
			<div class="modal__window" role="document" tabindex="-1">
				<button class="modal__close" type="button" aria-label="레이어 닫기" data-modal-close>&times;</button>
				<div class="modal__content"></div>
			</div>
		</div>

		<template id="event-1890-hollerith">
			<article class="event-detail" aria-labelledby="event-1890-hollerith-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1890</p>
					<h2 id="event-1890-hollerith-title">홀러리스 천공 카드 시스템</h2>
					<p class="event-detail__summary">통계국 서기 헬렌은 “이번엔 제때 끝낼 수 있을까?”라며 걱정했지만, 허먼 홀러리스의 펀치 카드와 전기 집계기가 기다리던 답을 내놓았습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>정부는 1880년 인구조사 집계를 끝내는 데 7년을 써버렸습니다. 통계관 헬렌은 “이대로 가면 다음 조사 결과가 나오기도 전에 또 조사를 해야 해요.”라며 한숨을 쉬었습니다. 통계청을 드나들던 허먼 홀러리스는 수레에 전기식 카운터와 펀치 카드를 싣고 와 직접 시연했습니다.</p>
						<p>“구멍이 뚫린 위치를 바늘로 읽으면 숫자를 자동으로 더할 수 있습니다.”라는 설명이 끝나자, 헬렌은 스위치를 눌러 카운터가 돌아가는 모습을 보며 미소를 지었습니다. 덕분에 1890년 인구조사 결과는 2년 만에 발표될 수 있었고, 통계국은 데이터를 기계에 맡기면 시간이 크게 줄어든다는 사실을 체감했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>펀치 카드는 각 칸을 구멍으로 표현해 숫자와 속성을 기록했습니다. 전극이 구멍을 통과하면 전류가 흐르고, 그 신호를 계수 장치가 집계했습니다. 오늘날의 행(row)과 열(column)을 구멍 위치로 표현한 셈입니다. 매뉴얼에는 어떤 질문이 어느 열에 대응되는지 적혀 있어, 모든 조사원이 같은 규칙으로 데이터를 입력할 수 있었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1956-ramac">
			<article class="event-detail" aria-labelledby="event-1956-ramac-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1956</p>
					<h2 id="event-1956-ramac-title">IBM 305 RAMAC · 자기 디스크 도입</h2>
					<p class="event-detail__summary">샌프란시스코 은행 창구 직원 로버트는 회전하는 디스크가 계좌 기록을 즉시 불러오는 모습을 보고 “이제 줄을 줄일 수 있겠다”고 안도했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>샌프란시스코의 은행 창구는 점심시간마다 줄이 끝이 없었습니다. 회계원 로버트는 “현금 카드 기록만 빨리 갱신하면 줄이 줄 텐데…”라며 이마에 땀을 닦았습니다. IBM이 들고 온 RAMAC은 냉장고만 한 덩치를 자랑했지만, 데이터를 저장한 디스크가 초당 수백 회 회전하면서 원하는 레코드를 즉시 읽어 들였습니다.</p>
						<p>로버트가 카드 번호를 입력하자, 기계는 거대한 암을 움직여 디스크의 정확한 위치를 찾고 “처리 완료”라는 불빛을 켰습니다. 그는 “드디어 대기표를 줄일 수 있겠어.”라며 환하게 웃었습니다. 자기 디스크 덕분에 파일을 순서대로 읽지 않아도 되는 시대가 열렸고, 기업은 실시간 처리에 눈을 뜨기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>RAMAC은 50장의 금속 디스크를 쌓아 5MB의 데이터를 저장했습니다. 테이프처럼 처음부터 끝까지 읽지 않고, 헤드를 이동해 바로 원하는 블록을 찾을 수 있었습니다. 이 <abbr title="온라인 트랜잭션 처리">OLTP</abbr> 방식은 고객 계좌나 재고처럼 즉시 수정해야 하는 데이터를 처리하는 데 필수가 되었고, 이후 데이터베이스 시스템이 디스크를 기본 저장소로 채택하는 계기가 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1959-codasyl">
			<article class="event-detail" aria-labelledby="event-1959-codasyl-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1959</p>
					<h2 id="event-1959-codasyl-title">CODASYL DB 위원회</h2>
					<p class="event-detail__summary">보험사와 제조사 대표들은 “파일 구조가 다르면 서로 못 알아들어요”라며 모여, 레코드와 링크를 표준화하는 규칙을 정했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>뉴욕의 회의실에는 10여 개 기업 대표가 둘러앉았습니다. “우리 시스템은 고객 레코드 뒤에 바로 계약 레코드를 붙입니다.”, “우리는 반대로 링크를 따로 저장해요.” 서로 다른 설명이 이어지자, 의장 베티는 칠판에 “RECORD · SET · LINK”를 적었습니다.</p>
						<p>밤늦게까지 이어진 회의에서 “링크 이름을 표준화하면 다른 시스템에서도 읽을 수 있어요.”라는 합의가 나왔고, 참석자들은 초안 문서를 집으로 가져가 테스트하기로 했습니다. CODASYL 보고서는 계층형·네트워크형 데이터 모델의 기초가 되었고, 기업들이 대형 프로젝트를 추진할 때 참고서 역할을 했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>CODASYL 모델은 레코드 타입, 세트(set), 오너(owner), 멤버(member)를 정의해 여러 레코드를 포인터로 연결했습니다. 애플리케이션은 포인터를 따라가며 데이터를 탐색해야 했으므로, 개발자는 데이터를 저장하는 순서와 관계를 미리 설계해야 했습니다. 이 노력은 후에 관계형 모델이 제시됐을 때 “선언형으로 데이터를 다루자”는 주장의 배경이 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1966-ims">
			<article class="event-detail" aria-labelledby="event-1966-ims-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1966</p>
					<h2 id="event-1966-ims-title">IMS · 아폴로 부품을 추적하다</h2>
					<p class="event-detail__summary">아폴로 부품을 관리하던 팀은 IMS 덕분에 “어떤 공정에서 어떤 부품이 필요한지”를 계층 구조로 바로 확인했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>아폴로 계획에 참여한 록웰 공장의 엔지니어들은 “조립 라인에서 볼트 하나라도 없으면 일정이 미뤄집니다.”라며 걱정했습니다. IBM과 협력해 만든 IMS는 조립 단계별로 필요한 부품을 계층 구조로 저장했습니다. 작업자 앤젤라는 터미널에 공정 번호를 입력해 필요한 부품 목록을 즉시 확인했습니다.</p>
						<p>IMS 덕분에 부품 부족이 줄어들자 현장 감독은 “이제는 창고를 뒤지느라 시간을 낭비하지 않아도 된다.”라고 말했습니다. 이후 은행과 항공사도 IMS를 도입해 고객 계좌와 예약 정보를 관리했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>IMS는 계층형 데이터베이스입니다. 루트 세그먼트(예: 프로젝트) 아래에 자식 세그먼트(예: 부품, 공급업체)를 둡니다. 응용 프로그램은 루트에서 자식으로 내려가며 데이터를 읽었습니다. 이러한 구조는 대량의 반복 데이터를 빠르게 처리하지만, 새로운 질의 요구가 생기면 프로그램을 수정해야 했습니다. 이 한계 때문에 관계형 모델의 유연함이 더 돋보이게 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1969-ids">
			<article class="event-detail" aria-labelledby="event-1969-ids-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1969</p>
					<h2 id="event-1969-ids-title">IDS 네트워크 모델</h2>
					<p class="event-detail__summary">항공기 제조사 설계자는 같은 부품이 여러 제품에 쓰일 때를 표현하려고, 링크로 얽힌 IDS 네트워크 모델을 받아들였습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>제너럴 일렉트릭의 개발자 찰스 바크만은 “한 부품이 여러 조립품에 쓰일 때 계층 구조로는 너무 복잡합니다.”라며 고민했습니다. 그가 만든 IDS는 `공급자 → 부품`, `부품 → 제품`처럼 다양한 관계를 포인터로 연결했습니다.</p>
						<p>시연 자리에서 엔지니어 리사는 “이제는 부품이 어느 제품에 쓰이는지 역방향으로도 추적할 수 있네요.”라며 감탄했습니다. IDS는 데이터베이스 설계가 단순 저장을 넘어 탐색을 돕는 도구가 되어야 한다는 인식을 심어 주었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>네트워크형 모델은 레코드를 여러 세트에 연결할 수 있도록 허용합니다. 조인 연산을 명시적으로 작성해야 했지만, 그래프처럼 유연한 연결을 표현할 수 있었습니다. 이 경험은 “질의 언어가 연결을 대신해 주면 얼마나 편할까?”라는 질문을 남겼고, SQL의 필요성을 뚜렷하게 만들었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1970-codd">
			<article class="event-detail" aria-labelledby="event-1970-codd-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1970</p>
					<h2 id="event-1970-codd-title">관계형 모델 논문</h2>
					<p class="event-detail__summary">E.F. Codd는 “데이터를 표로, 포인터 대신 수학으로 다루자”고 제안하며 선언형 <abbr title="Structured Query Language">SQL</abbr> 사고를 열었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Codd는 IBM 연구소에서 메인프레임 로그를 분석하며, 포인터와 물리 저장 방식에 얽매인 기존 시스템에 답답함을 느꼈습니다. 그는 “데이터를 집합으로 보고, 필요한 조건만 말하면 시스템이 나머지를 알아서 처리하도록 하자”고 주장했습니다.</p>
						<p>논문이 발표되자 동료 연구원 메리는 “이렇게 하면 새로운 보고서를 만들 때마다 프로그램을 다시 짜지 않아도 되겠네요.”라고 말했습니다. 관계형 모델은 데이터베이스를 단순한 파일 관리가 아니라, 논리적 구조로 바라보는 전환점이 되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>관계형 모델은 릴레이션(테이블), 튜플(행), 속성(열)이라는 개념을 도입했습니다. 선택, 투영, 조인 같은 연산은 수학적 집합 이론을 기반으로 정의되어, 다른 구현에서도 일관되게 사용할 수 있었습니다. ACID 원칙(원자성, 일관성, 독립성, 지속성)을 적용한 트랜잭션 개념도 이후 관계형 DB의 핵심이 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1976-ermodel">
			<article class="event-detail" aria-labelledby="event-1976-ermodel-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1976</p>
					<h2 id="event-1976-ermodel-title">Peter Chen의 ER 모델</h2>
					<p class="event-detail__summary">Peter Chen은 “업무를 그림으로 설명하게 도와 줄게요”라며 개체와 관계를 나란히 보여 주는 ER 다이어그램을 발표했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>컨설턴트 리즈는 회의실에서 마커를 들고 “고객은 계약을 하나 이상 가진다”라는 문장을 화살표로 표현했습니다. 엔지니어들은 “이제 요구사항을 그림으로 합의할 수 있겠네요.”라며 고개를 끄덕였습니다.</p>
						<p>ER 다이어그램 덕분에 분석가와 개발자가 같은 언어로 이야기하게 되었고, 데이터 모델링이 프로젝트 초반에 논의돼야 할 주제가 되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>ER 모델은 개체(Entity), 관계(Relationship), 속성(Attribute)를 정의해 관계형 스키마 설계에 앞서 개념 모델을 만드는 절차를 정착시켰습니다. 다중성(1:N, M:N)을 다이어그램으로 표현하면서, 실제 테이블 구조로 변환하기 전 잠재적 문제를 조기에 발견할 수 있게 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1979-oracle">
			<article class="event-detail" aria-labelledby="event-1979-oracle-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1979</p>
					<h2 id="event-1979-oracle-title">Oracle V2 · 상용 SQL 데이터베이스</h2>
					<p class="event-detail__summary">Oracle은 “연구실 말고 현장에서도 관계형 DB를 쓰자”며 SQL 제품을 출시해 실용성을 증명했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Oracle 직원들은 미 국방부 프로젝트에 참여하며 실험용 SQL 엔진을 다듬었습니다. 배포 첫날, 고객 지원팀은 “SELECT 문장이 이렇게 간단하다니 믿기지 않네요!”라는 전화를 받았습니다.</p>
						<p>성능은 완벽하지 않았지만, 업데이트를 반복하면서 기업 고객을 확보했고 다른 업체들도 관계형 DB 시장에 뛰어들었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Oracle은 SQL 문법을 상용 제품에 적용하고, <abbr title="온라인 트랜잭션 처리">OLTP</abbr> 환경에서 트랜잭션을 지원했습니다. 표준이 정립되기 전이었지만, 관계형 모델을 실제 비즈니스에 적용할 수 있다는 확신을 시장에 심어 주었습니다. 이후 IBM, Microsoft 등도 경쟁 제품을 내놓으며 생태계가 빠르게 성장했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1981-db2">
			<article class="event-detail" aria-labelledby="event-1981-db2-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1981</p>
					<h2 id="event-1981-db2-title">IBM DB2 베타</h2>
					<p class="event-detail__summary">IBM은 메인프레임 고객에게 DB2를 소개하며 “대형 업무도 표 기반으로 전환할 수 있다”는 확신을 심어 줬습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>IBM 고객사 파일럿 현장에서 회계 책임자 수잔은 “복잡한 조인도 SQL 하나로 되네요.”라며 놀랐습니다. DB2는 기존 VSAM 파일을 대체하면서도 성능을 지키기 위해 옵티마이저와 버퍼 풀 기술을 도입했습니다.</p>
						<p>베타 테스트가 성공하자, 은행과 보험사는 본격적으로 관계형 DB로 이주하기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>DB2는 비용 기반 옵티마이저를 도입해 SQL 실행 계획을 자동으로 선택했습니다. 또한 <abbr title="Structure Query Language">SQL</abbr> 표준화 논의를 주도하며 이후 ANSI 표준을 수용했습니다. 기업 고객이 ACID 트랜잭션과 SQL을 본격적으로 채택하는 계기가 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1986-sql-standard">
			<article class="event-detail" aria-labelledby="event-1986-sql-standard-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1986</p>
					<h2 id="event-1986-sql-standard-title">ANSI SQL-86</h2>
					<p class="event-detail__summary">ANSI 승인을 받은 SQL-86 덕분에 개발자들은 제품을 바꿔도 익숙한 문법을 유지할 수 있다고 안심했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>위원회 회의에서 기술자 마크는 “SELECT에서 JOIN을 어떻게 표준화할 것인지 정해야 합니다.”라며 칠판에 문법 후보를 적었습니다. 여러 업체가 타협을 거듭한 끝에, 오늘날 우리가 알고 있는 기본 SQL 문법이 확정되었습니다.</p>
						<p>표준이 발표되자 컨설턴트들은 “이제 고객이 다른 DB로 갈아타도 되겠네요.”라며 안도했습니다. 상호 운용성은 데이터베이스 시장 확대를 촉진했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>SQL-86은 데이터 정의 언어(DDL), 데이터 조작 언어(DML), 트랜잭션 제어를 명확히 구분했습니다. 이 표준 덕분에 JDBC, ODBC 같은 드라이버가 서로 다른 DB를 연결할 수 있게 되었고, 산업 전반에 SQL 교육과 도구가 확산되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1988-teradata">
			<article class="event-detail" aria-labelledby="event-1988-teradata-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1988</p>
					<h2 id="event-1988-teradata-title">Teradata DBC/1012</h2>
					<p class="event-detail__summary">Teradata의 DBC/1012는 수십 대 노드를 나란히 돌려 “이만한 데이터도 나눠서 계산할 수 있다”는 자신감을 줬습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>소매업 분석팀은 매주 수십억 건의 거래 데이터를 집계하느라 서버를 밤새 돌렸습니다. Teradata 시스템이 도입되자, 직원 줄리는 “이제는 새벽에 와서 결과를 확인할 수 있다”며 눈을 반짝였습니다. 여러 노드가 데이터를 나눠 가져가 동시에 처리했기 때문입니다.</p>
						<p>병렬 처리 개념은 이후 데이터 웨어하우스 설계의 기본 원칙이 되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Teradata의 공유-없음(Shared-nothing) 아키텍처는 각 노드에 데이터를 분산 저장하고, <abbr title="Massively Parallel Processing">MPP</abbr> 방식으로 질의를 수행했습니다. 균형 잡힌 파티셔닝과 조인 전략이 필요한 만큼, 데이터 모델링이 더욱 중요해졌습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1995-mysql">
			<article class="event-detail" aria-labelledby="event-1995-mysql-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1995</p>
					<h2 id="event-1995-mysql-title">MySQL 공개</h2>
					<p class="event-detail__summary">웹 개발자들은 “가볍고 공짜면 좋겠어”라고 말했고, MySQL이 LAMP 스택의 기본 선택이 되었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>스타트업 개발자 안나는 “비싼 라이선스를 살 돈이 없어요.”라며 오픈소스 DB를 찾아 헤맸습니다. MySQL은 설치와 설정이 쉬웠고, PHP에서 바로 쿼리를 실행할 수 있었습니다.</p>
						<p>커뮤니티가 빠르게 성장하면서 수많은 튜토리얼과 GUI 툴이 등장했고, 블로그와 쇼핑몰이 MySQL을 중심으로 구축되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>MySQL은 초기에는 MyISAM 스토리지를 사용해 빠른 읽기 성능을 제공했습니다. 이후 InnoDB를 도입해 <abbr title="원자성, 일관성, 독립성, 지속성">ACID</abbr> 트랜잭션과 외래 키를 지원했습니다. 오픈소스 라이선스는 커뮤니티의 빠른 확산을 이끌었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1996-postgres95">
			<article class="event-detail" aria-labelledby="event-1996-postgres95-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1996</p>
					<h2 id="event-1996-postgres95-title">PostgreSQL 6 프리뷰</h2>
					<p class="event-detail__summary">버클리 POSTGRES 연구는 커뮤니티와 합쳐져 PostgreSQL이 확장 가능한 오픈소스 데이터베이스로 자리 잡게 했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>개발자 마이클은 메일링 리스트에서 “사용자 정의 타입을 추가해 봤어요.”라는 글을 발견했습니다. PostgreSQL은 소스 코드를 공개하고 누구나 기능을 확장할 수 있도록 했습니다.</p>
						<p>덕분에 지리 정보, 검색 확장 등 다양한 확장 모듈이 생겨났고, 기업이 필요에 맞게 DB를 조정할 수 있는 옵션이 생겼습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>PostgreSQL은 MVCC(다중 버전 동시성 제어)를 기반으로 동시성을 관리했습니다. 커스텀 함수, 데이터 타입, 인덱스 메서드를 지원해 도메인 특화 기능을 구현하기 쉬웠습니다. 오픈 거버넌스 모델이 장기적인 발전을 가능하게 했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1998-datawarehouse">
			<article class="event-detail" aria-labelledby="event-1998-datawarehouse-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1998</p>
					<h2 id="event-1998-datawarehouse-title">데이터 웨어하우스 참고 모델</h2>
					<p class="event-detail__summary">랄프 킴벌과 빌 인몬은 “운영 데이터와 보고 데이터는 다르게 다뤄야 한다”며 데이터 웨어하우스 설계를 정리했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>제조업 분석가 지나는 “실시간 시스템에 복잡한 분석 쿼리를 돌리면 느려져요.”라며 고민했습니다. 컨설턴트는 스타 스킴과 ETL 파이프라인을 제안하며, 운영 데이터와 분석 데이터를 분리하자고 설명했습니다.</p>
						<p>이후 조직마다 데이터 웨어하우스 팀이 생겼고, BI(비즈니스 인텔리전스) 도구가 빠르게 보급되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>데이터 웨어하우스는 사실 테이블과 차원 테이블로 나누어 집계 작업을 최적화했습니다. ETL(추출·변환·적재) 과정이 정례화되면서, 데이터 품질과 거버넌스에 대한 조직적 관심이 높아졌습니다. 이는 이후 데이터 레이크, 레이크하우스의 전신이 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2004-mapreduce">
			<article class="event-detail" aria-labelledby="event-2004-mapreduce-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2004</p>
					<h2 id="event-2004-mapreduce-title">Google MapReduce 논문</h2>
					<p class="event-detail__summary">Google 엔지니어는 수천 대 서버에 흩어진 로그를 “나눠 계산하고 다시 합치자”며 MapReduce 모델을 선보였습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>엔지니어 샌디는 야간 배포가 끝나면 실패한 작업을 수동으로 재시작하느라 밤을 새우곤 했습니다. MapReduce 프레임워크가 도입되자, 작업이 자동으로 노드에 분배되고 실패 시 재시도되었습니다.</p>
						<p>이 아이디어는 하둡(Hadoop)으로 구현되어 대규모 로그 분석의 표준 도구가 되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>MapReduce는 map, shuffle, reduce라는 단계를 정의해 분산 처리를 단순화했습니다. 개발자는 데이터를 블록으로 나누고 함수만 작성하면, 프레임워크가 분산 실행과 장애 복구를 담당했습니다. 이는 데이터 레이크 개념과 클라우드 기반 분석의 토대를 닦았습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2006-dynamo">
			<article class="event-detail" aria-labelledby="event-2006-dynamo-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2006</p>
					<h2 id="event-2006-dynamo-title">Amazon Dynamo 설계</h2>
					<p class="event-detail__summary">Amazon은 “쇼핑 카트는 절대 사라지면 안 돼”라며 가용성과 일관성 균형을 설명한 Dynamo 설계를 공유했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>블랙프라이데이 전날, 아마존 엔지니어들은 “어떤 서버가 꺼져도 카트는 살아 있어야 한다.”라는 목표를 세웠습니다. Dynamo는 데이터를 여러 노드에 복제하고, 버전 충돌을 클라이언트에서 해소하는 모델을 택했습니다.</p>
						<p>쇼핑 카트가 한 번도 사라지지 않았다는 보고가 올라오자, 팀은 “우리 목표 달성!”이라며 서로를 격려했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Dynamo는 일관성(consistency), 가용성(availability), 파티션 허용성(partition tolerance) 중 어떤 요소를 선택할지 설명하며 <abbr title="분산 시스템에서 일관성과 가용성의 절충 관계를 설명하는 이론">CAP 정리</abbr> 논의를 촉진했습니다. 키-값 저장소는 이후 NoSQL 시스템의 대표적인 형태가 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2009-mongodb">
			<article class="event-detail" aria-labelledby="event-2009-mongodb-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2009</p>
					<h2 id="event-2009-mongodb-title">MongoDB 1.0</h2>
					<p class="event-detail__summary">스타트업 개발자들은 매일 바뀌는 필드를 감당하려고, 스키마를 느슨하게 다루는 MongoDB 문서 저장소를 도입했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>스타트업 엔지니어 재나는 “오늘은 주소에 우편번호가 없고, 내일은 소셜 로그인 정보가 추가됩니다.”라며 고민했습니다. MongoDB는 JSON과 비슷한 BSON 문서로 데이터를 저장해 필드를 자유롭게 추가할 수 있었습니다.</p>
						<p>덕분에 빠르게 변하는 제품 실험을 데이터 모델이 따라갈 수 있게 되었고, NoSQL 열풍이 본격적으로 시작되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>MongoDB는 컬렉션에 문서를 저장하고, 인덱스를 설정해 빠른 조회를 지원했습니다. 강한 스키마가 필요할 때는 유효성 검사를 추가할 수 있지만, 기본적으로 개발 속도를 우선시했습니다. 이는 SQL과 NoSQL을 상황에 따라 선택하는 하이브리드 전략을 탄생시켰습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2012-spanner">
			<article class="event-detail" aria-labelledby="event-2012-spanner-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2012</p>
					<h2 id="event-2012-spanner-title">Spanner · 글로벌 일관성</h2>
					<p class="event-detail__summary">Google은 세계 곳곳 데이터센터에서 같은 트랜잭션이 실행되도록, 원자 시계와 정밀한 시간 동기화를 갖춘 Spanner를 구축했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Google 결제팀은 “도쿄와 시카고 서버가 동시에 잔액을 수정하면 어떻게 되나?”라는 질문을 던졌습니다. Spanner는 TrueTime API로 시계 오차를 관리하며, 전역 트랜잭션을 가능하게 했습니다.</p>
						<p>덕분에 글로벌 서비스를 운영하는 기업도 <abbr title="원자성, 일관성, 독립성, 지속성">ACID</abbr> 보장을 유지한 채 대륙 간 복제를 활용할 수 있게 되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Spanner는 다중 버전 복제와 2단계 커밋을 사용했으며, TrueTime이 제공하는 시간 범위를 이용해 직렬화 가능한 순서를 결정했습니다. 이 접근은 클라우드 기반 NewSQL 데이터베이스의 모델이 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2014-kafka">
			<article class="event-detail" aria-labelledby="event-2014-kafka-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2014</p>
					<h2 id="event-2014-kafka-title">Apache Kafka 0.8</h2>
					<p class="event-detail__summary">LinkedIn 엔지니어는 “이벤트를 한 번 쓰고 여러 팀이 나눠 듣게 하자”며 Kafka 스트리밍 플랫폼을 오픈소스로 공개했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>온라인 서비스 운영자는 “분당 수백만 건의 로그를 안정적으로 받아야 한다”고 호소했습니다. Kafka는 파티션을 여러 브로커에 분산하고, 소비자가 읽은 위치를 기억해 처리 속도를 자유롭게 조절할 수 있게 했습니다.</p>
						<p>덕분에 데이터 웨어하우스, 스트리밍 분석, 마이크로서비스가 Kafka를 중심으로 연결되는 아키텍처가 탄생했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Kafka는 로그를 append-only 구조로 저장하고, 소비자가 원하는 시점부터 다시 읽을 수 있게 했습니다. <abbr title="읽기, 쓰기 작업을 다루는 처리 방식">OLTP</abbr> 시스템과 분석 시스템 사이를 잇는 버퍼가 생기면서, 데이터 지연을 줄이고 마이크로서비스 이벤트 흐름을 표준화할 수 있었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2018-snowflake">
			<article class="event-detail" aria-labelledby="event-2018-snowflake-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2018</p>
					<h2 id="event-2018-snowflake-title">Snowflake 전역 출시</h2>
					<p class="event-detail__summary">Snowflake는 저장소와 컴퓨팅을 분리해 “필요한 순간에만 파워를 켜자”는 클라우드 데이터 웨어하우스를 확산시켰습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>분석가 조나는 “보고서 하나 돌릴 때마다 팀 전체가 기다려야 했어요.”라며 웃었습니다. Snowflake는 여러 가상 웨어하우스를 동시에 띄워 서로 간섭 없이 쿼리를 실행하게 했습니다.</p>
						<p>사용한 만큼 비용을 내는 모델 덕분에 중소기업도 고급 분석 인프라를 손쉽게 구축할 수 있었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Snowflake는 스토리지 계층을 중앙화하고, 컴퓨팅 클러스터를 독립적으로 확장할 수 있게 설계했습니다. 세미 구조화 데이터(JSON, Parquet)를 그대로 저장하고 질의할 수 있어, 데이터 레이크와 웨어하우스의 경계를 허물었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2020-lakehouse">
			<article class="event-detail" aria-labelledby="event-2020-lakehouse-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2020</p>
					<h2 id="event-2020-lakehouse-title">레이크하우스 전략</h2>
					<p class="event-detail__summary">Databricks와 커뮤니티는 “호수와 창고를 잇자”며 트랜잭션을 지원하는 레이크하우스 아키텍처를 제안했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>분석팀은 “데이터 레이크는 싸지만 신뢰하기 어렵고, 웨어하우스는 비싸요.”라고 푸념했습니다. Databricks는 Delta Lake를 통해 <abbr title="원자성, 일관성, 독립성, 지속성">ACID</abbr> 트랜잭션과 스키마 진화를 지원하며 두 세계를 잇는 전략을 제시했습니다.</p>
						<p>기업은 이제 동일한 저장소에서 배치 분석과 스트리밍 처리를 동시에 실행할 수 있습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>레이크하우스는 테이블 형식 메타데이터와 트랜잭션 로그를 두어 데이터 레이크에 품질 관리 기능을 부여합니다. <abbr title="데이터 레이크">데이터 레이크</abbr>의 확장성과 웨어하우스의 거버넌스를 결합해, 엔지니어링 팀과 분석 팀이 하나의 저장소를 공유할 수 있게 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2023-vector">
			<article class="event-detail" aria-labelledby="event-2023-vector-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2023</p>
					<h2 id="event-2023-vector-title">벡터 데이터베이스 상용화</h2>
					<p class="event-detail__summary">생성형 AI 팀은 답변 품질을 높이기 위해 의미 기반 검색을 돕는 벡터 데이터베이스를 실무에 들여놓기 시작했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>컨택센터 자동화를 맡은 팀은 “질문과 비슷한 답변을 몇 초 안에 찾아서 AI에게 전달해야 해요.”라고 요청했습니다. Pinecone, Weaviate 같은 벡터 DB는 고차원 벡터를 저장하고 근사 최근접 검색을 제공합니다.</p>
						<p>AI 어시스턴트가 답변을 구성하는 데 필요한 맥락을 벡터 DB에서 즉시 가져오자, 팀은 “이제는 답변 품질이 훨씬 안정적이네요.”라고 평가했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>벡터 데이터베이스는 코사인 유사도, 내적 등 벡터 연산을 빠르게 실행하고, HNSW 같은 인덱스를 이용해 대규모 데이터에서도 실시간 검색을 지원합니다. RAG(검색 증강 생성) 파이프라인이 확산되면서 필수 구성 요소로 자리잡았습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<button type="button" class="scroll-top" data-scroll-top aria-label="맨 위로 이동" hidden>↑</button>

		<script src="assets/js/main.js" defer></script>
	</body>
</html>
