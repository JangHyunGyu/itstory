<!DOCTYPE html>
<html lang="ko">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>ArcherLab IT Story · 웹이 층을 나눈 이유</title>
		<meta name="description" content="정적 문서에서 CGI, Ajax, SPA, 서버리스까지. 웹이 프론트엔드와 백엔드로 나뉘고 다시 협력하게 된 순간을 타임라인으로 살펴봅니다." />
		<meta property="og:title" content="ArcherLab IT Story · Web Layers Timeline" />
		<meta property="og:description" content="WWW 제안부터 서버리스까지, 웹이 정적 문서에서 앱 플랫폼으로 성장한 과정을 읽어 보세요." />
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700;800&family=Space+Grotesk:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500;600&display=swap" rel="stylesheet">
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css">
		<link rel="stylesheet" href="assets/css/style.css">
	</head>
	<body>
		<div class="page">
			<header class="page__header" role="banner">
				<div class="page__header-left">
					<a class="page__brand" href="https://archerlab.dev" target="_blank" rel="noopener">
						<img src="assets/images/archerlab_mini_logo.png" alt="ArcherLab" class="page__brand-logo" loading="lazy">
						<span class="page__brand-label">ArcherLab Chronicle</span>
					</a>
					<nav class="page__topic-nav" aria-label="주제 전환">
						<a href="index.html">홈 허브</a>
						<a href="networks.html">네트워크 연대기</a>
						<a href="computers.html">컴퓨터 연대기</a>
						<a href="web.html" class="is-current">웹 연대기</a>
						<a href="databases.html">데이터베이스 연대기</a>
					</nav>
				</div>
				<nav class="page__nav" aria-label="섹션 탐색">
					<a href="#timeline">연도 보기</a>
					<a href="#sources">참고</a>
				</nav>
			</header>

			<main class="page__main" id="main" role="main">
				<section class="timeline-hero" aria-labelledby="timeline-title">
					<div class="timeline-hero__head">
						<p class="hero__eyebrow">Web Story for Product Builders</p>
						<h1 class="timeline-hero__title" id="timeline-title">정적 문서에서 API와 서버리스까지, 웹이 달라진 순간을 따라가 보세요</h1>
						<p class="timeline-hero__lede">
							이 타임라인은 “웹이 어떻게 지금 모습이 되었을까?”라는 질문에서 시작했습니다. 실험실에서 문서를 돌려 보던 연구원, 회의를 연결하고 싶었던 엔지니어, 빠른 지도를 만들고 싶었던 제품팀까지. 사람들의 고민을 시간 순서로 따라가면 복잡한 기술 용어가 자연스럽게 이해됩니다.
						</p>
						<p class="timeline-hero__lede">
							연도 버튼을 눌러 보세요. 정적 페이지에서 출발해 CGI, Ajax, 단일 페이지 앱, 서버리스와 엣지 컴퓨팅까지 이어지는 흐름을 소설 읽듯 차근차근 풀어 드립니다. 낯선 단어는 바로 옆 문장에서 설명하고, 다음 시대 이야기로 어떻게 이어졌는지도 함께 적어 두었습니다.
						</p>
					</div>
				</section>

				<section class="timeline-grid" id="timeline" aria-labelledby="timeline-title" aria-describedby="timeline-instructions">
					<p class="timeline-grid__instructions sr-only" id="timeline-instructions">연도 버튼을 누르면 새 창 없이 팝업 대화 상자가 열리고, 그 자리에서 자세한 이야기를 이어서 읽을 수 있습니다.</p>

					<section class="timeline-group" aria-labelledby="decade-1960 topic-1960">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1960">1968–1986</p>
							<h3 class="timeline-group__topic" id="topic-1960">웹을 가능하게 한 토대</h3>
							<p class="timeline-group__summary">“서로 다른 컴퓨터를 어떻게 이어 붙일까?” “문서는 어떻게 찾아야 할까?” 같은 질문을 풀어낸 시기입니다. 마우스를 처음 소개한 데모, 첫 네트워크 연결, 주소 체계와 문서 규칙이 차곡차곡 쌓이며 오늘의 웹을 위한 퍼즐 조각이 맞춰졌습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1968-mother-demo">
								<span class="timeline-event__year">1968</span>
								<span class="timeline-event__label">Mother of All Demos</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1969-arpanet">
								<span class="timeline-event__year">1969</span>
								<span class="timeline-event__label">ARPANET 최초 연결</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1974-tcpip">
								<span class="timeline-event__year">1974</span>
								<span class="timeline-event__label">TCP/IP 설계</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1978-usenet">
								<span class="timeline-event__year">1978</span>
								<span class="timeline-event__label">Usenet 개시</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1980-enquire">
								<span class="timeline-event__year">1980</span>
								<span class="timeline-event__label">ENQUIRE 구축</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1983-flag-day">
								<span class="timeline-event__year">1983</span>
								<span class="timeline-event__label">TCP/IP 전환일</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1984-dns">
								<span class="timeline-event__year">1984</span>
								<span class="timeline-event__label">DNS 도입</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1986-sgml">
								<span class="timeline-event__year">1986</span>
								<span class="timeline-event__label">ISO SGML 표준</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-1990 topic-1990">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1990">1990–1993</p>
							<h3 class="timeline-group__topic" id="topic-1990">정적 문서를 연결한 첫 웹</h3>
							<p class="timeline-group__summary">팀 버너스-리가 “링크로 문서를 이어 보자”고 제안하고, 이를 누구나 따라 할 수 있게 설명한 시기입니다. 아직은 서버가 파일을 그대로 건네주고 브라우저가 보여 주기만 했던 순박한 웹의 모습입니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1990-www-proposal">
								<span class="timeline-event__year">1990</span>
								<span class="timeline-event__label">WWW 제안</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1991-first-site">
								<span class="timeline-event__year">1991</span>
								<span class="timeline-event__label">첫 웹사이트 공개</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1993-mosaic">
								<span class="timeline-event__year">1993</span>
								<span class="timeline-event__label">Mosaic 공개</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-1990-dynamic topic-1990-dynamic">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1990-dynamic">1993–1997</p>
							<h3 class="timeline-group__topic" id="topic-1990-dynamic">서버가 문서를 만들어 주기 시작하다</h3>
							<p class="timeline-group__summary">사람마다 다른 페이지를 보여 주고 싶다는 요구가 늘어나면서 서버와 브라우저 사이에 일이 나눠지기 시작했습니다. 이때 나온 CGI, JavaScript, PHP, CSS, ASP 덕분에 “백엔드는 생각을 처리하고, 프론트엔드는 화면을 꾸민다”는 개념이 생겼습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1993-cgi">
								<span class="timeline-event__year">1993</span>
								<span class="timeline-event__label">CGI 표준화</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1995-javascript">
								<span class="timeline-event__year">1995</span>
								<span class="timeline-event__label">JavaScript 탄생</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1995-php">
								<span class="timeline-event__year">1995</span>
								<span class="timeline-event__label">PHP 도구</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1996-css">
								<span class="timeline-event__year">1996</span>
								<span class="timeline-event__label">CSS 레벨 1 권고안</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1996-asp">
								<span class="timeline-event__year">1996</span>
								<span class="timeline-event__label">Active Server Pages</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1997-servlet">
								<span class="timeline-event__year">1997</span>
								<span class="timeline-event__label">Servlet 1.0 사양</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-2000 topic-2000">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-2000">1998–2008</p>
							<h3 class="timeline-group__topic" id="topic-2000">브라우저가 움직임을 맡다</h3>
							<p class="timeline-group__summary">인터넷이 대중화되자 “페이지가 너무 느려요”라는 목소리가 커졌습니다. HTTP/1.1, XMLHttpRequest, LAMP, Ajax, 모바일 웹, Chrome과 V8 같은 사건이 이어지면서 브라우저는 더 많은 일을 맡고, 서버는 데이터를 빠르게 전달하는 역할에 집중하게 됩니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1999-http11">
								<span class="timeline-event__year">1999</span>
								<span class="timeline-event__label">HTTP/1.1 정식화</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1999-xmlhttprequest">
								<span class="timeline-event__year">1999</span>
								<span class="timeline-event__label">XMLHttpRequest 등장</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1999-tomcat">
								<span class="timeline-event__year">1999</span>
								<span class="timeline-event__label">Apache Tomcat 공개</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2001-lamp">
								<span class="timeline-event__year">2001</span>
								<span class="timeline-event__label">LAMP 스택 확산</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2003-spring">
								<span class="timeline-event__year">2003</span>
								<span class="timeline-event__label">Spring 1.0 발표</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2005-ajax">
								<span class="timeline-event__year">2005</span>
								<span class="timeline-event__label">Ajax 패턴 확산</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2007-mobile-web">
								<span class="timeline-event__year">2007</span>
								<span class="timeline-event__label">모바일 웹 전환점</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2008-chrome">
								<span class="timeline-event__year">2008</span>
								<span class="timeline-event__label">Chrome &amp; V8 공개</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-2010 topic-2010">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-2010">2009–2016</p>
							<h3 class="timeline-group__topic" id="topic-2010">브라우저가 애플리케이션이 되다</h3>
							<p class="timeline-group__summary">이제 브라우저가 앱처럼 행동합니다. Node.js, 단일 페이지 앱 프레임워크, WebSocket, React 같은 도구가 나오면서 프론트엔드는 상태와 화면을 모두 챙기고, 백엔드는 필요한 데이터를 즉시 보내 주는 조력자가 됩니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="2009-node">
								<span class="timeline-event__year">2009</span>
								<span class="timeline-event__label">Node.js 발표</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2010-angularjs">
								<span class="timeline-event__year">2010</span>
								<span class="timeline-event__label">AngularJS 공개</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2011-websocket">
								<span class="timeline-event__year">2011</span>
								<span class="timeline-event__label">WebSocket 표준 확정</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2011-nginx">
								<span class="timeline-event__year">2011</span>
								<span class="timeline-event__label">Nginx 1.0 안정화</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2013-react">
								<span class="timeline-event__year">2013</span>
								<span class="timeline-event__label">React 발표</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-2020 topic-2020">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-2020">2014–2025</p>
							<h3 class="timeline-group__topic" id="topic-2020">API와 서버리스로 재조합</h3>
							<p class="timeline-group__summary">서버를 직접 살피지 않아도 되는 시대가 왔습니다. HTML5, 서버리스, GraphQL, PWA, WebAssembly, 엣지 함수, JAMstack 흐름이 이어지며 “필요한 기능만 조각처럼 가져다 쓰자”는 방식이 자리 잡았습니다. 프론트엔드는 독립적으로 배포하고, 백엔드는 API와 이벤트로 조용히 힘을 보탭니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="2014-lambda">
								<span class="timeline-event__year">2014</span>
								<span class="timeline-event__label">AWS Lambda 출시</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2014-html5">
								<span class="timeline-event__year">2014</span>
								<span class="timeline-event__label">HTML5 최종 권고</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2014-spring-boot">
								<span class="timeline-event__year">2014</span>
								<span class="timeline-event__label">Spring Boot 1.0</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2015-http2">
								<span class="timeline-event__year">2015</span>
								<span class="timeline-event__label">HTTP/2 표준 채택</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2015-graphql">
								<span class="timeline-event__year">2015</span>
								<span class="timeline-event__label">GraphQL 공개</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2015-lets-encrypt">
								<span class="timeline-event__year">2015</span>
								<span class="timeline-event__label">Let’s Encrypt 런칭</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2016-pwa">
								<span class="timeline-event__year">2016</span>
								<span class="timeline-event__label">PWA 권장 아키텍처</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2017-webassembly">
								<span class="timeline-event__year">2017</span>
								<span class="timeline-event__label">WebAssembly MVP 완료</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2017-cloudflare-workers">
								<span class="timeline-event__year">2017</span>
								<span class="timeline-event__label">Cloudflare Workers</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2020-jamstack">
								<span class="timeline-event__year">2020</span>
								<span class="timeline-event__label">JAMstack/엣지 확산</span>
							</button>
						</div>
					</section>
				</section>

				<section class="sources" id="sources" aria-labelledby="sources-title">
					<div class="section__head">
						<h2 id="sources-title">참고 자료</h2>
						<p>웹의 구조가 정적 문서에서 애플리케이션 플랫폼으로 바뀐 과정을 기록한 1차 자료와 회고를 모았습니다. 원문을 읽어 보면 각 시대의 개발자들이 어떤 문제를 해결하려 했는지 더 선명합니다.</p>
					</div>
					<ul class="source-list">
						<li><a href="https://dougengelbart.org/content/view/209/448/" target="_blank" rel="noopener">Doug Engelbart Institute · The Mother of All Demos</a></li>
						<li><a href="https://www.netlab.cs.ucla.edu/papers/UCLA_Internet_1969.pdf" target="_blank" rel="noopener">UCLA · Birth of the ARPANET</a></li>
						<li><a href="https://www.rfc-editor.org/rfc/rfc675" target="_blank" rel="noopener">IETF · RFC 675: Specification of Internet Transmission Control Program</a></li>
						<li><a href="https://www.cs.unc.edu/~barman/usenet/" target="_blank" rel="noopener">Usenet Historical Documents · A Brief History of Usenet</a></li>
						<li><a href="https://www.w3.org/History/1980/EnquireFrame.html" target="_blank" rel="noopener">W3C History · ENQUIRE Manual</a></li>
						<li><a href="https://www.livinginternet.com/i/ii_arpanet_flagday.htm" target="_blank" rel="noopener">Living Internet · ARPANET Flag Day</a></li>
						<li><a href="https://www.rfc-editor.org/rfc/rfc1034" target="_blank" rel="noopener">IETF · RFC 1034: Domain Names - Concepts and Facilities</a></li>
						<li><a href="https://www.iso.org/standard/16387.html" target="_blank" rel="noopener">ISO · ISO 8879:1986 Standard Generalized Markup Language</a></li>
						<li><a href="https://www.w3.org/Proposal.html" target="_blank" rel="noopener">Tim Berners-Lee · Information Management: A Proposal</a></li>
						<li><a href="https://www.w3.org/History/19921103-hypertext/hypertext/WWW/TheProject.html" target="_blank" rel="noopener">CERN · World Wide Web Project</a></li>
						<li><a href="https://www.rfc-editor.org/rfc/rfc3875" target="_blank" rel="noopener">NCSA · Common Gateway Interface Specification</a></li>
						<li><a href="https://www.w3.org/TR/CSS1/" target="_blank" rel="noopener">W3C · Cascading Style Sheets Level 1</a></li>
						<li><a href="https://queue.acm.org/detail.cfm?id=1117401" target="_blank" rel="noopener">ACM Queue · Ajax: A New Approach to Web Applications</a></li>
						<li><a href="https://www.rfc-editor.org/rfc/rfc2616" target="_blank" rel="noopener">IETF · RFC 2616: Hypertext Transfer Protocol 1.1</a></li>
						<li><a href="https://www.apple.com/newsroom/2007/01/09Apple-Reinvents-the-Phone-with-iPhone/" target="_blank" rel="noopener">Apple Newsroom · Apple Reinvents the Phone with iPhone</a></li>
						<li><a href="https://www.rfc-editor.org/rfc/rfc6455" target="_blank" rel="noopener">IETF · RFC 6455: The WebSocket Protocol</a></li>
						<li><a href="https://www.rfc-editor.org/rfc/rfc7540" target="_blank" rel="noopener">IETF · RFC 7540: Hypertext Transfer Protocol 2</a></li>
						<li><a href="https://blog.chromium.org/2008/09/google-chrome-now-available-in-beta.html" target="_blank" rel="noopener">Chromium Blog · Google Chrome Beta Announcement</a></li>
						<li><a href="https://www.w3.org/blog/news/archives/4167" target="_blank" rel="noopener">W3C News · HTML5 Is a W3C Recommendation</a></li>
						<li><a href="https://letsencrypt.org/2015/12/03/launching-lets-encrypt.html" target="_blank" rel="noopener">ISRG · Launching Let’s Encrypt</a></li>
						<li><a href="https://developers.google.com/web/progressive-web-apps" target="_blank" rel="noopener">Google Developers · Progressive Web Apps Guide</a></li>
						<li><a href="https://webassembly.org/news/announcing-the-webassembly-mvp/" target="_blank" rel="noopener">WebAssembly.org · Announcing the WebAssembly MVP</a></li>
						<li><a href="https://blog.cloudflare.com/introducing-cloudflare-workers/" target="_blank" rel="noopener">Cloudflare Blog · Introducing Cloudflare Workers</a></li>
						<li><a href="https://aws.amazon.com/blogs/aws/aws-lambda-event-driven-code-in-the-cloud/" target="_blank" rel="noopener">AWS News Blog · AWS Lambda Announcement</a></li>
						<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript" target="_blank" rel="noopener">MDN · A re-introduction to JavaScript</a></li>
						<li><a href="https://nodejs.org/en/about" target="_blank" rel="noopener">Node.js Foundation · About Node.js</a></li>
						<li><a href="https://engineering.fb.com/2015/09/14/core-data/graphql-a-data-query-language/" target="_blank" rel="noopener">Meta Engineering · GraphQL: A Data Query Language</a></li>
					</ul>
				</section>
			</main>

			<footer class="page__footer" role="contentinfo">
				<p>© 2025 ArcherLab · Stories on how the web split and reunited.</p>
				<a class="page__footer-link" href="https://archerlab.dev" target="_blank" rel="noopener">archerlab.dev</a>
			</footer>
		</div>

		<div class="modal" id="event-modal" role="dialog" aria-modal="true" hidden>
			<div class="modal__overlay" data-modal-close></div>
			<div class="modal__window" role="document" tabindex="-1">
				<button class="modal__close" type="button" aria-label="레이어 닫기" data-modal-close>&times;</button>
				<div class="modal__content"></div>
			</div>
		</div>

		<template id="event-1968-mother-demo">
			<article class="event-detail" aria-labelledby="event-1968-mother-demo-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1968</p>
					<h2 id="event-1968-mother-demo-title">Mother of All Demos</h2>
					<p class="event-detail__summary">더글러스 엥겔바트가 “문서가 화면에서 이어질 수 있다”는 사실을 최초로 생중계하며 마우스와 링크를 세상에 공개했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>샌프란시스코 무대 한가운데, 엥겔바트는 나무 상자 모양의 마우스를 잡고 “이 버튼을 누르면 다른 생각으로 건너갑니다.”라고 말했습니다. 화면에는 굵게 강조된 문장과 새 창이 이어졌고, 멀리 떨어진 동료의 커서가 전화선을 타고 함께 움직였습니다.</p>
						<p>관객은 숨을 죽인 채 화면을 바라봤고, “문서를 클릭해서 이동한다”는 개념이 처음으로 눈앞에 펼쳐졌습니다. 한 번의 시연이 “언젠가 모두가 링크로 이어진 공간에서 함께 일할 수 있다”는 상상을 현실로 끌어당겼습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>이날 소개된 하이퍼텍스트와 마우스, 공동 편집 아이디어는 이후 웹 브라우저의 기본 원칙이 됩니다. 프론트엔드는 링크를 따라 여행하는 화면을 맡고, 백엔드는 멀리 떨어진 사람의 데이터를 한곳에 보관해 주는 역할을 맡게 되는 첫 출발점이었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1969-arpanet">
			<article class="event-detail" aria-labelledby="event-1969-arpanet-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1969</p>
					<h2 id="event-1969-arpanet-title">ARPANET 최초 연결</h2>
					<p class="event-detail__summary">캘리포니아 연구실에서 보낸 ‘LO’ 두 글자가 끊기지 않고 스탠퍼드에 도착하며 “서로 떨어진 컴퓨터가 정말 대화할 수 있다”는 확신이 생겼습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>UCLA 연구원이 키보드로 <em>LOGIN</em>을 입력하던 순간, 화면에 ‘LO’ 두 글자만 찍히고 연결이 끊겼습니다. 하지만 그 두 글자가 수백 킬로미터 떨어진 스탠퍼드에 그대로 도착하자 실험실은 환호성으로 가득 찼습니다.</p>
						<p>이후 몇 주 만에 네트워크는 유타와 산타바바라까지 뻗어 갔고, 연구자들은 “컴퓨터를 직접 찾아가지 않아도 된다”는 사실을 알고 상대 연구실의 컴퓨팅 자원을 빌려 실험을 이어 갔습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>ARPANET은 큰 메시지를 잘게 나눠 여러 경로로 보내는 “패킷” 방식을 사용했습니다. 그래서 중간 노드가 잠시 멈춰도 다른 길로 우회할 수 있었습니다. 오늘날 우리가 아무 생각 없이 웹사이트를 열어 볼 수 있는 것도 이 튼튼한 발상 덕분입니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1974-tcpip">
			<article class="event-detail" aria-labelledby="event-1974-tcpip-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1974</p>
					<h2 id="event-1974-tcpip-title">TCP/IP 설계</h2>
					<p class="event-detail__summary">빈트 서프와 밥 칸은 “서로 다르게 생긴 네트워크라도 같은 규칙만 지키면 연결할 수 있다”고 설명하며 인터넷의 공용 언어를 제안했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>서프와 칸은 회의장에서 “인터넷 프로토콜(IP)이 주소를 붙여 길을 찾고, 전송 제어 프로토콜(TCP)이 순서를 맞춰 주면 된다”며 두 층으로 나눈 설계를 발표했습니다. 참관자들은 “이렇게 하면 서로 다른 장비도 대화를 이어 갈 수 있겠군요.”라고 되물었습니다.</p>
						<p>군과 대학 연구소는 곧 이 제안을 시험했고, 1970년대 후반에는 라우터와 운영체제가 TCP/IP를 기본 옵션으로 받아들이기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>TCP/IP는 일을 층층이 나눠 “주소 붙이기”와 “순서 맞추기”를 분리했습니다. 이 덕분에 훗날 HTTP, 이메일, 파일 전송 등 어떤 서비스도 같은 바닥 위에서 돌아갈 수 있었습니다. 서버는 IP 주소를 가지고 데이터를 보내고, 브라우저는 TCP 덕분에 빠진 글자 없이 안전하게 페이지를 받을 수 있게 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1978-usenet">
			<article class="event-detail" aria-labelledby="event-1978-usenet-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1978</p>
					<h2 id="event-1978-usenet-title">Usenet 개시</h2>
					<p class="event-detail__summary">두 대학이 전화선을 연결해 밤마다 글을 주고받으며 “서버끼리 서로 대신 전달하는 게시판”을 처음으로 선보였습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>듀크 대학의 짐과 톰은 저녁마다 전화선을 연결해 프로그램을 돌렸습니다. “자고 일어나면 다른 학교에서 올라온 새 글이 우리 서버에 있네요!” 그들은 <code>net.general</code> 게시판에 ‘안녕하세요’라는 첫 글을 남기며 실험을 시작했습니다.</p>
						<p>얼마 지나지 않아 다른 학교도 합류했고, 각 학교 서버는 받은 글을 보관했다가 다음 서버로 넘겨주었습니다. 학생들은 자신의 단말에서 조용히 글을 읽고, 답글을 쓰면서 보이지 않는 협업이 펼쳐졌습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Usenet은 “스토어 앤드 포워드”라는 단순한 원리를 따랐습니다. 서버는 받은 글을 잠시 저장했다가 다음 서버로 넘겨 주고, 사용자는 자기 컴퓨터에서 내용을 읽고 썼습니다. 오늘날 웹 서비스가 “서버는 데이터를 보관하고, 브라우저는 보여 준다”고 나누는 방식과 꼭 닮은 첫 연습장이었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1980-enquire">
			<article class="event-detail" aria-labelledby="event-1980-enquire-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1980</p>
					<h2 id="event-1980-enquire-title">ENQUIRE 구축</h2>
					<p class="event-detail__summary">팀 버너스-리는 실험 장비와 사람 정보를 엮어 보겠다며 ENQUIRE라는 개인 노트 프로그램을 만들었고, 이 경험이 훗날 웹으로 이어집니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>버너스-리는 CERN 복도에서 “이 장비는 누가 책임지고 있지?”라는 질문을 자주 들었습니다. 그래서 ENQUIRE라는 작은 프로그램을 만들어 “장비 → 담당자 → 실험”이 서로 연결되도록 글을 써 내려갔습니다.</p>
						<p>종이 공책 대신 컴퓨터 화면에서 링크를 눌러 이동하는 경험은 그에게 큰 인상을 남겼고, “이 구조를 전 세계 문서에도 적용할 수 있지 않을까?”라는 생각이 서서히 자라났습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>ENQUIRE는 “노드와 링크”라는 단순한 구조를 시험한 도구였습니다. 화면은 필요한 정보를 보기 좋게 보여 주고, 프로그램 속 저장소는 문서 사이 관계를 조용히 기억했습니다. 나중에 웹이 “브라우저는 보여 주고 서버는 기억한다”는 역할을 나누게 된 것도 이 경험에서 비롯됩니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1983-flag-day">
			<article class="event-detail" aria-labelledby="event-1983-flag-day-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1983</p>
					<h2 id="event-1983-flag-day-title">TCP/IP 전환일</h2>
					<p class="event-detail__summary">1983년 새해 첫날, ARPANET이 모두 약속한 시간에 맞춰 TCP/IP로 갈아타며 “인터넷의 공식 언어”를 확정했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>미 국방성이 “1983년 1월 1일부터는 모두 TCP/IP를 쓰세요”라는 공문을 보내자, 네트워크 운영자들은 밤샘 작업을 시작했습니다. 케이블을 점검하고 소프트웨어를 바꾼 뒤, 새해 첫 아침 전원을 켰을 때 네트워크는 문제 없이 돌아갔습니다.</p>
						<p>이 성공을 지켜본 다른 연구망과 기업도 잇달아 같은 규칙을 받아들였고, 서로 다른 조직의 네트워크가 하나의 큰 인터넷으로 묶이기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>이날 이후 “TCP/IP만 따르면 누구와도 연결할 수 있다”는 믿음이 생겼습니다. 서버는 TCP/IP 스택 위에서 돌아가고, 브라우저는 표준 주소를 통해 어느 곳과도 대화를 시도할 수 있습니다. 우리가 다른 나라의 웹사이트를 자연스럽게 방문하는 배경에는 이 합의가 있습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1984-dns">
			<article class="event-detail" aria-labelledby="event-1984-dns-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1984</p>
					<h2 id="event-1984-dns-title">DNS 도입</h2>
					<p class="event-detail__summary">사람이 외우기 힘든 숫자 대신 이름으로 사이트를 찾을 수 있도록, DNS가 등장해 주소록 역할을 맡았습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>폴 모카페트리스는 두꺼운 ‘호스트 목록’ 파일을 들고 “이걸 일일이 업데이트하는 방식은 이제 한계입니다”라고 말했습니다. 그는 전화를 돌려 루트 서버와 하위 서버가 서로 물어보는 구조를 고안했고, <code>.com</code>, <code>.edu</code>처럼 역할이 다른 이름을 만들었습니다.</p>
						<p>운영자들은 새 서버를 소개할 때 긴 IP 대신 짧은 이름을 등록했고, 사람들은 기억하기 쉬운 주소만 입력하면 멀리 있는 컴퓨터에 접속할 수 있게 됐습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>DNS는 웹의 전화번호부입니다. 서버는 도메인 이름을 등록해 자신을 소개하고, 브라우저는 그 이름을 입력해 숫자 주소를 자동으로 찾아옵니다. 이 구조가 URL, 즐겨찾기, 하이퍼링크 같은 경험을 가능하게 했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1986-sgml">
			<article class="event-detail" aria-labelledby="event-1986-sgml-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1986</p>
					<h2 id="event-1986-sgml-title">ISO SGML 표준</h2>
					<p class="event-detail__summary">문서를 제목, 문단, 목록 같은 조각으로 나누는 규칙이 SGML이라는 이름으로 표준이 되었고, 훗날 HTML의 뼈대가 되었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>국제표준화기구(ISO)는 1986년 “문서의 모양이 아니라 구조를 먼저 적어 두자”라며 SGML을 승인했습니다. 출판사와 정부 기관은 <code>&lt;title&gt;</code>, <code>&lt;p&gt;</code> 같은 태그를 사용해 문서를 주고받기 시작했습니다.</p>
						<p>개발자들은 “같은 태그만 쓰면 다른 시스템에서도 내용이 그대로 보이네”라는 점을 확인하며, 특정 기기나 프로그램에 묶이지 않는 문서 표현법이 필요하다는 사실을 깨달았습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>SGML은 “문서에 이름표를 붙인다”는 간단한 아이디어를 표준으로 만들었습니다. 이후 HTML과 XML이 이 생각을 이어받았고, 브라우저는 태그를 읽어 화면에 그려 주며, 서버는 태그 구조를 만들어 저장하는 역할을 하게 됩니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1990-www-proposal">
			<article class="event-detail" aria-labelledby="event-1990-www-proposal-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1990</p>
					<h2 id="event-1990-www-proposal-title">WWW 제안 · 팀 버너스-리</h2>
					<p class="event-detail__summary">CERN 연구원이 “문서를 좀 쉽게 공유할 수 없을까?”라고 묻자, 팀 버너스-리는 하이퍼텍스트와 인터넷을 묶은 ‘월드 와이드 웹’ 제안을 꺼내 놓았습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>버너스-리는 “Information Management: A Proposal”이라는 제목의 문서를 쓰며, 종이에 간단한 그림을 그렸습니다. “문서를 링크로 엮고, 서버라는 컴퓨터가 요청을 받으면 파일을 보내 주는 거죠.” 동료가 “주소는 어떻게 쓰나요?”라고 묻자, 그는 <code>http://</code> 이라는 표기를 적어 보였습니다.</p>
						<p>CERN은 시험용 컴퓨터 한 대를 내주었고, 팀은 HTML, HTTP, 첫 웹 서버를 직접 만들었습니다. 연구자들은 메일 첨부 대신 링크 하나만 보내도 같은 문서를 함께 볼 수 있다는 사실에 놀라며 새 방식을 받아들였습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>제안서에는 세 가지 그림이 있었습니다. <strong>URI</strong>라는 주소 체계, <strong>HTTP</strong>라는 약속, <strong>HTML</strong>이라는 문서 언어입니다. 이 세 조각만 맞추면 누구나 문서를 올리고, 다른 사람이 같은 브라우저로 읽을 수 있었습니다. 그 시절 서버는 파일을 그대로 돌려주는 역할만 했고, 별도의 “백엔드 로직”은 아직 등장하지 않았습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1991-first-site">
			<article class="event-detail" aria-labelledby="event-1991-first-site-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1991</p>
					<h2 id="event-1991-first-site-title">첫 웹사이트 공개</h2>
					<p class="event-detail__summary">세계 최초의 웹페이지는 “웹을 만들고 싶다면 이렇게 하세요”라고 친절히 설명하는 안내서였습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>1991년 8월, 버너스-리는 <code>info.cern.ch</code>라는 새 주소를 열고 “World Wide Web Project” 페이지를 올렸습니다. 검정 글자와 파란 링크만 있는 단순한 문서였지만, HTML 태그 목록과 사용법, 예제 코드가 일목요연하게 정리돼 있었습니다.</p>
						<p>전화선으로 접속한 연구자들은 화살표 키로 링크를 오가며 “문서 사이를 이렇게 왔다 갔다 할 수 있구나” 하고 감탄했습니다. 얼마 지나지 않아 다른 연구실도 이 페이지를 따라 첫 웹서버를 가동했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>첫 웹페이지는 설명서이자 홍보물이었습니다. 서버를 설치하는 법, HTML 태그, 링크 만드는 규칙을 모두 공개해 누구나 같은 방법으로 따라 할 수 있도록 했습니다. 서버는 여전히 파일을 그대로 보내고, 브라우저는 화면에 보여 주기만 했지만, 그 단순함 덕분에 웹은 한 달 새 여러 나라로 퍼져 나갔습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1993-mosaic">
			<article class="event-detail" aria-labelledby="event-1993-mosaic-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1993</p>
					<h2 id="event-1993-mosaic-title">Mosaic 브라우저 공개</h2>
					<p class="event-detail__summary">그래픽 화면을 갖춘 Mosaic 덕분에 연구소 밖 사람들도 마우스로 링크를 클릭하는 즐거움을 처음 맛보았습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>NCSA 학생들은 시연회에서 관객에게 마우스를 건네며 말했습니다. “저 파란 글자를 눌러 보세요.” 클릭하는 순간 같은 창에서 다른 문서가 펼쳐졌고, 사람들은 “정말 바로 넘어가네요!”라고 탄성을 질렀습니다.</p>
						<p>신문 기자들은 Mosaic 화면을 사진으로 찍어 “웹이란 이런 모습입니다”라는 기사와 함께 실었습니다. 곧 대학과 기업이 Mosaic을 설치하고 정적 페이지를 올리기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Mosaic은 이미지와 텍스트를 같은 화면에 놓고, 링크를 클릭하며 돌아다닐 수 있게 해 줬습니다. 이 덕분에 ‘웹’이라는 단어가 대중에게 알려졌지만, 서버는 여전히 누구에게나 같은 파일을 보내는 수준이었습니다. “사람마다 다른 페이지를 보여 줄 수 있을까?”라는 고민이 본격적으로 시작된 것도 이때입니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1993-cgi">
			<article class="event-detail" aria-labelledby="event-1993-cgi-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1993</p>
					<h2 id="event-1993-cgi-title">CGI 표준화</h2>
					<p class="event-detail__summary">서버가 작은 프로그램을 불러 HTML을 즉석에서 만들 수 있게 해 주는 CGI 규칙이 정리되며 “백엔드”라는 개념이 모습을 드러냈습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>NCSA httpd 팀에 “게스트북에 남긴 글을 바로 보여 주면 좋겠다”는 문의가 들어오자, 개발자 수지는 “요청이 오면 잠깐 프로그램을 실행해 새 HTML을 만들어 돌려주죠”라고 답했습니다.</p>
						<p>이 아이디어가 Common Gateway Interface, 줄여서 CGI입니다. 사용자가 폼을 보내면 서버는 Perl 같은 스크립트를 실행해 데이터를 저장하고, 방금 저장한 내용을 HTML로 만들어 보여 주었습니다. “이제 페이지가 사람마다 다르게 바뀔 수 있겠네!”라는 감탄이 이어졌습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>CGI는 서버가 요청 정보를 프로그램에 넘기고, 프로그램이 HTML을 되돌려주는 간단한 약속입니다. 이 덕분에 “서버가 생각을 처리한 뒤 화면을 만든다”는 흐름이 생겼고, 우리는 이 부분을 백엔드라고 부르기 시작했습니다. 단점은 요청이 올 때마다 새 프로그램을 띄우느라 서버가 바빠진다는 점이었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1995-javascript">
			<article class="event-detail" aria-labelledby="event-1995-javascript-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1995</p>
					<h2 id="event-1995-javascript-title">JavaScript 탄생</h2>
					<p class="event-detail__summary">브라우저가 버튼 클릭과 즉시 반응을 직접 처리할 수 있도록, 가벼운 스크립트 언어인 JavaScript가 탄생했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Netscape에서 일하던 브렌던 아이크는 “작은 폼 하나를 고치려고 매번 서버에 다녀오니 너무 답답해요”라는 요청을 듣고 10일 만에 새 언어를 만들어 냈습니다. 처음에는 LiveScript라 불렸지만, 곧 JavaScript라는 이름으로 공개됐습니다.</p>
						<p>시연에서 사용자가 이름을 입력하자 화면의 인사말이 즉시 바뀌었습니다. 버튼, 검증, 이미지 전환 같은 일이 브라우저 안에서 바로 이루어지며 “프론트엔드도 하나의 프로그램을 만들 수 있다”는 사실이 널리 알려졌습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>JavaScript는 브라우저를 작은 런타임으로 바꾸었습니다. 화면 요소(DOM)를 직접 고치고, 이벤트가 일어날 때마다 코드를 실행할 수 있게 했습니다. 그 결과 브라우저가 즉각적인 반응을 맡고, 서버는 데이터와 핵심 규칙에 집중하는 분업이 자리 잡기 시작했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1995-php">
			<article class="event-detail" aria-labelledby="event-1995-php-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1995</p>
					<h2 id="event-1995-php-title">PHP 도구의 공개</h2>
					<p class="event-detail__summary">라스무스 러도르프는 HTML 틀 사이에 코드를 넣을 수 있는 PHP를 공개해, 웹페이지를 즉석에서 조립하기 쉽게 만들었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>라스무스는 개인 홈페이지 방문 통계를 만들다 “Perl 스크립트를 자꾸 따로 유지하기 힘드네”라고 고민했습니다. 그래서 HTML 안에 <code>&lt;?php ... ?&gt;</code>처럼 작은 코드를 끼워 넣어 데이터베이스에 연결하고 결과를 바로 출력하는 방식을 고안했습니다.</p>
						<p>커뮤니티에는 “폼 검증이 한 줄로 끝났어요!” 같은 후기 글이 올라왔고, 웹마스터들은 PHP로 게시판과 쇼핑몰을 척척 만들기 시작했습니다. 서버는 요청이 들어올 때마다 PHP를 실행해 새 HTML을 만들어 돌려주었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>PHP는 화면(HTML)과 로직을 한 파일에 함께 적을 수 있게 해 초기 웹 개발을 크게 단순화했습니다. 이 덕분에 백엔드는 데이터베이스, 인증, 세션을 책임지고, 브라우저는 만들어진 HTML을 보여 주는 역할로 정리되기 시작했습니다. 이후 프레임워크와 MVC 개념도 이런 흐름에서 파생됐습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1996-css">
			<article class="event-detail" aria-labelledby="event-1996-css-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1996</p>
					<h2 id="event-1996-css-title">CSS 레벨 1 권고안</h2>
					<p class="event-detail__summary">W3C는 “HTML은 내용, CSS는 모양”이라는 간단한 원칙을 정리해 스타일시트 권고안을 발표했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>보스턴에서 열린 W3C 회의에서 하콘 비움 리와 베르트 보스는 “HTML은 내용, CSS는 꾸밈”이라는 메시지가 적힌 슬라이드를 띄웠습니다. <code>h1 { color: navy; }</code>를 입력하자 제목 색이 바로 바뀌는 모습에 참석자들의 눈이 동그래졌습니다.</p>
						<p>얼마 지나지 않아 브라우저에는 CSS 기능이 추가됐고, 디자이너들은 테이블 레이아웃을 내려놓고 스타일시트 실험에 뛰어들었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>CSS는 내용과 모양을 분리해 생각하게 만들었습니다. 프론트엔드는 같은 HTML 구조를 유지한 채 CSS만 바꿔 분위기를 바꿀 수 있었고, 백엔드는 화면 꾸밈 대신 데이터와 로직에 집중할 수 있었습니다. 이후 박스 모델, 미디어 쿼리 같은 확장이 나오면서 프론트엔드는 사용자 경험을 책임지는 전문 분야로 성장합니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1996-asp">
			<article class="event-detail" aria-labelledby="event-1996-asp-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1996</p>
					<h2 id="event-1996-asp-title">Active Server Pages 도입</h2>
					<p class="event-detail__summary">마이크로소프트는 Active Server Pages를 통해 윈도우 서버에서 곧바로 동적인 웹 화면을 만들 수 있도록 했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>사내 프로젝트 회의에서 PM은 “사원 포털을 웹으로 바꿔 주세요”라고 요청했습니다. 개발자들은 HTML 파일 속에 VBScript와 JScript를 섞어 넣었고, 저장 버튼을 누르자 IIS가 자동으로 코드를 실행해 결과 페이지를 돌려줬습니다.</p>
						<p>IT 부서는 “윈도우 서버와 SQL Server를 그대로 쓰면서 웹을 만들 수 있네요”라며 반겼습니다. 기업용 웹 애플리케이션은 서버 쪽 로직이 더욱 두꺼워지기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>ASP는 세션, 데이터베이스 연결, 윈도우 컴포넌트 연동을 기본 기능으로 제공했습니다. 덕분에 서버는 주문, 재고, 권한 같은 비즈니스 로직을 책임지고, 브라우저는 만들어진 HTML과 가벼운 스크립트를 보여 주는 식의 분업이 뚜렷해졌습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1997-servlet">
			<article class="event-detail" aria-labelledby="event-1997-servlet-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1997</p>
					<h2 id="event-1997-servlet-title">Servlet 1.0 사양</h2>
					<p class="event-detail__summary">Sun은 자바 서블릿 사양을 발표해 “HTTP 요청을 클래스로 처리하자”는 공통 규칙을 제시했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Sun 개발자 회의에서 발표자는 <code>HttpServlet</code> 클래스를 띄우며 “doGet과 doPost 안에서 필요한 일을 하세요”라고 설명했습니다. 시연에서 사용자가 폼을 제출하자, 서블릿이 주문 데이터를 읽고 새로운 HTML을 만들어 돌려줬습니다.</p>
						<p>은행과 공공기관은 “동시에 많은 요청을 다루는 표준이 드디어 생겼다”며 서블릿 컨테이너 도입을 검토했습니다. 자바 진영은 공용 API를 중심으로 WAS를 발전시킬 발판을 마련했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>서블릿 사양은 요청·응답 객체, 필터, 라이프사이클 메서드 같은 개념을 정의했습니다. 덕분에 개발자는 어떤 컨테이너에서 실행하든 같은 코드를 사용할 수 있었고, WAS 벤더는 세션, 스레드, 보안 같은 공통 기능을 책임지게 되었습니다. 이는 이후 JSP, Tomcat, Spring 같은 기술이 함께 돌아가게 만든 토대였습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1999-http11">
			<article class="event-detail" aria-labelledby="event-1999-http11-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1999</p>
					<h2 id="event-1999-http11-title">HTTP/1.1 정식화</h2>
					<p class="event-detail__summary">HTTP/1.1 표준이 등장하면서 “한 번 연결로 여러 요청을 보내자” 같은 규칙이 정해져, 웹이 더 빠르고 안정적으로 동작하게 되었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>IETF 회의에서 로이 필딩은 “페이지를 열 때마다 연결을 새로 만드는 건 너무 굼뜹니다”라며 <code>Connection: keep-alive</code>를 소개했습니다. 덕분에 브라우저는 하나의 연결을 유지하며 여러 파일을 연달아 받을 수 있게 되었습니다.</p>
						<p>또한 <code>Host</code> 헤더 덕분에 같은 IP 주소로도 여러 사이트를 운영할 수 있게 되었고, 캐시 규칙이 정리되면서 CDN이 등장해 세계 곳곳에 파일을 미리 저장해 두기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>HTTP/1.1은 지속 연결, 청크 전송, 캐시 헤더 같은 규칙을 묶어 발표했습니다. 서버는 연결을 재사용해 효율이 높아졌고, 브라우저는 더 빠른 응답을 받게 되었습니다. 이후 REST 아키텍처와 CDN이 퍼질 수 있었던 든든한 밑바탕입니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1999-tomcat">
			<article class="event-detail" aria-labelledby="event-1999-tomcat-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1999</p>
					<h2 id="event-1999-tomcat-title">Apache Tomcat 공개</h2>
					<p class="event-detail__summary">Sun은 서블릿·JSP 레퍼런스 구현을 Apache 재단에 기증하며 Tomcat을 오픈소스로 공개했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>자바원 행사장에서 제임스 던컨 데이비슨은 노트북을 열고 <code>startup.sh</code>를 실행했습니다. 콘솔에 고양이 로고가 뜨자 청중이 웃었고, 곧바로 브라우저에서 JSP가 새 HTML을 만들어 응답하는 장면이 재현됐습니다.</p>
						<p>Sun은 “표준은 개방형 구현이 있어야 널리 쓰입니다”라며 코드를 Apache에 넘겼습니다. 개발자들은 Tomcat을 내려받아 <code>webapps</code> 폴더에 WAR 파일을 복사하는 것만으로 서블릿 애플리케이션을 배포할 수 있게 됐습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Tomcat은 커넥터, 스레드 풀, JSP 컴파일러를 내장해 개발용 WAS의 사실상 표준이 되었습니다. 덕분에 팀은 동일한 컨테이너 위에서 개발·운영 환경을 맞출 수 있었고, 이후 Spring, Struts 같은 프레임워크와 자연스럽게 통합되었습니다. Tomcat의 오픈소스 모델은 Jetty, JBoss 등 다른 WAS의 등장을 자극했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1999-xmlhttprequest">
			<article class="event-detail" aria-labelledby="event-1999-xmlhttprequest-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1999</p>
					<h2 id="event-1999-xmlhttprequest-title">XMLHttpRequest 등장</h2>
					<p class="event-detail__summary">XMLHttpRequest 덕분에 브라우저는 화면을 갈아엎지 않고도 조용히 서버와 데이터를 주고받을 수 있게 되었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Outlook Web Access 팀은 “웹메일도 데스크톱처럼 부드러우면 좋겠다”고 고민했습니다. 개발자 리나는 “화면 전체를 다시 그리지 말고 필요한 데이터만 몰래 가져오자”며 <code>XMLHttpRequest</code> 객체를 만들었습니다. 버튼을 눌러도 화면이 깜박이지 않자 사용자들은 놀랐습니다.</p>
						<p>다른 브라우저도 곧 같은 기능을 따라 했고, 프론트엔드는 화면은 그대로 둔 채 JSON이나 XML만 받아 필요한 부분을 살짝 바꾸기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>XMLHttpRequest는 “브라우저가 스스로 서버에 말을 걸 수 있다”는 문을 열었습니다. 화면은 그대로 두고 데이터만 새로 받아오는 Ajax 패턴이 탄생했고, 프론트엔드는 더 많은 로직을 맡게 되었습니다. 동시에 백엔드는 HTML 대신 JSON 같은 가벼운 데이터를 돌려주는 역할에 집중하기 시작했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2001-lamp">
			<article class="event-detail" aria-labelledby="event-2001-lamp-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2001</p>
					<h2 id="event-2001-lamp-title">LAMP 스택 확산</h2>
					<p class="event-detail__summary">리눅스, 아파치, MySQL, PHP를 묶은 ‘LAMP’ 조합이 “이대로 설치하면 웹서비스가 돌아간다”는 레시피로 자리 잡았습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>2001년 잡지 기사에 “LAMP는 저렴하고 강력하다”는 문장이 실리자, 스타트업 창업자들은 서로 링크를 돌렸습니다. “리눅스, 아파치, MySQL, PHP만 깔면 게시판이 돌아간대!”</p>
						<p>호스팅 업체는 월 요금제에 LAMP 환경을 묶어 팔았고, 개발자들은 템플릿과 플러그인을 얹은 CMS를 배포했습니다. 서버는 데이터베이스와 PHP 코드를 맡고, 브라우저는 만들어진 HTML과 자바스크립트를 보여주는 협업 방식이 빠르게 퍼졌습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>LAMP 스택은 “운영체제, 웹서버, 데이터베이스, 서버 스크립트”로 역할을 나누는 사고방식을 굳혔습니다. 이 구조 덕분에 팀은 어디까지가 백엔드이고, 어떤 부분이 프론트엔드인지 명확히 이야기할 수 있었습니다. 이후 Ruby on Rails, Django 같은 프레임워크도 이 흐름을 이어 받았습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2003-spring">
			<article class="event-detail" aria-labelledby="event-2003-spring-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2003</p>
					<h2 id="event-2003-spring-title">Spring 1.0 발표</h2>
					<p class="event-detail__summary">Spring 1.0은 “EJB 없이도 견고한 서버를 만들 수 있다”는 해법을 제시하며 자바 백엔드 구조를 가볍게 바꿨습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Rod Johnson은 《Expert One-on-One J2EE》에서 무거운 EJB 사용기를 털어놓은 뒤, 컨퍼런스에서 “객체를 단순 자바 클래스로 유지하고 외부에서 주입하면 됩니다”라며 Spring 1.0을 선보였습니다.</p>
						<p>데모에서는 XML 설정으로 서비스 객체와 DAO를 연결하고, 테스트에서는 컨테이너 없이도 단위 테스트가 돌아갔습니다. 기업 개발팀은 “경량 컨테이너로도 트랜잭션과 보안을 처리할 수 있네”라며 도입을 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Spring은 IoC 컨테이너와 AOP로 의존성을 주입하고 트랜잭션을 선언적으로 관리하게 했습니다. 덕분에 백엔드는 얇은 서비스 계층을 유지하면서도 확장성과 테스트 용이성을 갖출 수 있었고, 프론트엔드는 안정적인 API를 기대할 수 있었습니다. 이후 Spring MVC, Spring Security, Spring Boot가 같은 철학을 이어갑니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2005-ajax">
			<article class="event-detail" aria-labelledby="event-2005-ajax-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2005</p>
					<h2 id="event-2005-ajax-title">Ajax 패턴 확산</h2>
					<p class="event-detail__summary">구글 지도와 지메일이 화면을 새로 고치지 않고 부드럽게 움직이는 모습을 보여 주며 “브라우저가 더 많은 일을 맡자”는 흐름이 확산됐습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>2005년 구글 지도는 지도를 끌어도 화면이 깜박이지 않았고, 지메일은 새 메일만 자연스럽게 끼워 넣었습니다. 사용자들은 “이게 정말 웹이 맞나요?”라며 놀랐습니다.</p>
						<p>이 패턴은 Ajax라 불렸고, 수많은 블로그와 컨퍼런스에서 소개되었습니다. 개발자들은 프론트엔드에 상태 관리와 렌더링 로직을 더 많이 두기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Ajax는 “필요한 데이터만 몰래 가져와 화면 일부만 바꾼다”는 단순한 아이디어입니다. 서버는 JSON 같은 데이터를 준비하고, 브라우저는 DOM을 직접 고쳐 사용자에게 즉시 반응했습니다. 이 방식이 REST API 확산과 맞물리며 프론트엔드와 백엔드 분업을 한층 뚜렷하게 만들었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2007-mobile-web">
			<article class="event-detail" aria-labelledby="event-2007-mobile-web-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2007</p>
					<h2 id="event-2007-mobile-web-title">모바일 웹 전환점</h2>
					<p class="event-detail__summary">아이폰이 등장하며 손바닥에서도 제대로 보이는 웹이 필요해졌고, 가벼운 API와 반응형 디자인이 급속도로 퍼졌습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>2007년 스티브 잡스는 무대에서 아이폰을 쥐고 “손가락으로 웹을 탐색하세요”라고 말했습니다. 작은 화면 속 Safari는 데스크톱 사이트를 축소해 보여 주면서도 확대와 스크롤이 매끄러웠습니다.</p>
						<p>곧 제품팀은 “3G에서도 빨리 열리게 만들어 주세요”라고 요구했습니다. 회사들은 모바일 전용 API와 이미지 최적화 전략을 내놓았고, 2010년 Ethan Marcotte의 반응형 웹 디자인 제안이 나오면서 하나의 웹이 여러 기기에 적응하는 시대가 열렸습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>모바일 웹은 프론트엔드에 미디어 쿼리와 터치 친화적인 디자인을 요구했습니다. 백엔드는 JSON API, 이미지 최적화, 캐시 전략을 통해 응답을 가볍게 만들었습니다. 덕분에 하나의 백엔드가 웹앱과 네이티브 앱을 동시에 지원하는 멀티채널 구조가 시작되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2008-chrome">
			<article class="event-detail" aria-labelledby="event-2008-chrome-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2008</p>
					<h2 id="event-2008-chrome-title">Google Chrome &amp; V8 공개</h2>
					<p class="event-detail__summary">구글은 크롬과 V8 엔진을 공개하며 “브라우저에서도 프로그램이 빠르게 돌아갈 수 있다”는 믿음을 퍼뜨렸습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>2008년 9월 구글은 만화책으로 새 브라우저를 소개하며 “각 탭은 독립된 공간이고, V8 엔진이 자바스크립트를 즉석에서 빠르게 돌립니다”라고 설명했습니다.</p>
						<p>뒤이어 Gmail, Google Docs 시연에서 빠른 속도가 눈으로 확인되자, “브라우저 안에서도 복잡한 앱을 돌릴 수 있다”는 메시지가 퍼졌습니다. 다른 브라우저도 엔진을 강화하며 속도 경쟁에 나섰습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>V8은 자바스크립트를 기계어로 빠르게 바꾸는 JIT 컴파일러를 제공했습니다. 이 덕분에 프론트엔드는 실시간 협업이나 3D 렌더링 같은 무거운 작업도 시도할 수 있었고, 백엔드는 REST API와 WebSocket으로 데이터를 가볍게 전달하는 데 집중하게 됐습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2009-node">
			<article class="event-detail" aria-labelledby="event-2009-node-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2009</p>
					<h2 id="event-2009-node-title">Node.js 발표</h2>
					<p class="event-detail__summary">Node.js는 “자바스크립트를 서버에서도 쓰자”는 아이디어를 실현해, 한 언어로 프론트와 백엔드를 잇는 시대를 열었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>JSConf 2009에서 라이언 달은 “파일이 올라오는 동안 서버가 멈춰 있을 필요 없습니다”라며 Node.js를 소개했습니다. 그는 몇 줄짜리 자바스크립트 코드로 수천 개 연결을 동시에 처리하는 데모를 보여 주었습니다.</p>
						<p>관객은 같은 언어로 프론트엔드와 백엔드 코드를 나눠 쓸 수 있다는 사실에 열광했습니다. 곧 Express 같은 프레임워크와 npm 생태계가 등장하며 JSON 기반 협업이 당연해졌습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Node.js는 이벤트 루프를 통해 여러 요청을 빠르게 돌려주는 구조를 제공합니다. 이 덕분에 채팅, 스트리밍 같은 실시간 서비스가 쉬워졌고, 프론트와 백엔드가 같은 언어를 쓰며 코드를 공유하는 “풀스택 자바스크립트” 흐름이 자리 잡았습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2010-angularjs">
			<article class="event-detail" aria-labelledby="event-2010-angularjs-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2010</p>
					<h2 id="event-2010-angularjs-title">AngularJS 공개</h2>
					<p class="event-detail__summary">구글은 AngularJS를 공개해 “브라우저 안에서도 화면과 데이터 흐름을 스스로 관리하자”는 생각을 현실로 만들었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>구글 개발자 미로슬라브는 “HTML도 앱처럼 다룰 수 있어야 합니다”라며 AngularJS를 오픈소스로 내놓았습니다. 폼에 이름을 적자 화면이 즉시 바뀌었고, 컨트롤러라는 코드가 데이터를 정리했습니다.</p>
						<p>스타트업과 대기업은 대시보드, 관리자 도구를 AngularJS로 만들며 “브라우저만으로도 충분히 앱을 돌릴 수 있구나”라는 확신을 얻었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>AngularJS는 화면 구성, 라우팅, 상태 관리를 브라우저가 직접 맡게 했습니다. 서버는 JSON API를 제공하는 역할로 더 깔끔하게 정리되었고, 프론트엔드 세계에는 CLI와 빌드 도구 같은 전용 장비가 빠르게 늘어났습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2011-websocket">
			<article class="event-detail" aria-labelledby="event-2011-websocket-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2011</p>
					<h2 id="event-2011-websocket-title">WebSocket 표준 확정</h2>
					<p class="event-detail__summary">RFC 6455가 승인되면서 브라우저와 서버가 하나의 연결을 붙잡고 실시간으로 대화를 주고받을 수 있게 됐습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>IETF 회의에서 이안 힉슨은 “서버에 계속 ‘새 소식 있나요?’라고 묻지 말고, 한 번 연결하면 서로 말을 주고받게 합시다”라며 WebSocket 핸드셰이크를 보여 주었습니다. 크롬 도구에 서버 메시지가 즉시 표시되자 박수가 터졌습니다.</p>
						<p>트레이딩 데스크, 게임 회사, 채팅 서비스는 바로 실험을 시작했습니다. GitHub 알림과 Slack 메시지 스트림이 WebSocket을 채택하며 실시간 경험이 일상으로 들어왔습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>WebSocket은 HTTP 연결을 업그레이드해 하나의 파이프를 열어 두는 방식입니다. 브라우저는 서버가 보내는 메시지를 즉시 받아 화면을 바꾸고, 서버는 이벤트 루프와 메시지 브로커로 상태를 맞춥니다. 이후 Socket.IO, GraphQL Subscriptions 같은 실시간 기술이 이 위에서 자랐습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2011-nginx">
			<article class="event-detail" aria-labelledby="event-2011-nginx-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2011</p>
					<h2 id="event-2011-nginx-title">Nginx 1.0 안정화</h2>
					<p class="event-detail__summary">Nginx 1.0은 이벤트 기반 웹 서버를 안정판으로 공개하며 “가볍고 빠른 리버스 프록시” 시대를 열었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>2011년 4월, 이고르 시소예프는 메일링 리스트에 “Nginx 1.0이 나왔습니다. 이제 생산 환경에서 마음껏 쓰세요”라는 짧은 공지를 남겼습니다. 벤치마크에서는 수만 개의 동시 연결을 적은 메모리로 처리하는 모습이 잡혔습니다.</p>
						<p>스타트업은 정적 파일을 Nginx로 서빙하고, 백엔드 애플리케이션 앞단에는 리버스 프록시로 배치했습니다. 운영팀은 <code>nginx.conf</code>에 로드밸런싱과 캐시 설정을 적으며 “서버 한 대로도 많은 사용자를 버틴다”고 보고했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Nginx는 비동기 이벤트 루프, 비차단 I/O, 설정 기반 리버스 프록시를 제공했습니다. 덕분에 백엔드는 WAS와 API 서버를 여러 대로 쪼개고, 앞단에서는 Nginx가 트래픽을 분산했습니다. 이 구조는 이후 마이크로서비스, 컨테이너 오케스트레이션에서도 기본 패턴이 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2013-react">
			<article class="event-detail" aria-labelledby="event-2013-react-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2013</p>
					<h2 id="event-2013-react-title">React 발표</h2>
					<p class="event-detail__summary">페이스북은 React를 발표하며 “화면을 작은 조각으로 나누고 상태가 바뀌면 다시 그리자”는 간단한 원칙을 제시했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>JSConf 무대에서 페이스북 엔지니어 조던은 “DOM을 직접 건드리지 말고, 화면을 컴포넌트라는 작은 조각으로 선언하세요”라고 말했습니다. 낯선 Virtual DOM 개념에 걱정이 있었지만, 시연 화면은 빠르게 갱신됐습니다.</p>
						<p>곧 스타트업과 대기업이 React를 도입했고, 프론트엔드 팀은 상태 관리, 빌드, 테스트 도구까지 갖춘 독립 조직으로 성장했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>React가 보여준 컴포넌트 방식은 UI를 작은 조각으로 나누고, 필요한 데이터는 API로 가져오게 만들었습니다. 이후 Vue, Svelte 등이 뒤따르며 프론트엔드는 라우팅, 상태, 렌더링을 직접 맡는 완전한 애플리케이션 계층이 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2014-lambda">
			<article class="event-detail" aria-labelledby="event-2014-lambda-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2014</p>
					<h2 id="event-2014-lambda-title">AWS Lambda 출시</h2>
					<p class="event-detail__summary">AWS는 Lambda를 내놓으며 “서버를 직접 돌리지 말고, 필요한 코드만 올려 두세요”라는 메시지를 현실로 만들었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>AWS re:Invent 무대에서 발표자가 “이제 서버를 예약하지 않아도 됩니다”라며 Lambda를 소개했습니다. 개발자 앨리스가 콘솔에 짧은 함수를 저장하자, 곧바로 웹훅 주소가 생겨 요청을 받아들였습니다.</p>
						<p>스타트업들은 로그인, 알림, 이미지 처리 등을 Lambda로 옮겨 운영 부담을 줄였고, 백엔드는 점점 더 작은 함수와 이벤트 중심 구조로 나뉘기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>서버리스 모델은 확장과 비용을 자동으로 처리해 줍니다. 백엔드는 서버 관리 대신 핵심 로직에 집중할 수 있고, 프론트엔드는 정적 자산을 CDN에 올린 뒤 필요한 기능만 API로 호출하는 패턴을 손쉽게 실행할 수 있게 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2014-html5">
			<article class="event-detail" aria-labelledby="event-2014-html5-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2014</p>
					<h2 id="event-2014-html5-title">HTML5 최종 권고</h2>
					<p class="event-detail__summary">W3C는 HTML5를 최종 권고안으로 발표하며 “플러그인 없이도 비디오를 보고, 그림을 그리고, 데이터를 저장할 수 있다”는 새 기준을 세웠습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>2014년 10월 W3C는 “플러그인에 의존하지 말고 웹 자체 기능을 활용하세요”라며 HTML5 권고안을 발표했습니다. <code>&lt;video&gt;</code>, <code>&lt;canvas&gt;</code>, <code>localStorage</code> 같은 기능이 브라우저 기본 옵션이 되었습니다.</p>
						<p>워크숍에서는 HTML5 게임과 교육 콘텐츠 시연이 이어졌고, 기업들은 플래시를 걷어내기 위한 계획을 세우기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>HTML5는 웹을 운영체제처럼 활용할 수 있게 했습니다. 프론트엔드는 비디오, 그래픽, 오프라인 경험을 직접 구현하고, 백엔드는 스트리밍 API나 콘텐츠 보호 같은 인프라를 준비하게 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2014-spring-boot">
			<article class="event-detail" aria-labelledby="event-2014-spring-boot-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2014</p>
					<h2 id="event-2014-spring-boot-title">Spring Boot 1.0</h2>
					<p class="event-detail__summary">Spring Boot 1.0은 “설정 대신 실행”을 내세우며 스프링 백엔드를 몇 분 만에 띄울 수 있게 했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>2014년 Pivotal 개발자 필 웹은 무대에서 <code>spring init --dependencies=web demo</code>를 실행했습니다. IDE에서 <code>DemoApplication.java</code>를 열고 바로 실행하자 Tomcat이 내장된 애플리케이션이 5초 만에 떠올랐습니다.</p>
						<p>팀은 “설정 XML을 어디에 둬야 하지?” 같은 고민 대신 <code>application.properties</code>에 필요한 옵션만 적고 배포 파이프라인에 Jar 파일을 올렸습니다. 마이크로서비스 전환을 계획하던 조직은 “서비스 하나당 스프링 부트 하나”라는 전략을 채택했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Spring Boot는 자동 설정, 스타터 의존성, 내장 Tomcat/Jetty를 제공해 배포 단위를 Jar 파일로 단순화했습니다. 백엔드는 마이크로서비스와 CI/CD에 맞춰 작은 모듈을 빠르게 만들 수 있었고, 프론트엔드는 일관된 REST/GraphQL API를 더 쉽게 받을 수 있었습니다. 이 접근은 이후 Spring Cloud, Kubernetes 배포 모델과 자연스럽게 이어집니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2015-http2">
			<article class="event-detail" aria-labelledby="event-2015-http2-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2015</p>
					<h2 id="event-2015-http2-title">HTTP/2 표준 채택</h2>
					<p class="event-detail__summary">HTTP/2는 한 연결로 여러 파일을 동시에 보내고 헤더를 압축하면서 웹 성능 전략을 새로 짜게 만들었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>2015년 5월 IETF는 RFC 7540을 발표하며 “HTTP/1.1에서 줄 세워 기다리던 병목을 없애자”고 선언했습니다. 발표 직후 크롬과 파이어폭스는 업데이트를 내고 HTTP/2를 기본으로 켰습니다.</p>
						<p>트래픽이 많은 서비스는 “이미지 스프라이트나 도메인 샤딩을 억지로 하지 않아도 된다”며 HTTP/2로 옮겼습니다. 서버팀은 gRPC 같은 새 통신 방식을 시험했고, 프론트엔드는 번들 전략을 다시 짜며 코드 스플리팅에 집중했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>HTTP/2는 스트림 멀티플렉싱, 헤더 압축, 서버 푸시를 도입했습니다. 덕분에 한 연결에서 여러 리소스가 동시에 움직이고, 중복된 헤더도 줄었습니다. 이 변화는 나중에 HTTP/3와 QUIC으로 이어지며 웹 전송 방식을 더 빠르게 만들었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2015-graphql">
			<article class="event-detail" aria-labelledby="event-2015-graphql-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2015</p>
					<h2 id="event-2015-graphql-title">GraphQL 공개</h2>
					<p class="event-detail__summary">GraphQL은 필요한 데이터만 골라 받을 수 있는 질의 언어를 공개하며 REST와 다른 선택지를 보여 주었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>페이스북은 모바일 앱이 느린 네트워크에서도 필요한 정보만 가져오게 만들고 싶었습니다. 2015년 React 블로그 글에서 공개된 GraphQL은 스키마와 타입, 리졸버 같은 개념을 소개하며 “필요한 데이터를 직접 골라서 요청하세요”라고 설명했습니다.</p>
						<p>쇼핑몰과 뉴스 서비스는 한 화면에 꼭 필요한 정보만 빠르게 내려주자며 GraphQL 게이트웨이를 도입했습니다. 프론트엔드는 Apollo Client 같은 캐시 라이브러리를 활용했고, 백엔드는 여러 데이터 소스를 하나로 묶는 리졸버를 설계했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>GraphQL은 단일 엔드포인트와 타입 시스템으로 클라이언트가 필요한 필드를 명시합니다. REST보다 응답이 가볍다는 장점이 있지만, N+1 문제나 스키마 버전 관리처럼 새 숙제도 생겼습니다. 이후에는 페더레이션과 코드 퍼스트, 스키마 퍼스트 같은 전략이 등장해 GraphQL을 더 유연하게 만들었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2015-lets-encrypt">
			<article class="event-detail" aria-labelledby="event-2015-lets-encrypt-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2015</p>
					<h2 id="event-2015-lets-encrypt-title">Let’s Encrypt 런칭</h2>
					<p class="event-detail__summary">Let’s Encrypt는 무료로 자동 발급되는 인증서를 제공하며 “HTTPS는 기본”이라는 흐름을 빠르게 만들었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>2015년 12월 ISRG는 “자동화, 무료, 모두에게”라는 구호와 함께 Let’s Encrypt 베타를 열었습니다. <code>certbot</code> 스크립트를 실행하자 몇 초 만에 TLS 인증서가 발급되고 서버에 설치됐습니다.</p>
						<p>몇 달 뒤 브라우저는 HTTP 페이지에 “Not Secure” 경고를 붙였고, 호스팅 업체는 기본 옵션으로 HTTPS를 켜 주기 시작했습니다. 개발팀은 자동 갱신을 배포 파이프라인에 연결해 만료 걱정을 덜었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>HTTPS가 기본이 되자 프론트엔드는 서비스 워커, PWA, WebAuthn 같은 기능을 마음 놓고 사용할 수 있게 됐습니다. 백엔드는 TLS 자동화와 HSTS, CSP 설정을 살피며 보안을 운영의 필수 항목으로 다루게 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2016-pwa">
			<article class="event-detail" aria-labelledby="event-2016-pwa-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2016</p>
					<h2 id="event-2016-pwa-title">PWA 권장 아키텍처</h2>
					<p class="event-detail__summary">PWA 가이드는 웹앱도 오프라인 저장과 설치 아이콘을 갖추게 하며 “웹도 앱처럼 쓸 수 있다”는 기대를 만들었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Google I/O 2016에서 알렉스 러셀은 “웹도 오프라인에서 돌아가고 푸시 알림을 보낼 수 있습니다”라고 말하며 PWA 체크리스트를 공개했습니다. 발표 화면에서 트위터 라이트 아이콘이 홈 화면에 추가되자 관객이 환호했습니다.</p>
						<p>개발팀은 <code>serviceWorker.register()</code> 호출과 <code>manifest.json</code> 파일만으로 설치 가능한 웹앱을 만들었습니다. 여러 커머스 서비스는 PWA로 전환한 뒤 체류 시간과 재방문율이 올랐다고 발표했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>PWA는 서비스 워커, 오프라인 캐시, 푸시 알림을 묶어 브라우저가 앱 껍데기(앱 쉘)를 직접 관리하게 돕습니다. 백엔드는 백그라운드 동기화와 푸시 토큰을 맡아 모바일과 데스크톱을 잇는 경험을 뒷받침했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2017-webassembly">
			<article class="event-detail" aria-labelledby="event-2017-webassembly-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2017</p>
					<h2 id="event-2017-webassembly-title">WebAssembly MVP 완료</h2>
					<p class="event-detail__summary">WebAssembly는 브라우저가 C나 Rust 같은 언어도 빠르게 돌릴 수 있게 하며 “웹에서도 데스크톱 성능”을 기대하게 만들었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>2017년 3월 크롬, 파이어폭스, 사파리, 엣지 팀은 동시에 “오늘부터 WebAssembly가 기본으로 켜집니다”라는 글을 올렸습니다. 데모에서는 C++로 만든 게임이 브라우저에서 거의 네이티브 속도로 돌아갔습니다.</p>
						<p>핀테크와 CAD 업체는 계산이 많은 모듈을 옮겨 보고, 영상 편집 스타트업은 WebAssembly 프로토타입을 공개했습니다. 프론트엔드는 자바스크립트와 WebAssembly 모듈을 함께 묶는 전략을 실험했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>WebAssembly는 가벼운 이진 포맷과 샌드박스 실행을 제공해 백엔드에서 쓰던 언어를 브라우저에서 활용하게 해 줍니다. 백엔드는 CPU가 많이 드는 기능을 사용자의 장치로 넘기거나, 필요한 데이터만 전달하는 구조를 설계하며 작업 부하를 조정했습니다. 이후 WASI와 서버 측 WebAssembly가 등장하며 영역이 더 넓어졌습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2017-cloudflare-workers">
			<article class="event-detail" aria-labelledby="event-2017-cloudflare-workers-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2017</p>
					<h2 id="event-2017-cloudflare-workers-title">Cloudflare Workers 출시</h2>
					<p class="event-detail__summary">Cloudflare Workers는 전 세계 엣지에서 코드를 돌리게 하며 “사용자에게 몇 밀리초 더 가까이” 다가가는 시대를 열었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Cloudflare는 2017년 “코드를 사용자에게 10ms 안쪽으로 가져오세요”라는 말과 함께 Workers 베타를 공개했습니다. 개발자는 몇 줄의 자바스크립트를 배포해 A/B 테스트나 이미지 변환을 엣지에서 처리했습니다.</p>
						<p>곧이어 Vercel과 Netlify도 비슷한 엣지 함수 플랫폼을 선보였고, 제품팀은 정적 배포 위에 엣지와 서버리스를 얹는 구성을 기본 전략으로 삼았습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>엣지 런타임 덕분에 백엔드는 중앙 데이터베이스와 API는 유지하면서도 지연이 민감한 로직을 사용자 가까이 분산했습니다. 프론트엔드는 엣지 미들웨어로 맞춤 렌더링, 인증, 국제화를 빠르게 처리했습니다. 이는 서버리스와 JAMstack 흐름을 더 유연하게 만들었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2020-jamstack">
			<article class="event-detail" aria-labelledby="event-2020-jamstack-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2020</p>
					<h2 id="event-2020-jamstack-title">JAMstack와 엣지 함수 확산</h2>
					<p class="event-detail__summary">JAMstack은 정적 빌드와 API, 엣지 함수를 묶어 “프론트는 빠르게, 백엔드는 필요할 때 호출”이라는 방식을 일상으로 만들었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>제품팀은 Netlify나 Vercel을 저장소에 연결하고 “main에 머지하면 곧바로 배포됩니다”라는 알림을 받았습니다. 프론트엔드는 정적 파일로 빌드되어 CDN에 퍼지고, 필요한 데이터는 API나 서버리스 함수에서 그때그때 불러 왔습니다.</p>
						<p>엣지 함수가 더해지면서 개발자는 사용자 위치나 언어에 맞춰 콘텐츠를 바꾸는 작업을 코드 몇 줄로 끝냈습니다. 마케팅팀은 “서울에는 이 배너, 뉴욕에는 저 배너”처럼 실험을 빠르게 돌릴 수 있었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>JAMstack은 JavaScript, API, Markup 조합을 강조해 프론트와 백엔드를 각자 배포하는 방식을 일반화했습니다. 백엔드는 인증과 데이터를 API로 제공하고, 프론트엔드는 정적 자산과 런타임 로직을 맡아 빠른 배포와 확장성을 얻었습니다. 이 흐름은 마이크로서비스, 엣지 컴퓨팅, 서버리스 워크플로로 자연스럽게 이어졌습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<script src="assets/js/main.js" defer></script>
	</body>
</html>
