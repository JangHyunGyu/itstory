<!DOCTYPE html>
<html lang="ko">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>ArcherLab IT Story · 웹이 층을 나눈 이유</title>
		<meta name="description" content="정적 문서에서 CGI, Ajax, SPA, 서버리스까지. 웹이 프론트엔드와 백엔드로 나뉘고 다시 협력하게 된 순간을 타임라인으로 살펴봅니다." />
		<meta property="og:title" content="ArcherLab IT Story · Web Layers Timeline" />
		<meta property="og:description" content="WWW 제안부터 서버리스까지, 웹이 정적 문서에서 앱 플랫폼으로 성장한 과정을 읽어 보세요." />
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700;800&family=Space+Grotesk:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500;600&display=swap" rel="stylesheet">
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css">
		<link rel="stylesheet" href="assets/css/style.css">
	</head>
	<body>
		<div class="page">
			<header class="page__header" role="banner">
				<div class="page__header-left">
					<a class="page__brand" href="https://archerlab.dev" target="_blank" rel="noopener">
						<img src="assets/images/archerlab_mini_logo.png" alt="ArcherLab" class="page__brand-logo" loading="lazy">
						<span class="page__brand-label">ArcherLab Chronicle</span>
					</a>
					<nav class="page__topic-nav" aria-label="주제 전환">
						<a href="index.html">홈 허브</a>
						<a href="networks.html">네트워크 연대기</a>
						<a href="computers.html">컴퓨터 연대기</a>
						<a href="web.html" class="is-current">웹 연대기</a>
						<a href="databases.html">데이터베이스 연대기</a>
					</nav>
				</div>
				<nav class="page__nav" aria-label="섹션 탐색">
					<a href="#timeline">연도 보기</a>
					<a href="#sources">참고</a>
				</nav>
			</header>

			<main class="page__main" id="main" role="main">
				<section class="timeline-hero" aria-labelledby="timeline-title">
					<div class="timeline-hero__head">
						<p class="hero__eyebrow">Web Story for Product Builders</p>
						<h1 class="timeline-hero__title" id="timeline-title">정적 문서에서 API와 서버리스까지, 웹이 달라진 순간을 따라가 보세요</h1>
						<p class="timeline-hero__lede">
							연구소에서 문서를 공유하던 시절부터 지금의 글로벌 제품팀까지. 웹은 단순히 파일을 보여 주는 공간에서 애플리케이션을 돌리는 무대로 자라났고, 그 과정에서 프론트엔드와 백엔드가 나뉘었습니다.
						</p>
						<p class="timeline-hero__lede">
							연도 버튼을 눌러 보세요. 정적 페이지, CGI, Ajax, SPA, 서버리스 같은 흐름이 어떻게 등장했는지, 그리고 다음 세대 개발 방식을 어떻게 바꿨는지 한눈에 볼 수 있습니다.
						</p>
					</div>
				</section>

				<section class="timeline-grid" id="timeline" aria-labelledby="timeline-title" aria-describedby="timeline-instructions">
					<p class="timeline-grid__instructions sr-only" id="timeline-instructions">연도 버튼을 누르면 새 창 없이 팝업 대화 상자가 열리고, 그 자리에서 자세한 이야기를 이어서 읽을 수 있습니다.</p>

					<section class="timeline-group" aria-labelledby="decade-1960 topic-1960">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1960">1968–1986</p>
							<h3 class="timeline-group__topic" id="topic-1960">웹을 가능하게 한 토대</h3>
							<p class="timeline-group__summary">하이퍼텍스트 시연과 ARPANET, TCP/IP, DNS, SGML 같은 기초 기술이 나오면서 지금의 웹을 떠받치는 기본 아이디어가 자리 잡았습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1968-mother-demo">
								<span class="timeline-event__year">1968</span>
								<span class="timeline-event__label">Mother of All Demos</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1969-arpanet">
								<span class="timeline-event__year">1969</span>
								<span class="timeline-event__label">ARPANET 최초 연결</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1974-tcpip">
								<span class="timeline-event__year">1974</span>
								<span class="timeline-event__label">TCP/IP 설계</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1978-usenet">
								<span class="timeline-event__year">1978</span>
								<span class="timeline-event__label">Usenet 개시</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1980-enquire">
								<span class="timeline-event__year">1980</span>
								<span class="timeline-event__label">ENQUIRE 구축</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1983-flag-day">
								<span class="timeline-event__year">1983</span>
								<span class="timeline-event__label">TCP/IP 전환일</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1984-dns">
								<span class="timeline-event__year">1984</span>
								<span class="timeline-event__label">DNS 도입</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1986-sgml">
								<span class="timeline-event__year">1986</span>
								<span class="timeline-event__label">ISO SGML 표준</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-1990 topic-1990">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1990">1990–1993</p>
							<h3 class="timeline-group__topic" id="topic-1990">정적 문서를 연결한 첫 웹</h3>
							<p class="timeline-group__summary">WWW 제안과 최초의 브라우저·서버 구현이 등장하며 "파일을 요청하고 보여 주는" 정적 구조가 자리 잡았습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1990-www-proposal">
								<span class="timeline-event__year">1990</span>
								<span class="timeline-event__label">WWW 제안</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1991-first-site">
								<span class="timeline-event__year">1991</span>
								<span class="timeline-event__label">첫 웹사이트 공개</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1993-mosaic">
								<span class="timeline-event__year">1993</span>
								<span class="timeline-event__label">Mosaic 공개</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-1990-dynamic topic-1990-dynamic">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1990-dynamic">1993–1997</p>
							<h3 class="timeline-group__topic" id="topic-1990-dynamic">서버가 문서를 만들어 주기 시작하다</h3>
							<p class="timeline-group__summary">CGI와 JavaScript, PHP, CSS, ASP가 자리 잡으며 서버는 맞춤 HTML을 만들고 브라우저는 즉각적인 상호작용과 표현을 담당하기 시작했습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1993-cgi">
								<span class="timeline-event__year">1993</span>
								<span class="timeline-event__label">CGI 표준화</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1995-javascript">
								<span class="timeline-event__year">1995</span>
								<span class="timeline-event__label">JavaScript 탄생</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1995-php">
								<span class="timeline-event__year">1995</span>
								<span class="timeline-event__label">PHP 도구</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1996-css">
								<span class="timeline-event__year">1996</span>
								<span class="timeline-event__label">CSS 레벨 1 권고안</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1996-asp">
								<span class="timeline-event__year">1996</span>
								<span class="timeline-event__label">Active Server Pages</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-2000 topic-2000">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-2000">1998–2008</p>
							<h3 class="timeline-group__topic" id="topic-2000">브라우저가 움직임을 맡다</h3>
							<p class="timeline-group__summary">HTTP/1.1, XMLHttpRequest, LAMP, Ajax, Chrome/V8이 맞물리며 프론트엔드는 비동기 상호작용과 성능을, 백엔드는 표준화된 서버 구성을 맡았고, 모바일 기기가 새로운 요구를 던졌습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1999-http11">
								<span class="timeline-event__year">1999</span>
								<span class="timeline-event__label">HTTP/1.1 정식화</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1999-xmlhttprequest">
								<span class="timeline-event__year">1999</span>
								<span class="timeline-event__label">XMLHttpRequest 등장</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2001-lamp">
								<span class="timeline-event__year">2001</span>
								<span class="timeline-event__label">LAMP 스택 확산</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2005-ajax">
								<span class="timeline-event__year">2005</span>
								<span class="timeline-event__label">Ajax 패턴 확산</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2007-mobile-web">
								<span class="timeline-event__year">2007</span>
								<span class="timeline-event__label">모바일 웹 전환점</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2008-chrome">
								<span class="timeline-event__year">2008</span>
								<span class="timeline-event__label">Chrome &amp; V8 공개</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-2010 topic-2010">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-2010">2009–2016</p>
							<h3 class="timeline-group__topic" id="topic-2010">브라우저가 애플리케이션이 되다</h3>
							<p class="timeline-group__summary">Node.js, SPA 프레임워크, WebSocket이 등장하며 프론트엔드가 애플리케이션 전체를 직접 다루고, 백엔드는 실시간 API 제공자로 역할이 재정의되었습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="2009-node">
								<span class="timeline-event__year">2009</span>
								<span class="timeline-event__label">Node.js 발표</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2010-angularjs">
								<span class="timeline-event__year">2010</span>
								<span class="timeline-event__label">AngularJS 공개</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2011-websocket">
								<span class="timeline-event__year">2011</span>
								<span class="timeline-event__label">WebSocket 표준 확정</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2013-react">
								<span class="timeline-event__year">2013</span>
								<span class="timeline-event__label">React 발표</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-2020 topic-2020">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-2020">2014–2025</p>
							<h3 class="timeline-group__topic" id="topic-2020">API와 서버리스로 재조합</h3>
							<p class="timeline-group__summary">HTML5, Lambda, HTTP/2, GraphQL, PWA, HTTPS 자동화, WebAssembly, 엣지 런타임, JAMstack이 이어지며 백엔드는 API와 이벤트를, 프론트는 독립 배포와 조합을 맡는 구조가 완성되었습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="2014-lambda">
								<span class="timeline-event__year">2014</span>
								<span class="timeline-event__label">AWS Lambda 출시</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2014-html5">
								<span class="timeline-event__year">2014</span>
								<span class="timeline-event__label">HTML5 최종 권고</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2015-http2">
								<span class="timeline-event__year">2015</span>
								<span class="timeline-event__label">HTTP/2 표준 채택</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2015-graphql">
								<span class="timeline-event__year">2015</span>
								<span class="timeline-event__label">GraphQL 공개</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2015-lets-encrypt">
								<span class="timeline-event__year">2015</span>
								<span class="timeline-event__label">Let’s Encrypt 런칭</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2016-pwa">
								<span class="timeline-event__year">2016</span>
								<span class="timeline-event__label">PWA 권장 아키텍처</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2017-webassembly">
								<span class="timeline-event__year">2017</span>
								<span class="timeline-event__label">WebAssembly MVP 완료</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2017-cloudflare-workers">
								<span class="timeline-event__year">2017</span>
								<span class="timeline-event__label">Cloudflare Workers</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2020-jamstack">
								<span class="timeline-event__year">2020</span>
								<span class="timeline-event__label">JAMstack/엣지 확산</span>
							</button>
						</div>
					</section>
				</section>

				<section class="sources" id="sources" aria-labelledby="sources-title">
					<div class="section__head">
						<h2 id="sources-title">참고 자료</h2>
						<p>웹의 구조가 정적 문서에서 애플리케이션 플랫폼으로 바뀐 과정을 기록한 1차 자료와 회고를 모았습니다. 원문을 읽어 보면 각 시대의 개발자들이 어떤 문제를 해결하려 했는지 더 선명합니다.</p>
					</div>
					<ul class="source-list">
						<li><a href="https://dougengelbart.org/content/view/209/448/" target="_blank" rel="noopener">Doug Engelbart Institute · The Mother of All Demos</a></li>
						<li><a href="https://www.netlab.cs.ucla.edu/papers/UCLA_Internet_1969.pdf" target="_blank" rel="noopener">UCLA · Birth of the ARPANET</a></li>
						<li><a href="https://www.rfc-editor.org/rfc/rfc675" target="_blank" rel="noopener">IETF · RFC 675: Specification of Internet Transmission Control Program</a></li>
						<li><a href="https://www.cs.unc.edu/~barman/usenet/" target="_blank" rel="noopener">Usenet Historical Documents · A Brief History of Usenet</a></li>
						<li><a href="https://www.w3.org/History/1980/EnquireFrame.html" target="_blank" rel="noopener">W3C History · ENQUIRE Manual</a></li>
						<li><a href="https://www.livinginternet.com/i/ii_arpanet_flagday.htm" target="_blank" rel="noopener">Living Internet · ARPANET Flag Day</a></li>
						<li><a href="https://www.rfc-editor.org/rfc/rfc1034" target="_blank" rel="noopener">IETF · RFC 1034: Domain Names - Concepts and Facilities</a></li>
						<li><a href="https://www.iso.org/standard/16387.html" target="_blank" rel="noopener">ISO · ISO 8879:1986 Standard Generalized Markup Language</a></li>
						<li><a href="https://www.w3.org/Proposal.html" target="_blank" rel="noopener">Tim Berners-Lee · Information Management: A Proposal</a></li>
						<li><a href="https://www.w3.org/History/19921103-hypertext/hypertext/WWW/TheProject.html" target="_blank" rel="noopener">CERN · World Wide Web Project</a></li>
						<li><a href="https://www.rfc-editor.org/rfc/rfc3875" target="_blank" rel="noopener">NCSA · Common Gateway Interface Specification</a></li>
						<li><a href="https://www.w3.org/TR/CSS1/" target="_blank" rel="noopener">W3C · Cascading Style Sheets Level 1</a></li>
						<li><a href="https://queue.acm.org/detail.cfm?id=1117401" target="_blank" rel="noopener">ACM Queue · Ajax: A New Approach to Web Applications</a></li>
						<li><a href="https://www.rfc-editor.org/rfc/rfc2616" target="_blank" rel="noopener">IETF · RFC 2616: Hypertext Transfer Protocol 1.1</a></li>
						<li><a href="https://www.apple.com/newsroom/2007/01/09Apple-Reinvents-the-Phone-with-iPhone/" target="_blank" rel="noopener">Apple Newsroom · Apple Reinvents the Phone with iPhone</a></li>
						<li><a href="https://www.rfc-editor.org/rfc/rfc6455" target="_blank" rel="noopener">IETF · RFC 6455: The WebSocket Protocol</a></li>
						<li><a href="https://www.rfc-editor.org/rfc/rfc7540" target="_blank" rel="noopener">IETF · RFC 7540: Hypertext Transfer Protocol 2</a></li>
						<li><a href="https://blog.chromium.org/2008/09/google-chrome-now-available-in-beta.html" target="_blank" rel="noopener">Chromium Blog · Google Chrome Beta Announcement</a></li>
						<li><a href="https://www.w3.org/blog/news/archives/4167" target="_blank" rel="noopener">W3C News · HTML5 Is a W3C Recommendation</a></li>
						<li><a href="https://letsencrypt.org/2015/12/03/launching-lets-encrypt.html" target="_blank" rel="noopener">ISRG · Launching Let’s Encrypt</a></li>
						<li><a href="https://developers.google.com/web/progressive-web-apps" target="_blank" rel="noopener">Google Developers · Progressive Web Apps Guide</a></li>
						<li><a href="https://webassembly.org/news/announcing-the-webassembly-mvp/" target="_blank" rel="noopener">WebAssembly.org · Announcing the WebAssembly MVP</a></li>
						<li><a href="https://blog.cloudflare.com/introducing-cloudflare-workers/" target="_blank" rel="noopener">Cloudflare Blog · Introducing Cloudflare Workers</a></li>
						<li><a href="https://aws.amazon.com/blogs/aws/aws-lambda-event-driven-code-in-the-cloud/" target="_blank" rel="noopener">AWS News Blog · AWS Lambda Announcement</a></li>
						<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript" target="_blank" rel="noopener">MDN · A re-introduction to JavaScript</a></li>
						<li><a href="https://nodejs.org/en/about" target="_blank" rel="noopener">Node.js Foundation · About Node.js</a></li>
						<li><a href="https://engineering.fb.com/2015/09/14/core-data/graphql-a-data-query-language/" target="_blank" rel="noopener">Meta Engineering · GraphQL: A Data Query Language</a></li>
					</ul>
				</section>
			</main>

			<footer class="page__footer" role="contentinfo">
				<p>© 2025 ArcherLab · Stories on how the web split and reunited.</p>
				<a class="page__footer-link" href="https://archerlab.dev" target="_blank" rel="noopener">archerlab.dev</a>
			</footer>
		</div>

		<div class="modal" id="event-modal" role="dialog" aria-modal="true" hidden>
			<div class="modal__overlay" data-modal-close></div>
			<div class="modal__window" role="document" tabindex="-1">
				<button class="modal__close" type="button" aria-label="레이어 닫기" data-modal-close>&times;</button>
				<div class="modal__content"></div>
			</div>
		</div>

		<template id="event-1968-mother-demo">
			<article class="event-detail" aria-labelledby="event-1968-mother-demo-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1968</p>
					<h2 id="event-1968-mother-demo-title">Mother of All Demos</h2>
					<p class="event-detail__summary">더글러스 엥겔바트가 마우스와 하이퍼텍스트, 원격 협업을 한 번에 보여 주며 링크된 작업 공간의 모습을 처음 소개했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>샌프란시스코 컨벤션 센터. 엥겔바트는 작은 나무 상자 모양의 마우스를 움직이며 “이 버튼을 누르면 다른 문서로 이동합니다.”라고 말했습니다. 화면에는 텍스트가 강조되고 새 창이 열렸으며, 멀리 있는 동료와 화면을 나눠 쓰는 장면도 이어졌습니다.</p>
						<p>관객은 전화 회선을 타고 움직이는 커서와 링크, 실시간 회의를 보고 놀랐습니다. 이 데모 덕분에 “문서가 연결되고 떨어져 있어도 함께 작업한다”는 그림이 현실처럼 느껴졌습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>이 시연은 <strong>하이퍼텍스트</strong>, <strong>입력 장치</strong>, <strong>협업</strong>이라는 핵심 아이디어를 한 자리에서 보여 줬습니다. 나중에 프론트엔드는 링크를 따라 탐색하는 UI를 기본으로 삼게 되었고, 백엔드는 여러 사람이 공유하는 데이터를 보관하고 맞춰 주는 역할로 커졌습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1969-arpanet">
			<article class="event-detail" aria-labelledby="event-1969-arpanet-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1969</p>
					<h2 id="event-1969-arpanet-title">ARPANET 최초 연결</h2>
					<p class="event-detail__summary">캘리포니아에서 스탠퍼드로 ‘LO’ 두 글자가 전송되면서 패킷 스위칭 네트워크가 실제로 동작하기 시작했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>UCLA 연구자는 “LOGIN을 보내 볼게요.”라며 키보드를 쳤습니다. 세 번째 글자를 입력하기도 전에 연결이 끊겼지만, 화면에 ‘LO’가 찍힌 순간 모두가 환호했습니다. “다른 컴퓨터와 직접 통신했다!”</p>
						<p>몇 주 뒤 네트워크는 유타와 산타바바라까지 이어졌고, 대학과 연구소는 서로의 컴퓨터 자원을 빌려 쓰며 함께 실험하기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>ARPANET은 패킷을 나눠 보내고 여러 노드를 거치게 설계했습니다. 덕분에 일부 서버가 끊겨도 전체 네트워크가 유지될 수 있다는 사실이 증명됐습니다. 나중에 전 세계에 흩어진 웹 서버가 하나의 서비스처럼 느껴지는 것도 이 발상 덕분입니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1974-tcpip">
			<article class="event-detail" aria-labelledby="event-1974-tcpip-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1974</p>
					<h2 id="event-1974-tcpip-title">TCP/IP 설계</h2>
					<p class="event-detail__summary">빈튼 서프와 밥 칸이 네트워크끼리 연결되는 방법을 정리한 논문을 발표하며 오늘날 인터넷 계층 모델을 만들었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>두 사람은 “서로 다른 네트워크라도 같은 규칙만 지키면 끊김 없이 데이터를 주고받을 수 있다.”고 설명했습니다. TCP는 데이터를 순서대로 보내고, IP는 주소를 붙여 경로를 찾게 하는 구조였습니다.</p>
						<p>군사와 학계 프로젝트는 곧 이 설계를 시험했고, 1970년대 후반에는 여러 장비가 TCP/IP를 지원하기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>TCP/IP는 기능을 층층이 나눈 구조입니다. 나중에 HTTP와 HTML이 이 위에서 자유롭게 움직일 수 있었던 이유가 바로 여기에 있습니다. 백엔드는 IP 위에서 서버를 운영하고, 프론트엔드는 TCP 연결을 통해 안정적으로 콘텐츠를 받아올 수 있게 됐습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1978-usenet">
			<article class="event-detail" aria-labelledby="event-1978-usenet-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1978</p>
					<h2 id="event-1978-usenet-title">Usenet 개시</h2>
					<p class="event-detail__summary">두 대학이 전화선으로 게시판 메시지를 주고받으며 서버끼리 협력하는 모델을 시험했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>듀크 대학의 짐과 톰은 밤마다 UUCP를 돌려 다른 학교 컴퓨터와 메시지를 교환했습니다. “자고 일어나면 새 글이 다 복사되어 있네요!”라며 <code>net.general</code> 그룹에 첫 글을 남겼습니다.</p>
						<p>곧 여러 기관이 참여했고, 서버는 메시지를 모아 전달하고, 사용자는 자신의 단말에서 글을 읽고 답장을 쓰는 구조가 만들어졌습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Usenet은 서버가 메시지를 저장했다가 다른 서버로 넘겨주는 <strong>스토어-앤드-포워드</strong> 방식을 썼습니다. 서버는 백엔드처럼 데이터를 맡고, 사용자는 자신의 컴퓨터에서 글을 읽고 쓰는 프론트엔드 역할을 했습니다. 훗날 웹 서비스의 기본 분업과 닮았습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1980-enquire">
			<article class="event-detail" aria-labelledby="event-1980-enquire-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1980</p>
					<h2 id="event-1980-enquire-title">ENQUIRE 구축</h2>
					<p class="event-detail__summary">팀 버너스-리가 CERN 실험 정보를 연결하는 개인 하이퍼텍스트 도구를 만들며 웹 설계의 씨앗을 심었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>버너스-리는 “연구 장비와 담당자를 한눈에 보고 싶다.”는 고민 끝에 ENQUIRE라는 프로그램을 만들었습니다. 문서를 질문과 답 형식으로 묶고, 링크를 눌러 관련 내용을 차례대로 살필 수 있었습니다.</p>
						<p>그는 “문서가 서로 연결돼야 기억하기 쉽다.”고 적어 두었고, 훗날 WWW 제안서에서 이 구조가 더 크게 발전합니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>ENQUIRE는 <strong>노드와 링크</strong>, <strong>메타데이터</strong>를 다루는 실험장이었습니다. 프론트엔드는 사용자가 원하는 정보를 맥락과 함께 보여 주고, 백엔드는 문서 사이의 연결을 저장하는 저장소가 되어야 한다는 생각이 구체화됐습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1983-flag-day">
			<article class="event-detail" aria-labelledby="event-1983-flag-day-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1983</p>
					<h2 id="event-1983-flag-day-title">TCP/IP 전환일</h2>
					<p class="event-detail__summary">1983년 1월 1일, ARPANET이 TCP/IP로 일괄 전환하며 인터넷의 공통 언어가 정해졌습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>미 국방성은 “새해 첫날부터 TCP/IP를 사용하세요.”라는 공문을 보냈습니다. 운영자들은 밤새 코드를 바꿨고, 1월 1일 아침 네트워크는 새 프로토콜로 정상 작동했습니다.</p>
						<p>다른 연구망과 상업 네트워크도 곧 동일한 표준을 채택했고, 전 세계가 하나의 인터넷으로 묶이기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>이 전환 덕분에 어떤 시스템이라도 TCP/IP만 쓰면 서로 통신할 수 있게 됐습니다. 백엔드는 TCP/IP 스택 위에서 서버를 운영하고, 프론트엔드는 표준 주소를 이용해 어느 서버와도 연결을 시도할 수 있게 된 것입니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1984-dns">
			<article class="event-detail" aria-labelledby="event-1984-dns-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1984</p>
					<h2 id="event-1984-dns-title">DNS 도입</h2>
					<p class="event-detail__summary">도메인 이름 시스템이 등장하면서 사람이 읽기 쉬운 주소와 계층 구조가 자리 잡았습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>폴 모카페트리스는 “호스트 목록을 수동으로 배포하는 방식은 한계가 있다.”라며 DNS 구조를 제안했습니다. 루트 서버가 질문을 받고, 권한 있는 네임서버가 차례로 응답하는 방식이었고, <code>.com</code>, <code>.edu</code> 같은 최상위 도메인이 만들어졌습니다.</p>
						<p>운영자는 새 서버를 등록할 때 IP 대신 도메인 이름을 적었습니다. 사용자는 기억하기 쉬운 이름으로 원격 자원에 접속할 수 있게 되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>DNS 덕분에 URL과 URI 개념이 생겨날 수 있었습니다. 백엔드는 도메인 이름으로 서비스를 공개하고, 프론트엔드는 기억하기 쉬운 주소를 하이퍼링크에 그대로 쓸 수 있게 됐습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1986-sgml">
			<article class="event-detail" aria-labelledby="event-1986-sgml-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1986</p>
					<h2 id="event-1986-sgml-title">ISO SGML 표준</h2>
					<p class="event-detail__summary">SGML이 국제 표준으로 채택되면서 문서를 태그로 나누는 방식이 정리되었고, HTML의 뿌리가 되었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>ISO는 SGML(ISO 8879)을 승인하며 “문서는 텍스트와 구조를 나눠서 표현하자.”고 선언했습니다. 출판사와 정부 기관은 표준 태그 세트를 써서 문서를 교환했습니다.</p>
						<p>개발자들은 태그 기반 문서가 다른 시스템에서도 뜻을 유지하는 모습을 보며, 플랫폼에 묶이지 않는 표현 방식이 필요하다는 점을 깨달았습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>SGML은 HTML과 XML의 생각을 빚었습니다. 프론트엔드는 구조화된 마크업을 화면에 그리는 역할을 맡고, 백엔드는 태그를 만들어 내거나 변환하며 데이터를 다루는 역할을 맡는 틀이 만들어졌습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1990-www-proposal">
			<article class="event-detail" aria-labelledby="event-1990-www-proposal-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1990</p>
					<h2 id="event-1990-www-proposal-title">WWW 제안 · 팀 버너스-리</h2>
					<p class="event-detail__summary">CERN 연구원들이 “문서를 공유하기가 너무 불편하다.”고 말하자, 팀 버너스-리가 하이퍼텍스트와 인터넷을 엮은 제안을 작성했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>팀은 “Information Management: A Proposal”이라는 제목을 노트북에 적었습니다. “링크라는 개념을 쓰면 문서끼리 서로를 가리킬 수 있어요.” 동료가 “주소는 어떻게 만들죠?”라고 묻자 종이에 <code>http://</code>를 적어 보이며 “서버가 파일을 찾아 보내고, 브라우저가 화면에 보여 주면 됩니다.”라고 설명했습니다.</p>
						<p>관리자는 시험용 NeXT 컴퓨터를 내주었고, 팀은 HTML, HTTP, 첫 웹서버(CERN httpd)를 직접 만들었습니다. 연구자들은 “메일 첨부 대신 링크를 공유하면 되겠네.”라며 새 방식을 시험했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>제안서 핵심은 <strong>URI</strong>, <strong>HTTP</strong>, <strong>HTML</strong> 세 가지였습니다. 파일을 요청하는 방법, 문서를 표현하는 언어, 문서를 찾는 주소 체계를 한꺼번에 정리하면서 누구나 서버에 파일을 올리고 같은 브라우저로 읽을 수 있는 정적 웹이 탄생했습니다. 이때 서버는 파일을 그대로 돌려주기만 했고, 프론트엔드와 백엔드 구분은 아직 필요하지 않았습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1991-first-site">
			<article class="event-detail" aria-labelledby="event-1991-first-site-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1991</p>
					<h2 id="event-1991-first-site-title">첫 웹사이트 공개</h2>
					<p class="event-detail__summary">“웹페이지를 만들고 싶다면 이렇게 하세요.”라는 안내문이 세계 최초의 웹페이지였습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>1991년 8월, 팀 버너스-리는 CERN의 NeXT 서버에 <code>info.cern.ch</code>라는 주소를 만들고 “World Wide Web Project” 페이지를 공개했습니다. 검은 글자와 파란 링크뿐인 단순한 페이지였지만, “HTML 태그를 이렇게 쓰면 새 문서를 만들 수 있습니다.”라는 설명과 샘플 코드가 담겨 있었습니다.</p>
						<p>전화 회선으로 접속한 연구자들은 텍스트 브라우저에서 링크를 눌러 보며 “화살표 키로 문서 사이를 오갈 수 있네.”라고 말했습니다. 곧 다른 연구실도 같은 지침을 따라 웹서버를 설치하기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>첫 웹페이지는 튜토리얼과 표준 문서를 겸했습니다. 서버 설정, HTML 태그 목록, 링크 만드는 방법을 한 페이지에서 볼 수 있었기 때문에 매뉴얼만 읽을 줄 알면 누구나 따라 할 수 있는 열린 시스템으로 자리 잡았습니다. 서버는 여전히 디스크에 있는 파일을 그대로 전송했고, 브라우저는 그 내용을 화면에 보여 줬습니다. 이 단순함 덕분에 웹은 빠르게 퍼졌습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1993-mosaic">
			<article class="event-detail" aria-labelledby="event-1993-mosaic-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1993</p>
					<h2 id="event-1993-mosaic-title">Mosaic 브라우저 공개</h2>
					<p class="event-detail__summary">그래픽 UI를 갖춘 Mosaic이 나오자 연구소 밖 사용자도 처음으로 “링크를 클릭하는 경험”을 하게 됐습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>NCSA 학생들은 그래픽 버튼과 이미지를 보여 주며 “직접 클릭해 보세요.”라고 관객에게 마우스를 건넸습니다. 파란색 링크를 클릭하자 같은 창에서 다른 문서가 열렸고, 사람들은 “정말 바로 넘어가네!”라고 말했습니다.</p>
						<p>신문 기자는 “웹이란 게 이렇게 생겼나요?”라며 Mosaic 화면을 사진으로 실었습니다. 곧 대학과 기업도 Mosaic을 설치해 정적 페이지를 올리기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Mosaic은 이미지와 텍스트를 한 화면에 보여 주고, 마우스 중심 UI와 북마크를 제공하며 웹을 대중에게 알렸습니다. 하지만 서버는 여전히 정적 파일만 전달했습니다. 프론트엔드는 HTML을 그려 주는 역할에 머물렀고, 맞춤형 콘텐츠를 만들려면 새로운 방법이 필요하다는 생각이 퍼지기 시작했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1993-cgi">
			<article class="event-detail" aria-labelledby="event-1993-cgi-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1993</p>
					<h2 id="event-1993-cgi-title">CGI 표준화</h2>
					<p class="event-detail__summary">서버가 외부 프로그램을 실행해 HTML을 만들어 줄 수 있는 규칙이 만들어지면서 “백엔드 로직”이라는 개념이 생겼습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>NCSA httpd 팀은 “게스트북 글을 저장하고 바로 보여 줄 수 없을까?”라는 요청을 받았습니다. 개발자 수지는 “요청이 오면 Perl 스크립트를 실행해서 HTML을 만들어 돌려주죠.”라고 제안했습니다.</p>
						<p>이 아이디어가 Common Gateway Interface, 즉 CGI였습니다. 사용자가 폼을 보내면 서버가 스크립트를 돌려 데이터베이스에 기록하고, 결과를 HTML로 출력했습니다. 연구자들은 “이제 프로그램이 HTML을 만들어 준다!”며 놀랐습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>CGI는 환경 변수와 표준 입출력으로 서버와 프로그램이 데이터를 주고받는 규칙을 정했습니다. 덕분에 서버는 사람마다 다른 HTML을 만들 수 있게 되었고, 프론트엔드와 다른 서버측 로직, 즉 백엔드라는 개념이 싹텄습니다. 다만 요청마다 새 프로세스를 띄워야 해서 성능 부담은 컸습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1995-javascript">
			<article class="event-detail" aria-labelledby="event-1995-javascript-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1995</p>
					<h2 id="event-1995-javascript-title">JavaScript 탄생</h2>
					<p class="event-detail__summary">브라우저가 문서를 보여 주는 것에서 더 나아가 상호작용을 맡을 수 있도록 전용 스크립트 언어가 탄생했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Netscape 개발자 브렌던 아이크는 “버튼을 눌렀다가 서버로 다녀오는 시간이 너무 길다.”는 불만을 듣고 10일 만에 새 스크립트 언어를 만들었습니다. 처음엔 “LiveScript”로 불렸지만, 곧 “JavaScript”라는 이름이 붙었습니다.</p>
						<p>시연에서 개발자들은 “이름을 입력하자 인사말이 바로 바뀌네?”라며 감탄했습니다. 즉시 검증, 이미지 교체 같은 상호작용이 가능해지면서 프론트엔드는 더 이상 HTML만 보여 주는 역할에 머물지 않게 됐습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>JavaScript는 브라우저 안에서 돌아가는 가벼운 언어였습니다. <strong>이벤트 루프</strong>와 <strong>DOM 조작</strong> 개념을 소개하면서 프론트엔드도 본격적인 프로그래밍 영역이 되었습니다. 서버가 모든 일을 하던 시절에서 벗어나 브라우저가 즉각적인 반응을 담당하고, 백엔드는 데이터와 비즈니스 로직에 집중하는 흐름이 만들어졌습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1995-php">
			<article class="event-detail" aria-labelledby="event-1995-php-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1995</p>
					<h2 id="event-1995-php-title">PHP 도구의 공개</h2>
					<p class="event-detail__summary">라스무스 러도프가 HTML 안에 코드를 섞어 넣을 수 있는 도구를 공개하면서 웹페이지를 쉽게 동적으로 만들 수 있게 됐습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>라스무스는 개인 홈페이지 방문 통계를 위해 Perl 스크립트를 썼지만 관리가 번거로웠습니다. 그래서 HTML에 <code>&lt;?php&nbsp;?&gt;</code> 같은 코드를 바로 넣어 데이터베이스에 연결하고 결과를 출력하는 방식을 만들었습니다. “폼 검증이 한 줄로 끝나요!”라는 글이 커뮤니티에 쏟아졌습니다.</p>
						<p>웹마스터들은 PHP로 게시판과 쇼핑몰을 만들었고, 서버는 요청마다 PHP 인터프리터를 실행해 HTML을 즉석에서 만들었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>PHP는 템플릿과 로직을 한 파일에 섞어 쓸 수 있게 해 초기 웹 개발을 단순하게 만들었습니다. 이 흐름은 서버 코드를 정리하기 위한 프레임워크와 템플릿 엔진, MVC 개념으로 이어졌습니다. 백엔드는 데이터베이스, 인증, 세션을 담당하고 프론트엔드는 만들어진 HTML을 보여 주는 구조가 자리 잡기 시작했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1996-css">
			<article class="event-detail" aria-labelledby="event-1996-css-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1996</p>
					<h2 id="event-1996-css-title">CSS 레벨 1 권고안</h2>
					<p class="event-detail__summary">W3C가 HTML은 구조를, CSS는 모양을 맡기도록 첫 스타일시트 권고안을 발표했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>보스턴 W3C 회의에서 하콘 비움 리와 베르트 보스는 “HTML은 문서를 설명하고, CSS는 화면을 꾸밉니다.”라는 문장을 보여 주었습니다. 참석자들은 <code>h1 { color: navy; }</code> 같은 코드를 보며 글꼴과 여백이 바로 바뀌는 모습을 봤습니다.</p>
						<p>브라우저 제작사는 곧 시험 버전에 CSS 파서를 넣었고, 웹 디자이너는 “테이블 대신 스타일시트를 쓰자.”며 레이아웃 실험을 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>CSS 레벨 1은 <strong>콘텐츠와 표현을 나누자</strong>는 원칙을 제시했습니다. 프론트엔드는 HTML 구조를 그대로 두고 CSS로 모양을 바꿀 수 있었고, 백엔드는 HTML을 만드는 로직에 집중할 수 있었습니다. 이후 박스 모델과 미디어 쿼리 같은 확장이 나오면서 프론트엔드는 UX와 접근성 전략을 더 많이 다루게 됐습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1996-asp">
			<article class="event-detail" aria-labelledby="event-1996-asp-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1996</p>
					<h2 id="event-1996-asp-title">Active Server Pages 도입</h2>
					<p class="event-detail__summary">마이크로소프트가 IIS에 서버 스크립트를 넣어 기업용 웹 애플리케이션을 쉽게 만들 수 있게 했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>프로젝트 룸에서 PM이 말했습니다. “사내 포털을 웹으로 옮겨야 해요.” 개발자들은 HTML 안에 VBScript와 JScript를 섞어 주문, 재고, 권한 관리를 만들었습니다. 파일을 저장하면 IIS가 스크립트를 실행해 결과 HTML을 돌려주었습니다.</p>
						<p>IT 부서는 “윈도우 서버와 SQL Server를 함께 쓸 수 있어서 편하네요.”라며 반겼습니다. 기업 웹 애플리케이션은 서버 로직에 더 많은 비중을 두기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>ASP는 세션 관리와 데이터베이스 연결, COM 연동을 지원했습니다. 덕분에 백엔드는 비즈니스 로직과 상태를 책임지는 쪽으로 굳어졌고, 프론트엔드는 서버가 만들어 준 HTML과 간단한 스크립트를 담당했습니다. “서버 코드는 백엔드, 브라우저 코드는 프론트엔드”라는 말이 현장에서 자연스럽게 쓰이기 시작했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1999-http11">
			<article class="event-detail" aria-labelledby="event-1999-http11-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1999</p>
					<h2 id="event-1999-http11-title">HTTP/1.1 정식화</h2>
					<p class="event-detail__summary">RFC 2616이 발표되면서 지속 연결, 호스트 헤더, 캐시 규칙이 표준이 되었고 대규모 웹서비스를 뒷받침했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>IETF 회의에서 로이 필딩은 “요청마다 TCP를 다시 열면 너무 느립니다.”라며 <code>Connection: keep-alive</code>를 설명했습니다. 또한 <code>Host</code> 헤더를 소개해 하나의 IP에서 여러 도메인을 구분할 수 있게 했습니다.</p>
						<p>웹호스팅 업체는 “이제 하나의 IP로 여러 사이트를 운영할 수 있다.”고 홍보했고, 브라우저는 HTTP/1.1을 기본으로 채택했습니다. CDN은 캐시 제어 규칙을 바탕으로 전 세계에 파일을 뿌리기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>HTTP/1.1은 <strong>지속 연결</strong>, <strong>청크 전송</strong>, <strong>세밀한 캐시 헤더</strong>를 정리했습니다. 백엔드는 연결을 효율적으로 재사용할 수 있었고, 프론트엔드는 더 빠른 응답을 받을 수 있었습니다. REST 스타일 아키텍처와 CDN이 퍼질 수 있었던 바탕이 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1999-xmlhttprequest">
			<article class="event-detail" aria-labelledby="event-1999-xmlhttprequest-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1999</p>
					<h2 id="event-1999-xmlhttprequest-title">XMLHttpRequest 등장</h2>
					<p class="event-detail__summary">브라우저가 화면을 새로 고치지 않고도 서버와 데이터를 주고받을 수 있는 길이 열렸습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>마이크로소프트 Outlook Web Access 팀은 웹메일을 데스크톱처럼 만들고 싶었습니다. 개발자 리나는 “화면 전체를 갈아엎지 말고 필요한 데이터만 가져오자.”라며 <code>XMLHttpRequest</code> 객체를 만들었습니다. 버튼을 눌러도 화면이 깜박이지 않자 사용자들은 놀랐습니다.</p>
						<p>곧 다른 브라우저도 비슷한 API를 넣었고, 프론트엔드는 화면을 유지한 채 서버에서 JSON이나 XML을 받아 일부만 업데이트하기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>XMLHttpRequest 덕분에 자바스크립트로 HTTP 요청을 직접 만들 수 있게 됐습니다. 브라우저는 단순 렌더러가 아니라 데이터 흐름의 주체가 되었습니다. 프론트엔드는 Ajax 호출을 통해 더 많은 로직을 맡았고, 백엔드는 HTML 대신 JSON 같은 데이터를 돌려주는 역할을 맡기 시작했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2001-lamp">
			<article class="event-detail" aria-labelledby="event-2001-lamp-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2001</p>
					<h2 id="event-2001-lamp-title">LAMP 스택 확산</h2>
					<p class="event-detail__summary">리눅스, 아파치, MySQL, PHP가 한 세트처럼 묶이며 웹서비스 구축이 정해진 레시피를 갖게 됐습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p><em>PC Magazine</em>은 2001년 “LAMP(Linux, Apache, MySQL, PHP)는 저렴하고 강력하다.”는 기사를 냈습니다. 스타트업 창업자들은 “이 네 가지만 설치하면 게시판과 쇼핑몰을 만들 수 있대.”라며 링크를 돌렸습니다.</p>
						<p>호스팅 업체는 “월 20달러에 LAMP 환경 제공” 같은 상품을 팔았고, 개발자는 템플릿 엔진과 ORM을 곁들인 CMS(WordPress, phpBB 등)를 배포했습니다. 백엔드는 데이터베이스와 서버 코드를 맡고, 프론트엔드는 PHP가 만든 HTML과 자바스크립트를 다루는 협업 방식이 빠르게 퍼졌습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>LAMP 스택은 웹 개발을 <strong>층</strong>으로 나눠 보는 사고방식을 굳혔습니다. 운영체제(Linux), 웹서버(Apache), 데이터베이스(MySQL), 서버 스크립트(PHP)가 맡을 일을 나누면서 팀은 “여기까지가 프론트, 여기부터가 백엔드”를 명확히 말할 수 있게 됐습니다. 이 구성은 이후 Ruby on Rails, Django, Spring 같은 프레임워크에도 영향을 줬습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2005-ajax">
			<article class="event-detail" aria-labelledby="event-2005-ajax-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2005</p>
					<h2 id="event-2005-ajax-title">Ajax 패턴 확산</h2>
					<p class="event-detail__summary">구글 지도와 지메일이 페이지를 새로 고치지 않는 상호작용을 보여 주며 프론트엔드 중심 개발이 떠올랐습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>2005년, 사용자는 구글 지도에서 지도를 끌어도 화면이 깜박이지 않는 모습을 보고 놀랐습니다. 개발 팀은 백엔드에 데이터를 요청하면서도 브라우저에서 자바스크립트로 화면을 유지했습니다.</p>
						<p>“Ajax”라는 단어가 등장하자 블로그와 컨퍼런스가 이 패턴을 소개했습니다. 개발자들은 프론트엔드에 더 많은 상태 관리와 렌더링 로직을 두기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Ajax는 비동기 요청, JSON/XML 응답, DOM 조작을 엮은 패턴을 뜻하게 되었습니다. 서버는 <strong>데이터 API</strong>를 제공하고, 프론트엔드는 즉시 화면을 바꾸는 역할로 발전했습니다. 이는 REST 설계와 맞물려 백엔드가 데이터 규격과 인증, 확장성에 집중하고 프론트엔드는 상태 관리와 UI를 맡는 분업 구조를 굳혔습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2007-mobile-web">
			<article class="event-detail" aria-labelledby="event-2007-mobile-web-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2007</p>
					<h2 id="event-2007-mobile-web-title">모바일 웹 전환점</h2>
					<p class="event-detail__summary">아이폰과 풀 브라우저가 등장하면서 손안에서도 편하게 볼 수 있는 웹과 가벼운 API 요구가 폭발했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>2007년 1월, 스티브 잡스는 “손가락으로 웹을 탐색하세요.”라며 아이폰을 공개했습니다. 모바일 Safari는 데스크톱 사이트를 축소했지만 확대와 스크롤이 부드럽게 이어졌습니다.</p>
						<p>곧 제품팀은 “3G 네트워크에서도 빨리 열리게 해 주세요.”라는 요청을 받았습니다. Yahoo!와 Google은 모바일용 가벼운 API를 제공했고, 2010년 Ethan Marcotte는 반응형 웹 디자인을 제안하며 하나의 프론트엔드가 다양한 기기를 동시에 지원하는 시대를 열었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>모바일 웹 시대에는 프론트엔드가 <strong>미디어 쿼리</strong>와 터치 UI를 빠르게 도입했습니다. 백엔드는 REST·JSON API, 이미지 최적화, 캐시 전략으로 응답을 가볍게 만드는 데 집중했습니다. 이 변화가 네이티브 앱과 웹앱이 같은 백엔드 API를 쓰는 멀티채널 구조의 출발점이 됐습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2008-chrome">
			<article class="event-detail" aria-labelledby="event-2008-chrome-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2008</p>
					<h2 id="event-2008-chrome-title">Google Chrome &amp; V8 공개</h2>
					<p class="event-detail__summary">구글이 크롬과 V8 엔진을 공개하며 자바스크립트 속도 경쟁이 시작됐고, 웹앱도 데스크톱만큼 빠를 수 있다는 기대가 생겼습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>2008년 9월, 구글은 만화로 새 브라우저를 소개했습니다. 발표회에서 개발자들은 “탭마다 별도 프로세스를 돌리고, V8이 자바스크립트를 바로바로 컴파일합니다.”라고 설명했습니다.</p>
						<p>이후 Gmail, Google Docs 같은 앱이 빠르게 동작하는 시연이 이어졌고, “브라우저도 복잡한 앱을 충분히 처리한다.”는 메시지가 퍼졌습니다. 다른 브라우저도 엔진을 강화하며 속도 경쟁에 뛰어들었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>V8은 <strong>JIT 컴파일</strong>과 <strong>가비지 컬렉션 최적화</strong>로 자바스크립트를 빠르게 돌릴 수 있게 했습니다. 덕분에 프론트엔드는 복잡한 상태 관리나 실시간 협업, 3D 렌더링도 브라우저에서 직접 처리하게 됐고, 백엔드는 REST/JSON API와 WebSocket 등으로 데이터를 가볍게 전달하는 설계에 힘을 쏟았습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2009-node">
			<article class="event-detail" aria-labelledby="event-2009-node-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2009</p>
					<h2 id="event-2009-node-title">Node.js 발표</h2>
					<p class="event-detail__summary">자바스크립트를 서버에서도 돌릴 수 있게 되면서 “한 언어로 프론트와 백을 잇자”는 흐름이 커졌습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>JSConf 2009에서 라이언 달은 “파일 업로드가 끝날 때까지 스레드를 붙잡을 필요가 없습니다.”라며 Node.js를 소개했습니다. 몇 줄의 자바스크립트로 수천 개 연결을 처리하는 시연에 관객이 환호했습니다.</p>
						<p>개발자들은 “프론트엔드와 같은 언어로 API 서버를 만들 수 있네.”라며 Express 같은 프레임워크를 만들었고, JSON 기반 데이터 교환이 자연스러워졌습니다. 빌드 도구와 패키지 생태계(npm)도 빠르게 성장했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Node.js는 이벤트 루프 기반 논블로킹 I/O를 제공해 실시간 채팅, 스트리밍, 협업 편집 같은 서비스를 쉽게 만들도록 도왔습니다. 프론트엔드와 백엔드가 같은 언어를 사용하면서 코드 재사용과 팀 협업이 쉬워졌고, “풀스택 자바스크립트”라는 개념이 실무에 자리 잡았습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2010-angularjs">
			<article class="event-detail" aria-labelledby="event-2010-angularjs-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2010</p>
					<h2 id="event-2010-angularjs-title">AngularJS 공개</h2>
					<p class="event-detail__summary">구글은 브라우저에서 MVC를 구현하겠다며 양방향 데이터 바인딩과 템플릿을 제공했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>개발자 미로슬라브는 “HTML을 앱처럼 다뤄 보자.”라며 AngularJS를 오픈소스로 공개했습니다. 폼을 수정하자 화면이 바로 갱신되고 컨트롤러가 데이터를 관리했습니다.</p>
						<p>스타트업부터 대기업까지 AngularJS로 대시보드와 관리자 도구를 만들며 브라우저가 애플리케이션 런타임이 될 수 있다는 사실을 확인했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>AngularJS는 프론트엔드가 라우팅, 템플릿, 상태 관리를 직접 다루게 했습니다. 덕분에 백엔드는 JSON API 제공자로 역할이 더 뚜렷해졌고, CLI와 빌드 시스템 같은 프론트엔드 도구도 빠르게 발전했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2011-websocket">
			<article class="event-detail" aria-labelledby="event-2011-websocket-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2011</p>
					<h2 id="event-2011-websocket-title">WebSocket 표준 확정</h2>
					<p class="event-detail__summary">RFC 6455가 승인되면서 브라우저와 서버가 하나의 연결로 실시간 양방향 통신을 할 수 있게 됐습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>IETF 회의에서 이안 힉슨은 “폴링 대신 진짜 양방향 채널을 쓰세요.”라며 WebSocket 핸드셰이크를 시연했습니다. 크롬 개발자 도구에 서버 메시지가 바로 나타나자 박수가 터졌습니다.</p>
						<p>트레이딩 데스크, 게임 회사, 채팅 서비스는 즉시 프로토타입을 만들었습니다. GitHub는 협업 알림에 WebSocket을 쓰기 시작했고, Slack은 팀 메시지 스트림을 유지하는 핵심으로 삼았습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>WebSocket은 HTTP 업그레이드로 연결을 연 뒤 프레임 단위로 메시지를 주고받습니다. 프론트엔드는 서버가 밀어 주는 데이터를 받아 UI를 실시간으로 갱신했고, 백엔드는 상태를 맞추기 위해 이벤트 루프와 메시지 브로커를 도입했습니다. 이후 Socket.IO, SignalR, GraphQL Subscriptions 같은 실시간 계층이 이어졌습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2013-react">
			<article class="event-detail" aria-labelledby="event-2013-react-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2013</p>
					<h2 id="event-2013-react-title">React 발표</h2>
					<p class="event-detail__summary">페이스북은 “상태가 바뀌면 UI를 다시 선언하자.”며 컴포넌트 중심 방식을 내놓았습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>JSConf에서 페이스북 엔지니어 조던은 “DOM을 직접 만지지 말고 컴포넌트를 선언하세요.”라고 말했습니다. Virtual DOM 개념에 걱정이 나왔지만 시연 화면은 빠르고 부드럽게 갱신됐습니다.</p>
						<p>React는 곧 스타트업과 대형 서비스에서 쓰이기 시작했고, 프론트엔드 팀은 상태 관리와 빌드, 테스트 도구까지 갖춘 독립 조직으로 성장했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>컴포넌트 기반 개발은 UI를 재사용 가능한 조각으로 나누고, 서버와의 통신을 <strong>API 호출</strong>에 집중시키는 구조를 퍼뜨렸습니다. React, Vue, Svelte 등이 이어지며 프론트엔드는 라우팅과 상태, 렌더링을 직접 담당하는 완전한 애플리케이션 계층이 됐습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2014-lambda">
			<article class="event-detail" aria-labelledby="event-2014-lambda-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2014</p>
					<h2 id="event-2014-lambda-title">AWS Lambda 출시</h2>
					<p class="event-detail__summary">“서버를 직접 관리하지 말고 코드만 올리자”는 생각이 실제 서비스가 됐습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>re:Invent 무대에서 AWS는 이벤트에 맞춰 코드를 실행하는 Lambda를 공개했습니다. 개발자 앨리스가 콘솔에서 웹훅 함수를 저장하자, 곧바로 API Gateway와 연결된 엔드포인트가 열렸습니다.</p>
						<p>스타트업들은 로그인, 알림, 이미지 처리 등을 Lambda로 바꾸며 운영 부담을 줄였습니다. 백엔드는 점점 작은 함수와 이벤트 중심 구조로 나뉘었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>서버리스 모델은 확장과 비용을 자동으로 처리해 줘 백엔드가 인프라 대신 비즈니스 로직에 집중하게 했습니다. “피크 트래픽을 위해 서버를 더 살까?” 같은 고민이 줄었고, 함수별 과금 덕에 실험 기능도 손쉽게 배포했습니다. 프론트엔드는 정적 자산을 CDN에 올리고 필요한 기능만 API로 호출하는 패턴(JAMstack)의 기반을 갖췄습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2014-html5">
			<article class="event-detail" aria-labelledby="event-2014-html5-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2014</p>
					<h2 id="event-2014-html5-title">HTML5 최종 권고</h2>
					<p class="event-detail__summary">W3C가 HTML5를 권고안으로 발표하며 비디오, 캔버스, 오프라인 저장소가 정식 표준이 됐습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>2014년 10월 W3C는 “플러그인 없이 웹에서 멀티미디어를 구현하세요.”라는 메시지와 함께 HTML5 권고안을 발표했습니다. 브라우저는 <code>&lt;video&gt;</code>, <code>&lt;canvas&gt;</code>, <code>localStorage</code> 같은 기능을 기본으로 탑재했습니다.</p>
						<p>개발자들은 워크숍에서 HTML5 게임과 교육 콘텐츠를 시연했고, 기업들은 플래시에서 벗어나기 위한 계획을 세웠습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>HTML5는 웹 플랫폼을 운영체제처럼 쓸 수 있게 만들었습니다. 프론트엔드는 비디오 스트리밍, 그래픽, 오프라인 UX를 직접 구현했고, 백엔드는 REST·스트리밍 API, 콘텐츠 보호, 적응형 비트레이트 같은 서비스를 준비했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2015-http2">
			<article class="event-detail" aria-labelledby="event-2015-http2-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2015</p>
					<h2 id="event-2015-http2-title">HTTP/2 표준 채택</h2>
					<p class="event-detail__summary">SPDY 경험을 바탕으로 멀티플렉싱과 헤더 압축을 담은 HTTP/2가 표준이 되면서 성능 전략이 달라졌습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>IETF는 2015년 5월 RFC 7540을 내며 “HTTP/1.1의 순차 요청 병목을 없애자”고 선언했습니다. 구글 크롬과 파이어폭스는 며칠 만에 업데이트로 HTTP/2를 켰습니다.</p>
						<p>트래픽이 많은 서비스는 “이미지 스프라이트나 도메인 샤딩을 억지로 할 필요가 없다”고 말하며 새 프로토콜로 옮겼습니다. 서버팀은 gRPC 같은 바이너리 프로토콜도 함께 실험했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>HTTP/2는 <strong>스트림 멀티플렉싱</strong>, <strong>헤더 압축(HPACK)</strong>, <strong>서버 푸시</strong>를 도입했습니다. 프론트엔드는 번들 전략을 다시 짜고 코드 스플리팅에 집중했으며, 백엔드는 TLS 최적화와 프로토콜 협상을 담당하는 인프라 역할이 커졌습니다. 이후 HTTP/3와 QUIC으로 이어졌습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2015-graphql">
			<article class="event-detail" aria-labelledby="event-2015-graphql-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2015</p>
					<h2 id="event-2015-graphql-title">GraphQL 공개</h2>
					<p class="event-detail__summary">페이스북이 “클라이언트가 필요한 데이터를 직접 선언하자”는 새 API 방식을 공개했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>React Europe 2015에서 페이스북 엔지니어는 “모바일에서는 데이터가 너무 많이 오고, 웹에서는 너무 적게 온다”는 문제를 보여 줬습니다. GraphQL 쿼리로 필요한 필드만 요청하자, 같은 엔드포인트에서 각 기기가 원하는 데이터만 받아갔습니다.</p>
						<p>공개 직후 핀터레스트, 깃허브 등이 GraphQL API를 도입했습니다. 프론트엔드 팀은 “기능마다 새 REST 엔드포인트를 기다리지 않아도 된다”며 백엔드와의 협업이 빨라졌다고 말했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>GraphQL은 단일 엔드포인트에서 <strong>스키마</strong>로 데이터 타입을 정의하고, 클라이언트가 쿼리로 필요한 구조를 선언하게 합니다. 프론트엔드는 화면에 필요한 조각을 직접 조합하고, 백엔드는 리졸버로 데이터 출처를 관리합니다. 이는 API 디자인이 “리소스 중심”에서 “그래프 중심”으로 이동했음을 보여 주며 BFF 패턴과 API 게이트웨이 설계에도 영향을 줬습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2015-lets-encrypt">
			<article class="event-detail" aria-labelledby="event-2015-lets-encrypt-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2015</p>
					<h2 id="event-2015-lets-encrypt-title">Let’s Encrypt 런칭</h2>
					<p class="event-detail__summary">비영리 인증기관 Let’s Encrypt가 나오며 HTTPS 발급과 갱신이 자동화되어 웹의 기본값이 암호화로 바뀌었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>2015년 12월 ISRG는 “무료 자동화 인증서”를 내세운 Let’s Encrypt 베타를 열었습니다. <code>certbot</code>을 실행하자 몇 초 만에 TLS 인증서가 발급되고 설치됐습니다.</p>
						<p>몇 달 뒤 브라우저는 HTTP 페이지에 “Not Secure” 경고를 띄웠고, 호스팅 업체는 기본 옵션으로 HTTPS를 제공했습니다. 개발팀은 자동 갱신을 CI/CD 파이프라인에 연결했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>HTTPS가 기본이 되면서 프론트엔드는 서비스 워커, PWA, WebAuthn처럼 보안 연결이 필요한 기능을 자유롭게 쓸 수 있게 됐습니다. 백엔드는 TLS 자동화, HSTS, CSP를 관리하며 보안을 운영의 필수 요소로 다뤘습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2016-pwa">
			<article class="event-detail" aria-labelledby="event-2016-pwa-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2016</p>
					<h2 id="event-2016-pwa-title">PWA 권장 아키텍처</h2>
					<p class="event-detail__summary">서비스 워커와 앱 매니페스트를 묶은 PWA 가이드가 나오면서 웹앱이 네이티브와 경쟁할 준비를 갖췄습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Google I/O 2016에서 알렉스 러셀은 “웹도 오프라인에서 돌아가고 푸시 알림을 보낼 수 있습니다.”라며 PWA 체크리스트를 공개했습니다. 시연 중 크롬 홈 화면에 트위터 라이트 아이콘이 추가되자 관객이 환호했습니다.</p>
						<p>개발팀은 <code>serviceWorker.register()</code> 호출과 <code>manifest.json</code> 파일만으로 설치 가능한 웹앱을 만들었고, 대형 커머스 서비스는 PWA 전환 후 전환율이 올랐다고 발표했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>PWA는 <strong>서비스 워커</strong>, <strong>오프라인 캐시</strong>, <strong>푸시 알림</strong>을 묶어 프론트엔드가 앱 쉘 패턴을 구현하도록 이끌었습니다. 백엔드는 백그라운드 동기화와 푸시 토큰을 관리하는 API를 제공하며 모바일과 데스크톱을 아우르는 경험을 지원했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2017-webassembly">
			<article class="event-detail" aria-labelledby="event-2017-webassembly-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2017</p>
					<h2 id="event-2017-webassembly-title">WebAssembly MVP 완료</h2>
					<p class="event-detail__summary">브라우저 벤더가 함께 WebAssembly MVP를 발표하며 웹이 컴파일 언어 런타임을 품게 됐습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>2017년 3월 주요 브라우저 엔진 팀은 “오늘부터 WebAssembly가 기본으로 켜집니다.”라는 공동 글을 올렸습니다. 시연 영상에서 C++로 만든 게임이 브라우저에서 네이티브에 가까운 속도로 실행됐습니다.</p>
						<p>핀테크와 CAD 업체는 계산이 많은 모듈을 옮겼고, 오디오·비디오 편집 스타트업은 WebAssembly 기반 프로토타입을 공개했습니다. 프론트엔드는 자바스크립트와 WebAssembly 모듈을 함께 번들링하는 전략을 시험했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>WebAssembly는 <strong>바이너리 포맷</strong>과 <strong>샌드박스 실행</strong>을 제공해 백엔드에서 쓰던 언어를 프론트엔드로 가져올 수 있게 했습니다. 백엔드는 CPU 집약 기능을 클라이언트로 넘기거나 BFF를 통해 필요한 데이터만 전달하는 구조를 설계하며 작업 부하를 조정했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2017-cloudflare-workers">
			<article class="event-detail" aria-labelledby="event-2017-cloudflare-workers-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2017</p>
					<h2 id="event-2017-cloudflare-workers-title">Cloudflare Workers 출시</h2>
					<p class="event-detail__summary">CDN 엣지에서 자바스크립트를 실행하는 Workers가 나오며 “사용자 가까운 런타임”이 현실이 됐습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Cloudflare는 Recurse Center 프레스 브리핑에서 “글로벌 네트워크 어디서든 10ms 안에 코드를 실행하세요.”라며 Workers 베타를 소개했습니다. 개발자는 몇 줄의 자바스크립트만 배포해 A/B 테스트, 사용자 지정 라우팅, 이미지 변환을 처리했습니다.</p>
						<p>이후 Vercel과 Netlify도 비슷한 엣지 함수 플랫폼을 내놨고, 제품팀은 “정적 배포 + 엣지 + 서버리스” 구성을 기본 전략으로 삼았습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>엣지 런타임은 백엔드가 중앙 데이터베이스와 API를 유지하면서도 지연이 민감한 로직을 사용자 가까이로 분산할 수 있게 했습니다. 프론트엔드는 엣지 미들웨어를 활용해 맞춤 렌더링, 인증, 국제화를 빠르게 처리했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2020-jamstack">
			<article class="event-detail" aria-labelledby="event-2020-jamstack-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2020</p>
					<h2 id="event-2020-jamstack-title">JAMstack와 엣지 함수 확산</h2>
					<p class="event-detail__summary">정적 빌드, CDN 배포, API 조합이 기본이 되면서 프론트와 백엔드를 느슨하게 잇는 구조가 대중화됐습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>제품팀은 Netlify, Vercel 같은 플랫폼에 저장소를 연결하고 “main에 머지하면 자동으로 배포됩니다.”라는 알림을 받았습니다. 프론트엔드는 정적 파일로 빌드되어 전 세계 CDN에 퍼지고, 필요한 데이터는 API나 서버리스 함수에서 가져왔습니다.</p>
						<p>엣지 함수 덕분에 개발자들은 사용자 위치에 맞춰 콘텐츠를 바꿨습니다. “서울에는 이 배너, 뉴욕에는 저 배너” 같은 요구가 코드 몇 줄로 가능해졌습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>JAMstack은 <strong>JavaScript</strong>, <strong>API</strong>, <strong>Markup</strong> 조합을 강조하며 프론트와 백엔드를 따로 배포하는 방식을 표준처럼 만들었습니다. 백엔드는 인증, 데이터, 비즈니스 로직을 API로 제공하고, 프론트엔드는 정적 자산과 런타임 로직을 맡아 빠른 배포와 확장성을 얻었습니다. 이 흐름은 마이크로서비스, 엣지 컴퓨팅, 서버리스 워크플로로 이어지고 있습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<script src="assets/js/main.js" defer></script>
	</body>
</html>
