<!DOCTYPE html>
<html lang="ko">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>ArcherLab IT Story · 웹이 층을 나눈 이유</title>
		<meta name="description" content="정적 문서에서 CGI, Ajax, SPA, 서버리스까지. 웹이 프론트엔드와 백엔드로 나뉘고 다시 협력하게 된 순간을 타임라인으로 살펴봅니다." />
		<meta property="og:title" content="ArcherLab IT Story · Web Layers Timeline" />
		<meta property="og:description" content="WWW 제안부터 서버리스까지, 웹이 정적 문서에서 앱 플랫폼으로 성장한 과정을 읽어 보세요." />
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700;800&family=Space+Grotesk:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500;600&display=swap" rel="stylesheet">
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css">
		<link rel="stylesheet" href="assets/css/style.css">
	</head>
	<body>
		<div class="page">
			<header class="page__header" role="banner">
				<div class="page__header-left">
					<a class="page__brand" href="https://archerlab.dev" target="_blank" rel="noopener">
						<img src="assets/images/archerlab_mini_logo.png" alt="ArcherLab" class="page__brand-logo" loading="lazy">
						<span class="page__brand-label">ArcherLab Chronicle</span>
					</a>
					<nav class="page__topic-nav" aria-label="주제 전환">
						<a href="index.html">홈 허브</a>
						<a href="networks.html">네트워크 연대기</a>
						<a href="computers.html">컴퓨터 연대기</a>
						<a href="web.html" class="is-current">웹 연대기</a>
						<a href="databases.html">데이터베이스 연대기</a>
					</nav>
				</div>
				<nav class="page__nav" aria-label="섹션 탐색">
					<a href="#timeline">연도 보기</a>
					<a href="#sources">참고</a>
				</nav>
			</header>

			<main class="page__main" id="main" role="main">
				<section class="timeline-hero" aria-labelledby="timeline-title">
					<div class="timeline-hero__head">
						<p class="hero__eyebrow">Web Story for Product Builders</p>
						<h1 class="timeline-hero__title" id="timeline-title">정적 문서에서 API와 서버리스까지, 웹이 층을 나눠 성장한 이유를 따라가 보세요</h1>
						<p class="timeline-hero__lede">
							연구소 복도에서 문서를 돌려보던 과학자에게서 시작해, 전 세계 사용자를 상대하는 제품팀까지. 웹은 "파일을 보여 주는 곳"에서 "앱을 실행하는 무대"로 변하며 프론트엔드와 백엔드라는 역할을 만들었습니다.
						</p>
						<p class="timeline-hero__lede">
							연도 버튼을 누르면 정적 페이지, CGI, Ajax, SPA, 서버리스로 이어지는 실험과 그 결과가 다음 세대의 개발 방식을 어떻게 바꿨는지 확인할 수 있습니다.
						</p>
					</div>
				</section>

				<section class="timeline-grid" id="timeline" aria-labelledby="timeline-title" aria-describedby="timeline-instructions">
					<p class="timeline-grid__instructions sr-only" id="timeline-instructions">연도 버튼을 누르면 새 창 없이 팝업 대화 상자가 열리고, 그 자리에서 자세한 이야기를 이어서 읽을 수 있습니다.</p>

					<section class="timeline-group" aria-labelledby="decade-1990 topic-1990">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1990">1990–1993</p>
							<h3 class="timeline-group__topic" id="topic-1990">정적 문서를 연결한 첫 웹</h3>
							<p class="timeline-group__summary">WWW 제안과 최초의 브라우저·서버 구현이 등장하며 "파일을 요청하고 보여 주는" 정적 구조가 자리 잡았습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1990-www-proposal">
								<span class="timeline-event__year">1990</span>
								<span class="timeline-event__label">WWW 제안</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1991-first-site">
								<span class="timeline-event__year">1991</span>
								<span class="timeline-event__label">첫 웹사이트 공개</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1993-mosaic">
								<span class="timeline-event__year">1993</span>
								<span class="timeline-event__label">Mosaic 공개</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-1990-dynamic topic-1990-dynamic">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1990-dynamic">1993–1997</p>
							<h3 class="timeline-group__topic" id="topic-1990-dynamic">서버가 문서를 만들어 주기 시작하다</h3>
							<p class="timeline-group__summary">CGI와 JavaScript, PHP, ASP가 자리 잡으며 서버는 맞춤 HTML을 만들고 브라우저는 즉각적인 상호작용을 담당하기 시작했습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1993-cgi">
								<span class="timeline-event__year">1993</span>
								<span class="timeline-event__label">CGI 표준화</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1995-javascript">
								<span class="timeline-event__year">1995</span>
								<span class="timeline-event__label">JavaScript 탄생</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1995-php">
								<span class="timeline-event__year">1995</span>
								<span class="timeline-event__label">PHP 도구</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1996-asp">
								<span class="timeline-event__year">1996</span>
								<span class="timeline-event__label">Active Server Pages</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-2000 topic-2000">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-2000">1998–2006</p>
							<h3 class="timeline-group__topic" id="topic-2000">브라우저가 움직임을 맡다</h3>
							<p class="timeline-group__summary">XMLHttpRequest, LAMP 스택, Ajax 패턴이 맞물리며 프론트엔드는 비동기 상호작용을, 백엔드는 표준화된 서버 구성을 맡았습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1999-xmlhttprequest">
								<span class="timeline-event__year">1999</span>
								<span class="timeline-event__label">XMLHttpRequest 등장</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2001-lamp">
								<span class="timeline-event__year">2001</span>
								<span class="timeline-event__label">LAMP 스택 확산</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2005-ajax">
								<span class="timeline-event__year">2005</span>
								<span class="timeline-event__label">Ajax 패턴 확산</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-2010 topic-2010">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-2010">2009–2016</p>
							<h3 class="timeline-group__topic" id="topic-2010">브라우저가 애플리케이션이 되다</h3>
							<p class="timeline-group__summary">Node.js와 SPA 프레임워크가 등장하며 프론트엔드가 애플리케이션 전체를 직접 다루고, 백엔드는 API 제공자로 역할이 재정의되었습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="2009-node">
								<span class="timeline-event__year">2009</span>
								<span class="timeline-event__label">Node.js 발표</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2010-angularjs">
								<span class="timeline-event__year">2010</span>
								<span class="timeline-event__label">AngularJS 공개</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2013-react">
								<span class="timeline-event__year">2013</span>
								<span class="timeline-event__label">React 발표</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-2020 topic-2020">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-2020">2014–2025</p>
							<h3 class="timeline-group__topic" id="topic-2020">API와 서버리스로 재조합</h3>
							<p class="timeline-group__summary">Lambda, GraphQL, JAMstack과 엣지 함수가 등장하며 백엔드는 API와 이벤트, 프론트는 독립 배포와 조합을 맡는 구조가 완성되었습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="2014-lambda">
								<span class="timeline-event__year">2014</span>
								<span class="timeline-event__label">AWS Lambda 출시</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2015-graphql">
								<span class="timeline-event__year">2015</span>
								<span class="timeline-event__label">GraphQL 공개</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2020-jamstack">
								<span class="timeline-event__year">2020</span>
								<span class="timeline-event__label">JAMstack/엣지 확산</span>
							</button>
						</div>
					</section>
				</section>

				<section class="sources" id="sources" aria-labelledby="sources-title">
					<div class="section__head">
						<h2 id="sources-title">참고 자료</h2>
						<p>웹의 구조가 정적 문서에서 애플리케이션 플랫폼으로 바뀐 과정을 기록한 1차 자료와 회고를 모았습니다. 원문을 읽어 보면 각 시대의 개발자들이 어떤 문제를 해결하려 했는지 더 선명합니다.</p>
					</div>
					<ul class="source-list">
						<li><a href="https://www.w3.org/Proposal.html" target="_blank" rel="noopener">Tim Berners-Lee · Information Management: A Proposal</a></li>
						<li><a href="https://www.w3.org/History/19921103-hypertext/hypertext/WWW/TheProject.html" target="_blank" rel="noopener">CERN · World Wide Web Project</a></li>
						<li><a href="https://www.rfc-editor.org/rfc/rfc3875" target="_blank" rel="noopener">NCSA · Common Gateway Interface Specification</a></li>
						<li><a href="https://queue.acm.org/detail.cfm?id=1117401" target="_blank" rel="noopener">ACM Queue · Ajax: A New Approach to Web Applications</a></li>
						<li><a href="https://aws.amazon.com/blogs/aws/aws-lambda-event-driven-code-in-the-cloud/" target="_blank" rel="noopener">AWS News Blog · AWS Lambda Announcement</a></li>
						<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript" target="_blank" rel="noopener">MDN · A re-introduction to JavaScript</a></li>
						<li><a href="https://nodejs.org/en/about" target="_blank" rel="noopener">Node.js Foundation · About Node.js</a></li>
						<li><a href="https://engineering.fb.com/2015/09/14/core-data/graphql-a-data-query-language/" target="_blank" rel="noopener">Meta Engineering · GraphQL: A Data Query Language</a></li>
					</ul>
				</section>
			</main>

			<footer class="page__footer" role="contentinfo">
				<p>© 2025 ArcherLab · Stories on how the web split and reunited.</p>
				<a class="page__footer-link" href="https://archerlab.dev" target="_blank" rel="noopener">archerlab.dev</a>
			</footer>
		</div>

		<div class="modal" id="event-modal" role="dialog" aria-modal="true" hidden>
			<div class="modal__overlay" data-modal-close></div>
			<div class="modal__window" role="document" tabindex="-1">
				<button class="modal__close" type="button" aria-label="레이어 닫기" data-modal-close>&times;</button>
				<div class="modal__content"></div>
			</div>
		</div>

		<template id="event-1990-www-proposal">
			<article class="event-detail" aria-labelledby="event-1990-www-proposal-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1990</p>
					<h2 id="event-1990-www-proposal-title">WWW 제안 · 팀 버너스-리</h2>
					<p class="event-detail__summary">CERN 연구원들은 “문서를 공유하려면 메일을 또 보내야 하잖아요.”라고 불평했습니다. 팀 버너스-리는 하이퍼텍스트와 인터넷을 결합한 제안을 작성했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>연구소 복도에서 팀 버너스-리는 노트북에 “Information Management: A Proposal”이라는 제목을 쓰고, 메모를 넘겨 보던 동료에게 “이 링크 개념을 쓰면 문서를 서로 가리킬 수 있어요.”라고 설명했습니다. 동료는 “URL은 어떻게 생겼죠?”라고 묻자, 팀은 종이에 <code>http://</code>를 적으며 서버가 파일을 찾아 돌려주면 브라우저가 화면으로 보여 준다고 답했습니다.</p>
						<p>시스템 관리자는 시험용 NeXT 머신을 연결해 주었고, 팀은 HTML, HTTP, 첫 웹서버인 CERN httpd를 직접 구현했습니다. 연구자들은 “이제 메일 첨부 대신 링크를 보내면 되겠네.”라며 새로운 도구를 써 보기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>제안서의 핵심은 <strong>URI</strong>, <strong>HTTP</strong>, <strong>HTML</strong>이라는 세 가지 규격이었습니다. 파일을 요청하는 규칙과 문서를 구조화하는 언어, 그리고 문서를 식별하는 주소 체계를 함께 정의하면서, 누구나 서버에 파일을 올리고 동일한 브라우저로 읽을 수 있는 정적 웹이 태어났습니다. 이 단계에서 서버는 단순히 파일을 돌려주는 역할만 수행했고, 프론트엔드와 백엔드의 구분은 아직 필요하지 않았습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1991-first-site">
			<article class="event-detail" aria-labelledby="event-1991-first-site-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1991</p>
					<h2 id="event-1991-first-site-title">첫 웹사이트 공개</h2>
					<p class="event-detail__summary">“인터넷에 이런 문서를 올리고 싶다면 이렇게 하세요.”라는 안내문이 세계 최초의 웹페이지였습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>1991년 8월, 팀 버너스-리는 CERN의 NeXT 서버에 <code>info.cern.ch</code>라는 주소를 열어 “World Wide Web Project”라는 제목의 페이지를 올렸습니다. 페이지 디자인은 검은 글자와 파란 링크뿐이었고, “새 문서를 만들려면 HTML 태그를 이렇게 쓰세요.”라는 설명과 함께 샘플 코드가 적혀 있었습니다.</p>
						<p>전화 회선으로 접속한 연구자들은 텍스트 브라우저에서 링크를 눌러 보며 “이제 문서 사이를 화살표 키로 왔다 갔다 할 수 있네.”라고 감탄했습니다. 몇 주 뒤, 외부 대학 연구실에서도 같은 지침을 따라 웹서버를 설치하기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>첫 웹사이트는 튜토리얼이자 문서 표준이었습니다. 서버 설정 방법, HTML 태그 목록, 링크 작성법을 한 페이지에서 확인할 수 있었기 때문에 “웹”이라는 개념은 매뉴얼을 읽을 줄 아는 개발자라면 누구나 따라 할 수 있는 열린 시스템으로 자리 잡았습니다. 여전히 서버는 디스크에 있는 파일을 그대로 전달하는 역할만 했고, 브라우저는 해당 파일을 읽어 화면에 표시했습니다. 이 단순함 덕분에 웹은 빠르게 퍼질 수 있었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1993-mosaic">
			<article class="event-detail" aria-labelledby="event-1993-mosaic-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1993</p>
					<h2 id="event-1993-mosaic-title">Mosaic 브라우저 공개</h2>
					<p class="event-detail__summary">UI가 있는 브라우저가 등장하자 연구소 밖 사용자도 “링크를 클릭하는 경험”을 처음 맞이했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>NCSA의 학생들은 그래픽 버튼과 이미지가 들어간 새 브라우저를 시연하며 “여기, 직접 클릭해 보세요.”라고 관객에게 마우스를 건넸습니다. 링크가 파란색으로 표시되고 같은 창에서 다른 문서가 열리자 모두가 감탄했습니다.</p>
						<p>신문 기자는 “웹이란 게 이렇게 생겼나요?”라고 묻고는 기사에 Mosaic 스크린샷을 실었습니다. 곧 대학과 기업에서도 Mosaic을 설치해 정적 페이지를 게시하기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Mosaic은 이미지와 텍스트를 한 화면에 보여 주는 렌더링 엔진, 마우스 중심 UI, 북마크 기능을 제공하며 웹을 대중화했습니다. 하지만 여전히 서버는 정적 파일만 전달했습니다. 프론트엔드는 HTML을 해석해 화면을 꾸미는 역할만 담당했고, 맞춤형 콘텐츠를 제공하려면 새로운 방식이 필요하다는 인식이 생겨났습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1993-cgi">
			<article class="event-detail" aria-labelledby="event-1993-cgi-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1993</p>
					<h2 id="event-1993-cgi-title">CGI 표준화</h2>
					<p class="event-detail__summary">서버가 외부 프로그램을 실행해 HTML을 만들어 주는 인터페이스가 정의되면서 “백엔드 로직”이라는 개념이 태어났습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>NCSA httpd 팀은 “게스트북에 글을 남기면 바로 반영하도록 해 달라”는 요청을 받고 회의실에 모였습니다. 개발자 수지는 “요청이 들어오면 Perl 스크립트를 실행해서 HTML을 만들어 돌려주죠.”라고 제안했습니다.</p>
						<p>그 결과가 Common Gateway Interface였습니다. 방문자가 폼을 제출하면 서버가 스크립트를 실행해 데이터베이스에 기록하고, 그 결과를 HTML로 출력했습니다. 연구자들은 “파일이 아니라 프로그램이 응답을 만든다”는 사실에 놀랐습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>CGI는 환경 변수와 표준 입력/출력을 통해 웹서버와 프로그램이 데이터를 주고받는 규칙을 정의했습니다. 이는 서버가 사용자별, 요청별로 다른 결과를 반환할 수 있는 토대를 마련했고, 프론트엔드와 구분되는 서버측 로직(백엔드)의 첫 형태가 되었습니다. 다만 매 요청마다 프로세스를 새로 띄우기 때문에 성능 부담이 컸습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1995-javascript">
			<article class="event-detail" aria-labelledby="event-1995-javascript-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1995</p>
					<h2 id="event-1995-javascript-title">JavaScript 탄생</h2>
					<p class="event-detail__summary">브라우저가 단순 문서를 넘어서 상호작용을 담당할 수 있도록 ‘브라우저용 스크립트 언어’가 만들어졌습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Netscape의 개발자 브렌던 아이크는 “사용자가 버튼을 클릭했을 때 서버까지 갔다가 돌아오는 시간을 줄이고 싶다.”는 요구를 듣고 10일 만에 새로운 스크립트 언어를 작성했습니다. 마케팅 팀은 이를 “LiveScript”라 불렀지만, 곧 당시 인기 언어였던 자바의 이름을 빌린 “JavaScript”로 알려지게 되었습니다.</p>
						<p>브라우저 시연에서 개발자들은 “텍스트 상자에 이름을 입력하고 나면 바로 인사말이 바뀌어요!”라고 외쳤습니다. 사용자의 입력을 즉시 검증하거나, 이미지 롤오버를 구현하는 등의 작은 상호작용이 가능해졌고, 프론트엔드는 단순한 HTML 표시에 머무르지 않게 되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>JavaScript는 브라우저 안에서 실행되는 가벼운 언어로 시작했지만, <strong>이벤트 루프</strong>와 <strong>DOM 조작</strong>이라는 개념을 소개하며 프론트엔드 개발을 프로그래밍의 한 분야로 만들었습니다. 서버가 모든 로직을 담당하던 시대에서 브라우저가 “즉각적인 반응”을 담당하게 되자, 프론트엔드는 사용자 경험을, 백엔드는 데이터와 비즈니스 로직을 맡는 구조로 서서히 분리되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1995-php">
			<article class="event-detail" aria-labelledby="event-1995-php-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1995</p>
					<h2 id="event-1995-php-title">PHP 도구의 공개</h2>
					<p class="event-detail__summary">라스무스 러도프는 “웹 페이지에서 내 이력서를 동적으로 관리해 보고 싶다”라며 HTML 안에 직접 코드를 끼워 넣을 수 있는 도구를 배포했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>라스무스는 개인 홈페이지 방문 통계를 보기 위해 Perl 스크립트를 작성했지만 유지보수가 번거로웠습니다. 그래서 HTML에 <code>&lt;?php&nbsp;?&gt;</code> 블록을 넣어 바로 DB에 연결하고 결과를 출력하는 방식을 만들었습니다. 커뮤니티 게시판에는 “폼 검증이 한 줄로 끝나요!” 같은 댓글이 쏟아졌습니다.</p>
						<p>웹마스터들은 게시판과 쇼핑몰을 만들며 PHP를 확산시켰고, 서버는 요청마다 PHP 인터프리터를 호출해 HTML을 즉석에서 생성했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>PHP는 템플릿과 로직을 한 파일에 섞어 쓸 수 있게 해 초기 웹 개발을 빠르게 했습니다. 이는 서버 측 코드를 유지하기 위한 프레임워크, 템플릿 엔진, MVC 개념이 등장하는 토대로 이어졌습니다. 백엔드는 데이터베이스 연결, 인증, 세션 관리를 맡고 프론트엔드는 생성된 HTML을 렌더링하는 역할로 나뉘기 시작했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1996-asp">
			<article class="event-detail" aria-labelledby="event-1996-asp-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1996</p>
					<h2 id="event-1996-asp-title">Active Server Pages 도입</h2>
					<p class="event-detail__summary">마이크로소프트는 IIS에 서버 스크립트를 내장해 기업용 웹 애플리케이션 개발을 지원했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>컨설팅 기업의 프로젝트 룸에서 PM은 “사내 포털을 웹으로 옮겨야 합니다.”라고 말했습니다. 개발자들은 VBScript와 JScript를 HTML에 섞어 쓰며 주문, 재고, 권한 관리를 구현했습니다. 페이지를 저장하면 IIS가 자동으로 스크립트를 실행해 결과를 돌려줬습니다.</p>
						<p>IT 부서는 “윈도우 서버와 SQL Server를 묶어 배포할 수 있으니 편하네요.”라고 평가했습니다. 기업 웹 애플리케이션이 백엔드 로직 위주로 성장하기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>ASP는 세션 관리, 데이터베이스 연결, 컴포넌트 객체 모델(COM) 연동을 제공해 백엔드가 비즈니스 로직과 상태를 책임지는 구조를 공고히 했습니다. 이 시기부터 프론트엔드는 서버가 보낸 HTML과 최소한의 JavaScript를 담당했고, “서버 코드는 백엔드, 브라우저 코드는 프론트엔드”라는 용어가 실무에서 쓰이기 시작했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1999-xmlhttprequest">
			<article class="event-detail" aria-labelledby="event-1999-xmlhttprequest-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1999</p>
					<h2 id="event-1999-xmlhttprequest-title">XMLHttpRequest 등장</h2>
					<p class="event-detail__summary">브라우저가 페이지를 새로고침하지 않고도 서버와 데이터를 주고받을 수 있는 숨은 문이 열렸습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>마이크로소프트 Outlook Web Access 팀은 웹메일을 데스크톱 앱처럼 만들고 싶었습니다. 개발자 리나는 “프레임을 갈아치우지 말고 비동기로 데이터를 가져오자.”라며 <code>XMLHttpRequest</code> 객체를 만들었습니다. 버튼을 눌렀는데도 화면이 깜박이지 않자 사용자들은 놀랐습니다.</p>
						<p>다른 브라우저들도 비슷한 API를 도입했고, 프론트엔드는 화면을 유지한 채 서버에서 JSON이나 XML을 받아 UI를 갱신하기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>XMLHttpRequest는 HTTP 요청을 자바스크립트로 직접 만들 수 있게 하여 브라우저가 단순 렌더러를 넘어 데이터 흐름의 주체가 되도록 했습니다. 프론트엔드는 Ajax 호출을 통해 더 많은 로직을 가져왔고, 백엔드는 템플릿 대신 JSON 등의 데이터를 반환하는 역할을 맡기 시작했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2001-lamp">
			<article class="event-detail" aria-labelledby="event-2001-lamp-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2001</p>
					<h2 id="event-2001-lamp-title">LAMP 스택 확산</h2>
					<p class="event-detail__summary">리눅스, 아파치, MySQL, PHP가 “한 세트”로 엮이며 웹서비스 구축이 공식 메뉴처럼 정리되었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>잡지 <em>PC Magazine</em>은 2001년 “LAMP(Linux, Apache, MySQL, PHP)는 저렴하게도 강력하다”라는 기사로 네 가지 오픈소스 조합을 소개했습니다. 스타트업 창업자들은 “이 네 가지만 설치하면 게시판과 쇼핑몰을 만들 수 있다네.”라고 서로 링크를 공유했습니다.</p>
						<p>호스팅 업체들은 “월 20달러에 LAMP 환경 제공” 같은 상품을 내놓았고, 개발자들은 템플릿 엔진과 ORM을 곁들인 CMS(WordPress, phpBB 등)를 배포했습니다. 백엔드는 데이터베이스와 서버 코드를 맡고, 프론트엔드는 PHP가 만들어 준 HTML과 JavaScript를 다루는 협업 모델이 빠르게 확산되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>LAMP 스택은 웹 개발을 <strong>레이어</strong>로 바라보는 사고방식을 정착시켰습니다. 운영체제(Linux), 웹서버(Apache), 데이터베이스(MySQL), 서버 스크립트(PHP)가 역할을 나눈 덕분에 팀마다 “어디까지가 프론트이고 어디부터가 백엔드인가”를 명확히 나눌 수 있었습니다. 이러한 구성이 이후 Ruby on Rails, Django, Spring 같은 프레임워크 설계에도 그대로 영향을 끼쳤습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2005-ajax">
			<article class="event-detail" aria-labelledby="event-2005-ajax-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2005</p>
					<h2 id="event-2005-ajax-title">Ajax 패턴 확산</h2>
					<p class="event-detail__summary">구글 지도와 지메일이 “페이지 전환 없는 상호작용”을 대중에게 보여 주며 프론트엔드 중심 개발이 부상했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>2005년, 사용자는 구글 지도에서 마우스로 지도를 끌다가 놀랐습니다. “페이지가 새로고침되지 않네요!” 개발 팀은 백엔드에 데이터를 요청하되, 브라우저에서 JavaScript로 화면을 계속 유지했습니다.</p>
						<p>“Ajax”라는 용어가 만들어지자 각종 블로그와 컨퍼런스에서 이 패턴을 소개했습니다. 개발자들은 프론트엔드에 더 많은 상태 관리와 렌더링 로직을 두기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Ajax는 비동기 요청, JSON/ XML 응답, DOM 조작을 조합한 패턴의 이름이 되었습니다. 서버는 <strong>데이터 API</strong>를 제공하고, 프론트엔드는 사용자의 상호작용을 즉시 반영하는 역할로 진화했습니다. 이 흐름은 “리소스를 URL로 표현하고 HTTP 메서드로 조작한다”는 REST 설계 원칙과 맞물려, 백엔드가 데이터 규격과 인증·확장성에 집중하고 프론트엔드는 상태 관리와 UI 구축을 담당하는 분업 구조를 뚜렷하게 만들었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2009-node">
			<article class="event-detail" aria-labelledby="event-2009-node-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2009</p>
					<h2 id="event-2009-node-title">Node.js 발표</h2>
					<p class="event-detail__summary">자바스크립트가 브라우저를 넘어 서버에서도 실행되면서 “한 언어로 프론트와 백을 잇자”는 흐름이 커졌습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>JSConf 2009 무대에서 라이언 달은 “파일 업로드가 끝날 때까지 스레드를 붙잡고 있을 필요는 없습니다.”라고 말하며 Node.js를 소개했습니다. 시연에서 수천 개의 동시 연결을 처리하는 서버가 간단한 자바스크립트 코드 몇 줄로 구현되자 관객이 환호했습니다.</p>
						<p>개발자들은 곧 “프론트엔드 코드와 같은 언어로 API 서버를 만들 수 있네.”라고 말하며 Express 같은 프레임워크를 만들었습니다. JSON을 중심으로 한 데이터 교환이 자연스러워지고, 빌드 도구와 패키지 생태계(npm)가 폭발적으로 성장했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Node.js는 이벤트 루프 기반의 논블로킹 I/O를 제공해 실시간 채팅, 스트리밍, 협업 편집처럼 빠른 응답이 필요한 서비스를 쉽게 만들도록 돕습니다. 프론트엔드와 백엔드가 같은 언어를 공유하면서 코드 재사용과 팀 협업도 쉬워졌으며, “풀스택 자바스크립트”라는 개념이 실무에 뿌리내렸습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2010-angularjs">
			<article class="event-detail" aria-labelledby="event-2010-angularjs-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2010</p>
					<h2 id="event-2010-angularjs-title">AngularJS 공개</h2>
					<p class="event-detail__summary">구글은 “브라우저 안에서 MVC를 구현하자”라며 양방향 데이터 바인딩과 템플릿 기능을 제공했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>개발자 미로슬라브는 “HTML을 앱처럼 다뤄 보자”고 결심하고 AngularJS를 오픈 소스로 공개했습니다. 폼을 조작하면 화면이 즉시 갱신되고, 컨트롤러가 데이터를 관리했습니다.</p>
						<p>초기 스타트업과 대규모 기업 모두 AngularJS로 대시보드, 관리자 도구를 만들며 브라우저가 애플리케이션 런타임이 될 수 있음을 체감했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>AngularJS는 프론트엔드가 라우팅, 템플릿, 상태 관리를 스스로 처리하도록 만들었습니다. 이로써 백엔드는 JSON API 제공자 역할로 더 선명해졌고, CLI와 빌드 시스템 같은 프론트엔드 도구 체인이 발전하는 계기가 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2013-react">
			<article class="event-detail" aria-labelledby="event-2013-react-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2013</p>
					<h2 id="event-2013-react-title">React 발표</h2>
					<p class="event-detail__summary">페이스북은 “상태가 변할 때마다 UI를 다시 선언하자”라며 컴포넌트 중심 접근을 소개했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>JSConf 무대에서 페이스북 엔지니어 조던은 “DOM을 직접 건드리는 것보다 컴포넌트를 선언하세요.”라고 이야기했습니다. Virtual DOM 개념이 발표되자 관객들은 “브라우저가 느려지지 않을까요?”라고 물었지만, 시연은 부드럽게 동작했습니다.</p>
						<p>React는 금세 스타트업과 대규모 서비스에 채택되었고, 프론트엔드 팀은 상태 관리, 빌드 파이프라인, 테스트 도구를 포함한 독립된 조직으로 성장했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>컴포넌트 기반 개발은 UI를 재사용 가능한 모듈로 나누고, 서버와의 통신을 <strong>API 호출</strong>에 집중시키는 아키텍처를 촉진했습니다. React, Vue, Svelte 같은 프레임워크가 뒤이어 등장하면서 프론트엔드는 자체 라우팅, 상태, 렌더링 파이프라인을 갖춘 완전한 애플리케이션 계층으로 자리 잡았습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2014-lambda">
			<article class="event-detail" aria-labelledby="event-2014-lambda-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2014</p>
					<h2 id="event-2014-lambda-title">AWS Lambda 출시</h2>
					<p class="event-detail__summary">“서버를 직접 관리하지 않고 코드를 올려 실행하자”는 아이디어가 실 서비스로 제공되었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>re:Invent 무대에서 AWS는 파일 업로드나 이벤트에 반응해 코드를 실행하는 Lambda를 발표했습니다. 개발자 앨리스는 “인증 웹훅을 처리하는 데 서버가 필요 없네요.”라고 감탄했습니다. 콘솔에서 함수를 저장하자 즉시 API Gateway와 연결되어 동작했습니다.</p>
						<p>스타트업들은 로그인, 알림, 이미지 처리 등을 Lambda로 구현하며 운영 부담을 줄였습니다. 백엔드는 점점 작은 함수와 이벤트를 중심으로 재편되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>서버리스 모델은 확장성과 비용을 자동으로 관리해 주어 백엔드가 인프라 대신 비즈니스 로직에 집중하게 만들었습니다. 더 이상 “주말 트래픽을 대비해 서버를 몇 대 더 살지” 고민할 필요가 없었고, 함수별로 과금되기 때문에 실험용 기능을 가볍게 배포할 수 있었습니다. 그 결과 프론트엔드는 정적 자산을 CDN에 배포하고 필요한 기능만 API 호출로 연결하는 패턴(JAMstack)의 토대가 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2015-graphql">
			<article class="event-detail" aria-labelledby="event-2015-graphql-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2015</p>
					<h2 id="event-2015-graphql-title">GraphQL 공개</h2>
					<p class="event-detail__summary">페이스북이 “클라이언트가 필요한 데이터 구조를 직접 선언하자”라는 새로운 API 방식을 오픈소스로 내놓았습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>React Europe 2015에서 페이스북 엔지니어는 뉴스피드 앱 시연을 보여 주며 “모바일에서는 데이터가 너무 많이 오고, 웹에서는 너무 적게 오네요.”라는 문제를 지적했습니다. GraphQL 쿼리를 작성해 필요한 필드만 요청하자, 동일한 엔드포인트에서 각 기기가 원하는 데이터만 받아갔습니다.</p>
						<p>공개 직후 핀터레스트, 깃허브 같은 서비스가 GraphQL API를 도입했습니다. 프론트엔드 팀은 “기능을 만들 때마다 새 REST 엔드포인트를 기다리지 않아도 된다.”며 백엔드 팀과의 협업이 빨라졌다고 밝혔습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>GraphQL은 단일 엔드포인트에서 <strong>스키마</strong>로 데이터 타입을 정의하고, 클라이언트가 필요한 데이터 구조를 선언형 쿼리로 요청하게 합니다. 덕분에 프론트엔드는 화면에 필요한 조각을 스스로 조합할 수 있고, 백엔드는 리졸버를 통해 데이터 출처를 관리합니다. 이는 API 설계가 “리소스 중심”에서 “그래프 중심”으로 이동했음을 의미하며, BFF(Backend for Frontend) 패턴과 API 게이트웨이 설계에도 영향을 주었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2020-jamstack">
			<article class="event-detail" aria-labelledby="event-2020-jamstack-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2020</p>
					<h2 id="event-2020-jamstack-title">JAMstack와 엣지 함수 확산</h2>
					<p class="event-detail__summary">정적 빌드, CDN 배포, API 조합이 기본 옵션이 되면서 프론트엔드와 백엔드가 느슨하게 결합된 구조가 대중화되었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>제품팀은 Netlify, Vercel 같은 플랫폼에 리포지토리를 연결하고 “main에 머지하면 자동으로 배포됩니다.”라는 알림을 받았습니다. 프론트엔드는 정적 파일로 빌드되어 전 세계 CDN에 퍼지고, 필요한 데이터는 API나 서버리스 함수에서 가져왔습니다.</p>
						<p>엣지 함수가 등장하면서 개발자들은 사용자 위치에 따라 맞춤 콘텐츠를 적용했습니다. “서울 사용자는 이 배너를, 뉴욕 사용자는 저 배너를 보여 줘.” 같은 요구가 코드 몇 줄로 가능해졌습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>JAMstack은 <strong>JavaScript</strong>, <strong>API</strong>, <strong>Markup</strong>의 조합을 강조하며 프론트엔드와 백엔드를 분리 배포하는 방식을 표준처럼 만들었습니다. 백엔드는 인증, 데이터, 비즈니스 로직을 API 형태로 제공하고, 프론트엔드는 정적 자산과 런타임 로직을 맡아 빠른 배포와 확장성을 누릴 수 있게 되었습니다. 이는 마이크로서비스, 엣지 컴퓨팅, 서버리스 워크플로로 이어지고 있습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<script src="assets/js/main.js" defer></script>
	</body>
</html>
