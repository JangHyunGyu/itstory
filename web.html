<!DOCTYPE html>
<html lang="ko">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>ArcherLab IT Story · 웹이 층을 나눈 이유</title>
		<meta name="description" content="정적 문서에서 CGI, Ajax, SPA, 서버리스까지. 웹이 프론트엔드와 백엔드로 나뉘고 다시 협력하게 된 순간을 타임라인으로 살펴봅니다." />
		<meta property="og:title" content="ArcherLab IT Story · Web Layers Timeline" />
		<meta property="og:description" content="WWW 제안부터 서버리스까지, 웹이 정적 문서에서 앱 플랫폼으로 성장한 과정을 읽어 보세요." />
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700;800&family=Space+Grotesk:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500;600&display=swap" rel="stylesheet">
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css">
		<link rel="stylesheet" href="assets/css/style.css">
	</head>
	<body>
		<div class="page">
			<header class="page__header" role="banner">
				<div class="page__header-left">
					<a class="page__brand" href="https://archerlab.dev" target="_blank" rel="noopener">
						<img src="assets/images/archerlab_mini_logo.png" alt="ArcherLab" class="page__brand-logo" loading="lazy">
						<span class="page__brand-label">ArcherLab Chronicle</span>
					</a>
					<nav class="page__topic-nav" aria-label="주제 전환">
						<a href="index.html">홈 허브</a>
						<a href="networks.html">네트워크 연대기</a>
						<a href="computers.html">컴퓨터 연대기</a>
						<a href="web.html" class="is-current">웹 연대기</a>
						<a href="databases.html">데이터베이스 연대기</a>
					</nav>
				</div>
				<nav class="page__nav" aria-label="섹션 탐색">
					<a href="#timeline">연도 보기</a>
					<a href="#sources">참고</a>
				</nav>
			</header>

			<main class="page__main" id="main" role="main">
				<section class="timeline-hero" aria-labelledby="timeline-title">
					<div class="timeline-hero__head">
						<p class="hero__eyebrow">Web Story for Product Builders</p>
						<h1 class="timeline-hero__title" id="timeline-title">정적 문서에서 API와 서버리스까지, 웹이 층을 나눠 성장한 이유를 따라가 보세요</h1>
						<p class="timeline-hero__lede">
							연구소 복도에서 문서를 돌려보던 과학자에게서 시작해, 전 세계 사용자를 상대하는 제품팀까지. 웹은 "파일을 보여 주는 곳"에서 "앱을 실행하는 무대"로 변하며 프론트엔드와 백엔드라는 역할을 만들었습니다.
						</p>
						<p class="timeline-hero__lede">
							연도 버튼을 누르면 정적 페이지, CGI, Ajax, SPA, 서버리스로 이어지는 실험과 그 결과가 다음 세대의 개발 방식을 어떻게 바꿨는지 확인할 수 있습니다.
						</p>
					</div>
				</section>

				<section class="timeline-grid" id="timeline" aria-labelledby="timeline-title" aria-describedby="timeline-instructions">
					<p class="timeline-grid__instructions sr-only" id="timeline-instructions">연도 버튼을 누르면 새 창 없이 팝업 대화 상자가 열리고, 그 자리에서 자세한 이야기를 이어서 읽을 수 있습니다.</p>

					<section class="timeline-group" aria-labelledby="decade-1960 topic-1960">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1960">1968–1986</p>
							<h3 class="timeline-group__topic" id="topic-1960">웹을 가능하게 한 토대</h3>
							<p class="timeline-group__summary">하이퍼텍스트 시연, ARPANET, TCP/IP, DNS, SGML이 등장하며 링크된 문서와 계층화된 네트워크라는 웹의 기반이 갖춰졌습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1968-mother-demo">
								<span class="timeline-event__year">1968</span>
								<span class="timeline-event__label">Mother of All Demos</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1969-arpanet">
								<span class="timeline-event__year">1969</span>
								<span class="timeline-event__label">ARPANET 최초 연결</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1974-tcpip">
								<span class="timeline-event__year">1974</span>
								<span class="timeline-event__label">TCP/IP 설계</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1978-usenet">
								<span class="timeline-event__year">1978</span>
								<span class="timeline-event__label">Usenet 개시</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1980-enquire">
								<span class="timeline-event__year">1980</span>
								<span class="timeline-event__label">ENQUIRE 구축</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1983-flag-day">
								<span class="timeline-event__year">1983</span>
								<span class="timeline-event__label">TCP/IP 전환일</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1984-dns">
								<span class="timeline-event__year">1984</span>
								<span class="timeline-event__label">DNS 도입</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1986-sgml">
								<span class="timeline-event__year">1986</span>
								<span class="timeline-event__label">ISO SGML 표준</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-1990 topic-1990">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1990">1990–1993</p>
							<h3 class="timeline-group__topic" id="topic-1990">정적 문서를 연결한 첫 웹</h3>
							<p class="timeline-group__summary">WWW 제안과 최초의 브라우저·서버 구현이 등장하며 "파일을 요청하고 보여 주는" 정적 구조가 자리 잡았습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1990-www-proposal">
								<span class="timeline-event__year">1990</span>
								<span class="timeline-event__label">WWW 제안</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1991-first-site">
								<span class="timeline-event__year">1991</span>
								<span class="timeline-event__label">첫 웹사이트 공개</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1993-mosaic">
								<span class="timeline-event__year">1993</span>
								<span class="timeline-event__label">Mosaic 공개</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-1990-dynamic topic-1990-dynamic">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-1990-dynamic">1993–1997</p>
							<h3 class="timeline-group__topic" id="topic-1990-dynamic">서버가 문서를 만들어 주기 시작하다</h3>
							<p class="timeline-group__summary">CGI와 JavaScript, PHP, CSS, ASP가 자리 잡으며 서버는 맞춤 HTML을 만들고 브라우저는 즉각적인 상호작용과 표현을 담당하기 시작했습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1993-cgi">
								<span class="timeline-event__year">1993</span>
								<span class="timeline-event__label">CGI 표준화</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1995-javascript">
								<span class="timeline-event__year">1995</span>
								<span class="timeline-event__label">JavaScript 탄생</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1995-php">
								<span class="timeline-event__year">1995</span>
								<span class="timeline-event__label">PHP 도구</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1996-css">
								<span class="timeline-event__year">1996</span>
								<span class="timeline-event__label">CSS 레벨 1 권고안</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1996-asp">
								<span class="timeline-event__year">1996</span>
								<span class="timeline-event__label">Active Server Pages</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-2000 topic-2000">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-2000">1998–2008</p>
							<h3 class="timeline-group__topic" id="topic-2000">브라우저가 움직임을 맡다</h3>
							<p class="timeline-group__summary">HTTP/1.1, XMLHttpRequest, LAMP, Ajax, Chrome/V8이 맞물리며 프론트엔드는 비동기 상호작용과 성능을, 백엔드는 표준화된 서버 구성을 맡았고, 모바일 기기가 새로운 요구를 던졌습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="1999-http11">
								<span class="timeline-event__year">1999</span>
								<span class="timeline-event__label">HTTP/1.1 정식화</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="1999-xmlhttprequest">
								<span class="timeline-event__year">1999</span>
								<span class="timeline-event__label">XMLHttpRequest 등장</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2001-lamp">
								<span class="timeline-event__year">2001</span>
								<span class="timeline-event__label">LAMP 스택 확산</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2005-ajax">
								<span class="timeline-event__year">2005</span>
								<span class="timeline-event__label">Ajax 패턴 확산</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2007-mobile-web">
								<span class="timeline-event__year">2007</span>
								<span class="timeline-event__label">모바일 웹 전환점</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2008-chrome">
								<span class="timeline-event__year">2008</span>
								<span class="timeline-event__label">Chrome &amp; V8 공개</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-2010 topic-2010">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-2010">2009–2016</p>
							<h3 class="timeline-group__topic" id="topic-2010">브라우저가 애플리케이션이 되다</h3>
							<p class="timeline-group__summary">Node.js, SPA 프레임워크, WebSocket이 등장하며 프론트엔드가 애플리케이션 전체를 직접 다루고, 백엔드는 실시간 API 제공자로 역할이 재정의되었습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="2009-node">
								<span class="timeline-event__year">2009</span>
								<span class="timeline-event__label">Node.js 발표</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2010-angularjs">
								<span class="timeline-event__year">2010</span>
								<span class="timeline-event__label">AngularJS 공개</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2011-websocket">
								<span class="timeline-event__year">2011</span>
								<span class="timeline-event__label">WebSocket 표준 확정</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2013-react">
								<span class="timeline-event__year">2013</span>
								<span class="timeline-event__label">React 발표</span>
							</button>
						</div>
					</section>

					<section class="timeline-group" aria-labelledby="decade-2020 topic-2020">
						<header class="timeline-group__head">
							<p class="timeline-group__decade" id="decade-2020">2014–2025</p>
							<h3 class="timeline-group__topic" id="topic-2020">API와 서버리스로 재조합</h3>
							<p class="timeline-group__summary">HTML5, Lambda, HTTP/2, GraphQL, PWA, HTTPS 자동화, WebAssembly, 엣지 런타임, JAMstack이 이어지며 백엔드는 API와 이벤트를, 프론트는 독립 배포와 조합을 맡는 구조가 완성되었습니다.</p>
						</header>
						<div class="timeline-group__list" role="list">
							<button class="timeline-event" type="button" role="listitem" data-event-id="2014-lambda">
								<span class="timeline-event__year">2014</span>
								<span class="timeline-event__label">AWS Lambda 출시</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2014-html5">
								<span class="timeline-event__year">2014</span>
								<span class="timeline-event__label">HTML5 최종 권고</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2015-http2">
								<span class="timeline-event__year">2015</span>
								<span class="timeline-event__label">HTTP/2 표준 채택</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2015-graphql">
								<span class="timeline-event__year">2015</span>
								<span class="timeline-event__label">GraphQL 공개</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2015-lets-encrypt">
								<span class="timeline-event__year">2015</span>
								<span class="timeline-event__label">Let’s Encrypt 런칭</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2016-pwa">
								<span class="timeline-event__year">2016</span>
								<span class="timeline-event__label">PWA 권장 아키텍처</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2017-webassembly">
								<span class="timeline-event__year">2017</span>
								<span class="timeline-event__label">WebAssembly MVP 완료</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2017-cloudflare-workers">
								<span class="timeline-event__year">2017</span>
								<span class="timeline-event__label">Cloudflare Workers</span>
							</button>
							<button class="timeline-event" type="button" role="listitem" data-event-id="2020-jamstack">
								<span class="timeline-event__year">2020</span>
								<span class="timeline-event__label">JAMstack/엣지 확산</span>
							</button>
						</div>
					</section>
				</section>

				<section class="sources" id="sources" aria-labelledby="sources-title">
					<div class="section__head">
						<h2 id="sources-title">참고 자료</h2>
						<p>웹의 구조가 정적 문서에서 애플리케이션 플랫폼으로 바뀐 과정을 기록한 1차 자료와 회고를 모았습니다. 원문을 읽어 보면 각 시대의 개발자들이 어떤 문제를 해결하려 했는지 더 선명합니다.</p>
					</div>
					<ul class="source-list">
						<li><a href="https://dougengelbart.org/content/view/209/448/" target="_blank" rel="noopener">Doug Engelbart Institute · The Mother of All Demos</a></li>
						<li><a href="https://www.netlab.cs.ucla.edu/papers/UCLA_Internet_1969.pdf" target="_blank" rel="noopener">UCLA · Birth of the ARPANET</a></li>
						<li><a href="https://www.rfc-editor.org/rfc/rfc675" target="_blank" rel="noopener">IETF · RFC 675: Specification of Internet Transmission Control Program</a></li>
						<li><a href="https://www.cs.unc.edu/~barman/usenet/" target="_blank" rel="noopener">Usenet Historical Documents · A Brief History of Usenet</a></li>
						<li><a href="https://www.w3.org/History/1980/EnquireFrame.html" target="_blank" rel="noopener">W3C History · ENQUIRE Manual</a></li>
						<li><a href="https://www.livinginternet.com/i/ii_arpanet_flagday.htm" target="_blank" rel="noopener">Living Internet · ARPANET Flag Day</a></li>
						<li><a href="https://www.rfc-editor.org/rfc/rfc1034" target="_blank" rel="noopener">IETF · RFC 1034: Domain Names - Concepts and Facilities</a></li>
						<li><a href="https://www.iso.org/standard/16387.html" target="_blank" rel="noopener">ISO · ISO 8879:1986 Standard Generalized Markup Language</a></li>
						<li><a href="https://www.w3.org/Proposal.html" target="_blank" rel="noopener">Tim Berners-Lee · Information Management: A Proposal</a></li>
						<li><a href="https://www.w3.org/History/19921103-hypertext/hypertext/WWW/TheProject.html" target="_blank" rel="noopener">CERN · World Wide Web Project</a></li>
						<li><a href="https://www.rfc-editor.org/rfc/rfc3875" target="_blank" rel="noopener">NCSA · Common Gateway Interface Specification</a></li>
						<li><a href="https://www.w3.org/TR/CSS1/" target="_blank" rel="noopener">W3C · Cascading Style Sheets Level 1</a></li>
						<li><a href="https://queue.acm.org/detail.cfm?id=1117401" target="_blank" rel="noopener">ACM Queue · Ajax: A New Approach to Web Applications</a></li>
						<li><a href="https://www.rfc-editor.org/rfc/rfc2616" target="_blank" rel="noopener">IETF · RFC 2616: Hypertext Transfer Protocol 1.1</a></li>
						<li><a href="https://www.apple.com/newsroom/2007/01/09Apple-Reinvents-the-Phone-with-iPhone/" target="_blank" rel="noopener">Apple Newsroom · Apple Reinvents the Phone with iPhone</a></li>
						<li><a href="https://www.rfc-editor.org/rfc/rfc6455" target="_blank" rel="noopener">IETF · RFC 6455: The WebSocket Protocol</a></li>
						<li><a href="https://www.rfc-editor.org/rfc/rfc7540" target="_blank" rel="noopener">IETF · RFC 7540: Hypertext Transfer Protocol 2</a></li>
						<li><a href="https://blog.chromium.org/2008/09/google-chrome-now-available-in-beta.html" target="_blank" rel="noopener">Chromium Blog · Google Chrome Beta Announcement</a></li>
						<li><a href="https://www.w3.org/blog/news/archives/4167" target="_blank" rel="noopener">W3C News · HTML5 Is a W3C Recommendation</a></li>
						<li><a href="https://letsencrypt.org/2015/12/03/launching-lets-encrypt.html" target="_blank" rel="noopener">ISRG · Launching Let’s Encrypt</a></li>
						<li><a href="https://developers.google.com/web/progressive-web-apps" target="_blank" rel="noopener">Google Developers · Progressive Web Apps Guide</a></li>
						<li><a href="https://webassembly.org/news/announcing-the-webassembly-mvp/" target="_blank" rel="noopener">WebAssembly.org · Announcing the WebAssembly MVP</a></li>
						<li><a href="https://blog.cloudflare.com/introducing-cloudflare-workers/" target="_blank" rel="noopener">Cloudflare Blog · Introducing Cloudflare Workers</a></li>
						<li><a href="https://aws.amazon.com/blogs/aws/aws-lambda-event-driven-code-in-the-cloud/" target="_blank" rel="noopener">AWS News Blog · AWS Lambda Announcement</a></li>
						<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript" target="_blank" rel="noopener">MDN · A re-introduction to JavaScript</a></li>
						<li><a href="https://nodejs.org/en/about" target="_blank" rel="noopener">Node.js Foundation · About Node.js</a></li>
						<li><a href="https://engineering.fb.com/2015/09/14/core-data/graphql-a-data-query-language/" target="_blank" rel="noopener">Meta Engineering · GraphQL: A Data Query Language</a></li>
					</ul>
				</section>
			</main>

			<footer class="page__footer" role="contentinfo">
				<p>© 2025 ArcherLab · Stories on how the web split and reunited.</p>
				<a class="page__footer-link" href="https://archerlab.dev" target="_blank" rel="noopener">archerlab.dev</a>
			</footer>
		</div>

		<div class="modal" id="event-modal" role="dialog" aria-modal="true" hidden>
			<div class="modal__overlay" data-modal-close></div>
			<div class="modal__window" role="document" tabindex="-1">
				<button class="modal__close" type="button" aria-label="레이어 닫기" data-modal-close>&times;</button>
				<div class="modal__content"></div>
			</div>
		</div>

		<template id="event-1968-mother-demo">
			<article class="event-detail" aria-labelledby="event-1968-mother-demo-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1968</p>
					<h2 id="event-1968-mother-demo-title">Mother of All Demos</h2>
					<p class="event-detail__summary">더글러스 엥겔바트는 마우스, 하이퍼텍스트, 원격 협업을 묶은 시연으로 “링크로 연결된 작업 공간”을 세상에 처음 보여 주었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>샌프란시스코의 컨벤션 센터에서 엥겔바트는 마우스를 움직이며 화면을 가리켰습니다. “여기를 클릭하면 관련 문서로 이동합니다.” 대형 스크린에는 텍스트가 하이라이트되며 다음 노드가 열렸고, 원격지 동료와 화면을 공유해 공동 편집을 시연했습니다.</p>
						<p>관객은 전화 회선을 통한 원격 커서, 하이퍼링크, 실시간 회의 기능을 보며 탄성을 질렀습니다. 이 데모는 “문서가 서로 연결되고, 사람들은 떨어져 있어도 협력한다”는 비전을 현실처럼 체감하게 했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>이 시연은 <strong>하이퍼텍스트</strong>, <strong>인풋 장치</strong>, <strong>콜라보레이션</strong> 개념을 한 번에 보여 주며 웹의 사용자 경험을 예감하게 만들었습니다. 이후 프론트엔드는 링크를 따라 탐색하는 UI를 기본으로 삼게 되었고, 백엔드는 여러 사용자가 공유하는 정보를 저장하고 동기화하는 역할로 발전할 토대를 마련했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1969-arpanet">
			<article class="event-detail" aria-labelledby="event-1969-arpanet-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1969</p>
					<h2 id="event-1969-arpanet-title">ARPANET 최초 연결</h2>
					<p class="event-detail__summary">캘리포니아와 스탠퍼드 사이에 ‘LO’ 문자가 전송되며 패킷 스위칭 네트워크가 현실로 등장했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>UCLA의 연구자 찰리는 IMP 단말 앞에서 “LOGIN을 보내 보죠.”라고 말했습니다. 하지만 세 번째 글자를 입력하기도 전에 연결이 끊어졌습니다. 그럼에도 과학자들은 “우리가 방금 원격 컴퓨터에 메시지를 보냈다”는 사실에 환호했습니다.</p>
						<p>수주 후 네트워크는 유타, 산타바바라까지 확장되었고, 대학과 연구소는 서로의 컴퓨터 자원을 공유하며 협력하기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>ARPANET은 패킷 스위칭과 분산 노드 설계를 통해 서버가 끊어져도 네트워크가 유지될 수 있음을 입증했습니다. 후일 웹 서버가 전 세계에 흩어져 있어도 하나의 공간처럼 동작할 수 있었던 이유가 여기서 비롯되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1974-tcpip">
			<article class="event-detail" aria-labelledby="event-1974-tcpip-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1974</p>
					<h2 id="event-1974-tcpip-title">TCP/IP 설계</h2>
					<p class="event-detail__summary">빈튼 서프와 밥 칸은 ‘패킷 네트워크의 상호연결’을 발표하며 오늘날 인터넷 계층 모델을 정의했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>서프와 칸은 논문에서 “다른 네트워크가 끊김 없이 대화를 이어가려면 공통 전송 계층이 필요합니다.”라고 주장했습니다. TCP는 신뢰성을, IP는 주소 지정과 라우팅을 담당하며 여러 네트워크를 하나로 묶는 구조를 제안했습니다.</p>
						<p>군사·학술 프로젝트들은 곧 이 설계를 시험했고, 1970년대 말에는 다양한 하드웨어가 TCP/IP를 구현하기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>TCP/IP의 계층화 원칙은 이후 HTTP와 HTML이 ‘응용 계층’에서 독립적으로 진화할 수 있게 만들었습니다. 백엔드는 IP 위에서 서버를 운영하고, 프론트엔드는 TCP 연결을 통해 안정적으로 콘텐츠를 받아올 수 있게 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1978-usenet">
			<article class="event-detail" aria-labelledby="event-1978-usenet-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1978</p>
					<h2 id="event-1978-usenet-title">Usenet 개시</h2>
					<p class="event-detail__summary">두 대학이 전화선으로 게시판 메시지를 교환하며 서버 간 분산 협업의 가능성을 입증했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>듀크 대학의 짐과 톰은 UUCP를 이용해 밤마다 뉴스 그룹 데이터를 주고받았습니다. “잠자는 동안에도 새 글이 복제되네요.” 그들은 <code>net.general</code>에 첫 글을 남기며 다른 학교를 초대했습니다.</p>
						<p>곧 수십 개 기관이 참여해 주제별 그룹이 생겨났고, 전용 서버가 메시지를 받아 보관하고 사용자는 로컬 클라이언트로 읽고 답글을 달았습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Usenet은 <strong>스토어-앤드-포워드</strong>와 <strong>클라이언트/서버 분리</strong>를 실험했습니다. 서버는 데이터를 저장·전달하는 백엔드로, 사용자는 단말에서 콘텐츠를 읽고 작성하는 프론트엔드로 역할이 나뉘는 모델의 선례가 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1980-enquire">
			<article class="event-detail" aria-labelledby="event-1980-enquire-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1980</p>
					<h2 id="event-1980-enquire-title">ENQUIRE 구축</h2>
					<p class="event-detail__summary">팀 버너스-리는 CERN의 실험 정보를 연결하는 개인 하이퍼텍스트 시스템을 만들며 웹 설계의 씨앗을 심었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>버너스-리는 “연구 장비와 사람들의 관계를 기록할 방법이 필요하다”는 생각에 ENQUIRE 프로그램을 개발했습니다. 각 노드는 질문과 답 형식으로 연결되었고, 사용자는 링크를 따라 관련 문서를 탐색할 수 있었습니다.</p>
						<p>그는 “모든 문서는 서로 연결되어야 기억에 남는다”는 메모를 남겼고, 이후 WWW 제안서에서 ENQUIRE의 아이디어가 그대로 발전했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>ENQUIRE는 <strong>노드와 링크</strong>, <strong>문서의 메타데이터</strong>를 다루는 방법을 실험했습니다. 프론트엔드는 사용자가 원하는 정보를 맥락과 함께 보여주는 구조를, 백엔드는 링크 그래프를 유지하는 저장소라는 개념을 구체화했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1983-flag-day">
			<article class="event-detail" aria-labelledby="event-1983-flag-day-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1983</p>
					<h2 id="event-1983-flag-day-title">TCP/IP 전환일</h2>
					<p class="event-detail__summary">1983년 1월 1일, ARPANET은 일괄적으로 TCP/IP로 갈아타며 인터넷의 공통 언어를 확립했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>미 국방성은 모든 ARPANET 호스트에게 “1983년 새해에 TCP/IP 스택을 가동하라”는 지침을 보냈습니다. 운영자들은 밤새 코드를 배포했고, 전환일 아침에는 네트워크가 새 프로토콜로 정상 동작했습니다.</p>
						<p>이후 다른 연구망도 TCP/IP를 채택했고, 상업적 네트워크 역시 같은 표준을 쓰기 시작했습니다. 세계가 하나의 인터넷으로 묶이기 시작한 순간이었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Flag Day는 상호 운용성의 승리였습니다. 백엔드는 TCP/IP 스택 위에서 동작하면 전 세계 어디와도 통신할 수 있게 되었고, 프론트엔드는 표준화된 주소 체계를 이용해 어떤 서버와도 연결을 시도할 수 있게 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1984-dns">
			<article class="event-detail" aria-labelledby="event-1984-dns-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1984</p>
					<h2 id="event-1984-dns-title">DNS 도입</h2>
					<p class="event-detail__summary">도메인 이름 시스템이 등장해 사람 친화적인 주소와 계층적 네임스페이스가 정착했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>폴 모카페트리스는 “호스트 파일을 계속 수동으로 배포할 수는 없습니다.”라며 DNS 설계를 발표했습니다. 루트 서버와 권한 있는 네임서버가 계층적으로 응답을 위임하는 구조였고, <code>.com</code>, <code>.edu</code> 같은 최상위 도메인이 정의되었습니다.</p>
						<p>네트워크 관리자는 새 서버를 추가할 때 IP 주소 대신 도메인 이름을 등록했고, 사용자들은 기억하기 쉬운 이름으로 원격 자원에 접속하게 되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>DNS는 URL과 URI 개념이 등장할 수 있는 토대였습니다. 백엔드는 서비스를 도메인 이름으로 노출하고, 프론트엔드는 하드코딩된 IP 대신 인간이 읽을 수 있는 주소를 사용하며 하이퍼링크를 작성할 수 있게 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1986-sgml">
			<article class="event-detail" aria-labelledby="event-1986-sgml-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1986</p>
					<h2 id="event-1986-sgml-title">ISO SGML 표준</h2>
					<p class="event-detail__summary">국제 표준 SGML은 문서 구조를 태그로 정의하는 방식을 정리하며 HTML의 직계 조상이 되었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>ISO는 SGML(ISO 8879)을 채택하며 “문서를 텍스트와 구조로 분리해 표현하자”는 원칙을 정했습니다. 출판사와 정부 기관은 표준화된 태그 세트를 사용해 문서를 교환하기 시작했습니다.</p>
						<p>젊은 개발자들은 태그 기반 문서가 다른 시스템으로 전송되어도 의미를 유지하는 것을 보며, 플랫폼 독립적인 표현 방식의 필요성을 인식했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>SGML은 HTML과 XML의 설계 철학을 제공합니다. 프론트엔드는 구조화된 마크업을 렌더링해 표현을 담당하고, 백엔드는 태그를 출력하거나 변환하며 데이터를 관리하는 역할로 나뉘는 기반을 마련했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1990-www-proposal">
			<article class="event-detail" aria-labelledby="event-1990-www-proposal-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1990</p>
					<h2 id="event-1990-www-proposal-title">WWW 제안 · 팀 버너스-리</h2>
					<p class="event-detail__summary">CERN 연구원들은 “문서를 공유하려면 메일을 또 보내야 하잖아요.”라고 불평했습니다. 팀 버너스-리는 하이퍼텍스트와 인터넷을 결합한 제안을 작성했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>연구소 복도에서 팀 버너스-리는 노트북에 “Information Management: A Proposal”이라는 제목을 쓰고, 메모를 넘겨 보던 동료에게 “이 링크 개념을 쓰면 문서를 서로 가리킬 수 있어요.”라고 설명했습니다. 동료는 “URL은 어떻게 생겼죠?”라고 묻자, 팀은 종이에 <code>http://</code>를 적으며 서버가 파일을 찾아 돌려주면 브라우저가 화면으로 보여 준다고 답했습니다.</p>
						<p>시스템 관리자는 시험용 NeXT 머신을 연결해 주었고, 팀은 HTML, HTTP, 첫 웹서버인 CERN httpd를 직접 구현했습니다. 연구자들은 “이제 메일 첨부 대신 링크를 보내면 되겠네.”라며 새로운 도구를 써 보기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>제안서의 핵심은 <strong>URI</strong>, <strong>HTTP</strong>, <strong>HTML</strong>이라는 세 가지 규격이었습니다. 파일을 요청하는 규칙과 문서를 구조화하는 언어, 그리고 문서를 식별하는 주소 체계를 함께 정의하면서, 누구나 서버에 파일을 올리고 동일한 브라우저로 읽을 수 있는 정적 웹이 태어났습니다. 이 단계에서 서버는 단순히 파일을 돌려주는 역할만 수행했고, 프론트엔드와 백엔드의 구분은 아직 필요하지 않았습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1991-first-site">
			<article class="event-detail" aria-labelledby="event-1991-first-site-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1991</p>
					<h2 id="event-1991-first-site-title">첫 웹사이트 공개</h2>
					<p class="event-detail__summary">“인터넷에 이런 문서를 올리고 싶다면 이렇게 하세요.”라는 안내문이 세계 최초의 웹페이지였습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>1991년 8월, 팀 버너스-리는 CERN의 NeXT 서버에 <code>info.cern.ch</code>라는 주소를 열어 “World Wide Web Project”라는 제목의 페이지를 올렸습니다. 페이지 디자인은 검은 글자와 파란 링크뿐이었고, “새 문서를 만들려면 HTML 태그를 이렇게 쓰세요.”라는 설명과 함께 샘플 코드가 적혀 있었습니다.</p>
						<p>전화 회선으로 접속한 연구자들은 텍스트 브라우저에서 링크를 눌러 보며 “이제 문서 사이를 화살표 키로 왔다 갔다 할 수 있네.”라고 감탄했습니다. 몇 주 뒤, 외부 대학 연구실에서도 같은 지침을 따라 웹서버를 설치하기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>첫 웹사이트는 튜토리얼이자 문서 표준이었습니다. 서버 설정 방법, HTML 태그 목록, 링크 작성법을 한 페이지에서 확인할 수 있었기 때문에 “웹”이라는 개념은 매뉴얼을 읽을 줄 아는 개발자라면 누구나 따라 할 수 있는 열린 시스템으로 자리 잡았습니다. 여전히 서버는 디스크에 있는 파일을 그대로 전달하는 역할만 했고, 브라우저는 해당 파일을 읽어 화면에 표시했습니다. 이 단순함 덕분에 웹은 빠르게 퍼질 수 있었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1993-mosaic">
			<article class="event-detail" aria-labelledby="event-1993-mosaic-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1993</p>
					<h2 id="event-1993-mosaic-title">Mosaic 브라우저 공개</h2>
					<p class="event-detail__summary">UI가 있는 브라우저가 등장하자 연구소 밖 사용자도 “링크를 클릭하는 경험”을 처음 맞이했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>NCSA의 학생들은 그래픽 버튼과 이미지가 들어간 새 브라우저를 시연하며 “여기, 직접 클릭해 보세요.”라고 관객에게 마우스를 건넸습니다. 링크가 파란색으로 표시되고 같은 창에서 다른 문서가 열리자 모두가 감탄했습니다.</p>
						<p>신문 기자는 “웹이란 게 이렇게 생겼나요?”라고 묻고는 기사에 Mosaic 스크린샷을 실었습니다. 곧 대학과 기업에서도 Mosaic을 설치해 정적 페이지를 게시하기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Mosaic은 이미지와 텍스트를 한 화면에 보여 주는 렌더링 엔진, 마우스 중심 UI, 북마크 기능을 제공하며 웹을 대중화했습니다. 하지만 여전히 서버는 정적 파일만 전달했습니다. 프론트엔드는 HTML을 해석해 화면을 꾸미는 역할만 담당했고, 맞춤형 콘텐츠를 제공하려면 새로운 방식이 필요하다는 인식이 생겨났습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1993-cgi">
			<article class="event-detail" aria-labelledby="event-1993-cgi-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1993</p>
					<h2 id="event-1993-cgi-title">CGI 표준화</h2>
					<p class="event-detail__summary">서버가 외부 프로그램을 실행해 HTML을 만들어 주는 인터페이스가 정의되면서 “백엔드 로직”이라는 개념이 태어났습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>NCSA httpd 팀은 “게스트북에 글을 남기면 바로 반영하도록 해 달라”는 요청을 받고 회의실에 모였습니다. 개발자 수지는 “요청이 들어오면 Perl 스크립트를 실행해서 HTML을 만들어 돌려주죠.”라고 제안했습니다.</p>
						<p>그 결과가 Common Gateway Interface였습니다. 방문자가 폼을 제출하면 서버가 스크립트를 실행해 데이터베이스에 기록하고, 그 결과를 HTML로 출력했습니다. 연구자들은 “파일이 아니라 프로그램이 응답을 만든다”는 사실에 놀랐습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>CGI는 환경 변수와 표준 입력/출력을 통해 웹서버와 프로그램이 데이터를 주고받는 규칙을 정의했습니다. 이는 서버가 사용자별, 요청별로 다른 결과를 반환할 수 있는 토대를 마련했고, 프론트엔드와 구분되는 서버측 로직(백엔드)의 첫 형태가 되었습니다. 다만 매 요청마다 프로세스를 새로 띄우기 때문에 성능 부담이 컸습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1995-javascript">
			<article class="event-detail" aria-labelledby="event-1995-javascript-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1995</p>
					<h2 id="event-1995-javascript-title">JavaScript 탄생</h2>
					<p class="event-detail__summary">브라우저가 단순 문서를 넘어서 상호작용을 담당할 수 있도록 ‘브라우저용 스크립트 언어’가 만들어졌습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Netscape의 개발자 브렌던 아이크는 “사용자가 버튼을 클릭했을 때 서버까지 갔다가 돌아오는 시간을 줄이고 싶다.”는 요구를 듣고 10일 만에 새로운 스크립트 언어를 작성했습니다. 마케팅 팀은 이를 “LiveScript”라 불렀지만, 곧 당시 인기 언어였던 자바의 이름을 빌린 “JavaScript”로 알려지게 되었습니다.</p>
						<p>브라우저 시연에서 개발자들은 “텍스트 상자에 이름을 입력하고 나면 바로 인사말이 바뀌어요!”라고 외쳤습니다. 사용자의 입력을 즉시 검증하거나, 이미지 롤오버를 구현하는 등의 작은 상호작용이 가능해졌고, 프론트엔드는 단순한 HTML 표시에 머무르지 않게 되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>JavaScript는 브라우저 안에서 실행되는 가벼운 언어로 시작했지만, <strong>이벤트 루프</strong>와 <strong>DOM 조작</strong>이라는 개념을 소개하며 프론트엔드 개발을 프로그래밍의 한 분야로 만들었습니다. 서버가 모든 로직을 담당하던 시대에서 브라우저가 “즉각적인 반응”을 담당하게 되자, 프론트엔드는 사용자 경험을, 백엔드는 데이터와 비즈니스 로직을 맡는 구조로 서서히 분리되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1995-php">
			<article class="event-detail" aria-labelledby="event-1995-php-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1995</p>
					<h2 id="event-1995-php-title">PHP 도구의 공개</h2>
					<p class="event-detail__summary">라스무스 러도프는 “웹 페이지에서 내 이력서를 동적으로 관리해 보고 싶다”라며 HTML 안에 직접 코드를 끼워 넣을 수 있는 도구를 배포했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>라스무스는 개인 홈페이지 방문 통계를 보기 위해 Perl 스크립트를 작성했지만 유지보수가 번거로웠습니다. 그래서 HTML에 <code>&lt;?php&nbsp;?&gt;</code> 블록을 넣어 바로 DB에 연결하고 결과를 출력하는 방식을 만들었습니다. 커뮤니티 게시판에는 “폼 검증이 한 줄로 끝나요!” 같은 댓글이 쏟아졌습니다.</p>
						<p>웹마스터들은 게시판과 쇼핑몰을 만들며 PHP를 확산시켰고, 서버는 요청마다 PHP 인터프리터를 호출해 HTML을 즉석에서 생성했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>PHP는 템플릿과 로직을 한 파일에 섞어 쓸 수 있게 해 초기 웹 개발을 빠르게 했습니다. 이는 서버 측 코드를 유지하기 위한 프레임워크, 템플릿 엔진, MVC 개념이 등장하는 토대로 이어졌습니다. 백엔드는 데이터베이스 연결, 인증, 세션 관리를 맡고 프론트엔드는 생성된 HTML을 렌더링하는 역할로 나뉘기 시작했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1996-css">
			<article class="event-detail" aria-labelledby="event-1996-css-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1996</p>
					<h2 id="event-1996-css-title">CSS 레벨 1 권고안</h2>
					<p class="event-detail__summary">HTML은 구조를, CSS는 표현을 담당하도록 W3C가 첫 공식 스타일시트 권고안을 발표했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>보스턴에서 열린 W3C 회의에서 하콘 비움 리와 베르트 보스는 프로젝터에 “HTML은 문서를 설명하고, CSS는 화면을 꾸밉니다.”라는 슬라이드를 띄웠습니다. 참석자들은 <code>h1 { color: navy; }</code> 같은 구문으로 폰트와 여백을 조정하는 시연을 지켜봤습니다.</p>
						<p>브라우저 벤더들은 얼마 지나지 않아 프리뷰 버전에 CSS 파서를 탑재했고, 웹 디자이너들은 “테이블 대신 스타일시트를 쓰자”는 캠페인을 벌이며 레이아웃 실험을 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>CSS 레벨 1은 <strong>콘텐츠와 표현의 분리</strong>라는 원칙을 강제했습니다. 프론트엔드는 HTML 문서의 구조를 유지한 채 CSS로 테마를 적용할 수 있게 되었고, 백엔드는 HTML 생성 로직에 집중할 수 있었습니다. 이후 박스 모델, 미디어 쿼리 같은 확장이 이어지며 프론트엔드가 UX와 접근성 전략을 주도하게 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1996-asp">
			<article class="event-detail" aria-labelledby="event-1996-asp-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1996</p>
					<h2 id="event-1996-asp-title">Active Server Pages 도입</h2>
					<p class="event-detail__summary">마이크로소프트는 IIS에 서버 스크립트를 내장해 기업용 웹 애플리케이션 개발을 지원했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>컨설팅 기업의 프로젝트 룸에서 PM은 “사내 포털을 웹으로 옮겨야 합니다.”라고 말했습니다. 개발자들은 VBScript와 JScript를 HTML에 섞어 쓰며 주문, 재고, 권한 관리를 구현했습니다. 페이지를 저장하면 IIS가 자동으로 스크립트를 실행해 결과를 돌려줬습니다.</p>
						<p>IT 부서는 “윈도우 서버와 SQL Server를 묶어 배포할 수 있으니 편하네요.”라고 평가했습니다. 기업 웹 애플리케이션이 백엔드 로직 위주로 성장하기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>ASP는 세션 관리, 데이터베이스 연결, 컴포넌트 객체 모델(COM) 연동을 제공해 백엔드가 비즈니스 로직과 상태를 책임지는 구조를 공고히 했습니다. 이 시기부터 프론트엔드는 서버가 보낸 HTML과 최소한의 JavaScript를 담당했고, “서버 코드는 백엔드, 브라우저 코드는 프론트엔드”라는 용어가 실무에서 쓰이기 시작했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1999-http11">
			<article class="event-detail" aria-labelledby="event-1999-http11-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1999</p>
					<h2 id="event-1999-http11-title">HTTP/1.1 정식화</h2>
					<p class="event-detail__summary">RFC 2616이 발표되면서 지속 연결, 호스트 헤더, 캐시 규칙이 표준이 되어 대규모 웹서비스의 토대가 되었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>인터넷 엔지니어링 태스크포스 초안 회의에서 로이 필딩은 “매 요청마다 TCP를 다시 열면 너무 느립니다.”라며 <code>Connection: keep-alive</code> 확장을 설명했습니다. 호스트 이름만으로 가상 호스팅을 구분하는 <code>Host</code> 헤더도 함께 소개했습니다.</p>
						<p>웹호스팅 업체들은 곧 “하나의 IP로 여러 도메인을 서비스할 수 있다”는 장점을 내세웠고, 브라우저는 HTTP/1.1 기본 동작을 채택했습니다. 콘텐츠 제공 네트워크는 캐시 제어 정책을 기반으로 전 세계에 파일을 분산하기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>HTTP/1.1은 <strong>지속 연결</strong>, <strong>청크 전송</strong>, <strong>세밀한 캐시 헤더</strong>를 정리해 백엔드가 연결 자원을 효율적으로 사용할 수 있게 했습니다. 프론트엔드는 더 빠른 응답을 얻을 수 있었고, REST 스타일 아키텍처와 CDN이 확산되는 기반이 마련되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-1999-xmlhttprequest">
			<article class="event-detail" aria-labelledby="event-1999-xmlhttprequest-title">
				<header class="event-detail__header">
					<p class="event-detail__year">1999</p>
					<h2 id="event-1999-xmlhttprequest-title">XMLHttpRequest 등장</h2>
					<p class="event-detail__summary">브라우저가 페이지를 새로고침하지 않고도 서버와 데이터를 주고받을 수 있는 숨은 문이 열렸습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>마이크로소프트 Outlook Web Access 팀은 웹메일을 데스크톱 앱처럼 만들고 싶었습니다. 개발자 리나는 “프레임을 갈아치우지 말고 비동기로 데이터를 가져오자.”라며 <code>XMLHttpRequest</code> 객체를 만들었습니다. 버튼을 눌렀는데도 화면이 깜박이지 않자 사용자들은 놀랐습니다.</p>
						<p>다른 브라우저들도 비슷한 API를 도입했고, 프론트엔드는 화면을 유지한 채 서버에서 JSON이나 XML을 받아 UI를 갱신하기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>XMLHttpRequest는 HTTP 요청을 자바스크립트로 직접 만들 수 있게 하여 브라우저가 단순 렌더러를 넘어 데이터 흐름의 주체가 되도록 했습니다. 프론트엔드는 Ajax 호출을 통해 더 많은 로직을 가져왔고, 백엔드는 템플릿 대신 JSON 등의 데이터를 반환하는 역할을 맡기 시작했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2001-lamp">
			<article class="event-detail" aria-labelledby="event-2001-lamp-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2001</p>
					<h2 id="event-2001-lamp-title">LAMP 스택 확산</h2>
					<p class="event-detail__summary">리눅스, 아파치, MySQL, PHP가 “한 세트”로 엮이며 웹서비스 구축이 공식 메뉴처럼 정리되었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>잡지 <em>PC Magazine</em>은 2001년 “LAMP(Linux, Apache, MySQL, PHP)는 저렴하게도 강력하다”라는 기사로 네 가지 오픈소스 조합을 소개했습니다. 스타트업 창업자들은 “이 네 가지만 설치하면 게시판과 쇼핑몰을 만들 수 있다네.”라고 서로 링크를 공유했습니다.</p>
						<p>호스팅 업체들은 “월 20달러에 LAMP 환경 제공” 같은 상품을 내놓았고, 개발자들은 템플릿 엔진과 ORM을 곁들인 CMS(WordPress, phpBB 등)를 배포했습니다. 백엔드는 데이터베이스와 서버 코드를 맡고, 프론트엔드는 PHP가 만들어 준 HTML과 JavaScript를 다루는 협업 모델이 빠르게 확산되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>LAMP 스택은 웹 개발을 <strong>레이어</strong>로 바라보는 사고방식을 정착시켰습니다. 운영체제(Linux), 웹서버(Apache), 데이터베이스(MySQL), 서버 스크립트(PHP)가 역할을 나눈 덕분에 팀마다 “어디까지가 프론트이고 어디부터가 백엔드인가”를 명확히 나눌 수 있었습니다. 이러한 구성이 이후 Ruby on Rails, Django, Spring 같은 프레임워크 설계에도 그대로 영향을 끼쳤습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2005-ajax">
			<article class="event-detail" aria-labelledby="event-2005-ajax-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2005</p>
					<h2 id="event-2005-ajax-title">Ajax 패턴 확산</h2>
					<p class="event-detail__summary">구글 지도와 지메일이 “페이지 전환 없는 상호작용”을 대중에게 보여 주며 프론트엔드 중심 개발이 부상했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>2005년, 사용자는 구글 지도에서 마우스로 지도를 끌다가 놀랐습니다. “페이지가 새로고침되지 않네요!” 개발 팀은 백엔드에 데이터를 요청하되, 브라우저에서 JavaScript로 화면을 계속 유지했습니다.</p>
						<p>“Ajax”라는 용어가 만들어지자 각종 블로그와 컨퍼런스에서 이 패턴을 소개했습니다. 개발자들은 프론트엔드에 더 많은 상태 관리와 렌더링 로직을 두기 시작했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Ajax는 비동기 요청, JSON/ XML 응답, DOM 조작을 조합한 패턴의 이름이 되었습니다. 서버는 <strong>데이터 API</strong>를 제공하고, 프론트엔드는 사용자의 상호작용을 즉시 반영하는 역할로 진화했습니다. 이 흐름은 “리소스를 URL로 표현하고 HTTP 메서드로 조작한다”는 REST 설계 원칙과 맞물려, 백엔드가 데이터 규격과 인증·확장성에 집중하고 프론트엔드는 상태 관리와 UI 구축을 담당하는 분업 구조를 뚜렷하게 만들었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2007-mobile-web">
			<article class="event-detail" aria-labelledby="event-2007-mobile-web-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2007</p>
					<h2 id="event-2007-mobile-web-title">모바일 웹 전환점</h2>
					<p class="event-detail__summary">아이폰과 풀 브라우저가 등장하며 “손안의 웹”을 위한 반응형 레이아웃과 경량 API 수요가 폭발했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>2007년 1월, 스티브 잡스는 “손가락으로 웹을 탐색하세요.”라며 아이폰을 공개했습니다. Safari 모바일은 데스크톱 사이트를 축소 렌더링했지만 확대와 스크롤이 부드럽게 이어졌습니다.</p>
						<p>제품팀은 곧 “3G 네트워크에서도 빠르게 로딩되게 만들어야 해요.”라는 요구를 받았습니다. Yahoo!와 Google은 모바일용 경량 API를 별도로 제공했고, 2010년에는 Ethan Marcotte가 반응형 웹 디자인을 제안하며 하나의 프론트엔드가 다양한 기기와 협력하는 시대가 열렸습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>모바일 웹의 부상은 프론트엔드가 <strong>미디어 쿼리</strong>와 터치 UI를 본격적으로 도입하게 만들었고, 백엔드는 REST·JSON API, 이미지 최적화, 캐시 전략으로 응답 크기를 줄이는 데 집중했습니다. 이 변화는 이후 네이티브 앱과 웹앱이 동일한 백엔드 API를 공유하는 멀티채널 아키텍처의 출발점이 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2008-chrome">
			<article class="event-detail" aria-labelledby="event-2008-chrome-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2008</p>
					<h2 id="event-2008-chrome-title">Google Chrome &amp; V8 공개</h2>
					<p class="event-detail__summary">구글은 크롬과 V8 엔진을 공개하며 자바스크립트 성능 전쟁을 촉발했고, 웹앱이 데스크톱을 대체할 수 있다는 기대를 만들었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>2008년 9월, 구글은 만화 형식 브랜딩으로 새 브라우저를 발표했습니다. 런칭 이벤트에서 개발자들은 “탭마다 별도 프로세스를 돌리고, V8이 자바스크립트를 JIT 컴파일합니다.”라고 소개했습니다.</p>
						<p>개발자들은 곧 Gmail, Google Docs, Wave 같은 대규모 앱을 시연하며 “브라우저도 복잡한 애플리케이션을 거뜬히 처리한다”는 메시지를 전했습니다. 경쟁 브라우저들도 엔진을 최적화하며 속도 경쟁이 본격화됐습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>V8은 <strong>JIT 컴파일</strong>과 <strong>가비지 컬렉션 최적화</strong>로 자바스크립트 속도를 대폭 향상했습니다. 프론트엔드는 복잡한 상태 관리, 실시간 협업, 3D 렌더링을 브라우저에서 직접 수행하게 되었고, 백엔드는 REST/JSON API와 WebSocket을 통해 가벼운 데이터 전달과 이벤트 중심 설계에 집중했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2009-node">
			<article class="event-detail" aria-labelledby="event-2009-node-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2009</p>
					<h2 id="event-2009-node-title">Node.js 발표</h2>
					<p class="event-detail__summary">자바스크립트가 브라우저를 넘어 서버에서도 실행되면서 “한 언어로 프론트와 백을 잇자”는 흐름이 커졌습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>JSConf 2009 무대에서 라이언 달은 “파일 업로드가 끝날 때까지 스레드를 붙잡고 있을 필요는 없습니다.”라고 말하며 Node.js를 소개했습니다. 시연에서 수천 개의 동시 연결을 처리하는 서버가 간단한 자바스크립트 코드 몇 줄로 구현되자 관객이 환호했습니다.</p>
						<p>개발자들은 곧 “프론트엔드 코드와 같은 언어로 API 서버를 만들 수 있네.”라고 말하며 Express 같은 프레임워크를 만들었습니다. JSON을 중심으로 한 데이터 교환이 자연스러워지고, 빌드 도구와 패키지 생태계(npm)가 폭발적으로 성장했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>Node.js는 이벤트 루프 기반의 논블로킹 I/O를 제공해 실시간 채팅, 스트리밍, 협업 편집처럼 빠른 응답이 필요한 서비스를 쉽게 만들도록 돕습니다. 프론트엔드와 백엔드가 같은 언어를 공유하면서 코드 재사용과 팀 협업도 쉬워졌으며, “풀스택 자바스크립트”라는 개념이 실무에 뿌리내렸습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2010-angularjs">
			<article class="event-detail" aria-labelledby="event-2010-angularjs-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2010</p>
					<h2 id="event-2010-angularjs-title">AngularJS 공개</h2>
					<p class="event-detail__summary">구글은 “브라우저 안에서 MVC를 구현하자”라며 양방향 데이터 바인딩과 템플릿 기능을 제공했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>개발자 미로슬라브는 “HTML을 앱처럼 다뤄 보자”고 결심하고 AngularJS를 오픈 소스로 공개했습니다. 폼을 조작하면 화면이 즉시 갱신되고, 컨트롤러가 데이터를 관리했습니다.</p>
						<p>초기 스타트업과 대규모 기업 모두 AngularJS로 대시보드, 관리자 도구를 만들며 브라우저가 애플리케이션 런타임이 될 수 있음을 체감했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>AngularJS는 프론트엔드가 라우팅, 템플릿, 상태 관리를 스스로 처리하도록 만들었습니다. 이로써 백엔드는 JSON API 제공자 역할로 더 선명해졌고, CLI와 빌드 시스템 같은 프론트엔드 도구 체인이 발전하는 계기가 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2011-websocket">
			<article class="event-detail" aria-labelledby="event-2011-websocket-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2011</p>
					<h2 id="event-2011-websocket-title">WebSocket 표준 확정</h2>
					<p class="event-detail__summary">RFC 6455가 승인되면서 브라우저와 서버가 하나의 연결로 양방향 실시간 통신을 할 수 있게 되었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>IETF 회의에서 이안 힉슨은 브라우저 개발자들에게 “폴링을 멈추고 진짜 양방향 채널을 쓰세요.”라고 말하며 WebSocket 핸드셰이크를 시연했습니다. 크롬 개발자도구에 서버가 즉시 메시지를 밀어 주는 화면이 나타나자 청중이 박수쳤습니다.</p>
						<p>트레이딩 데스크, 게임 스튜디오, 채팅 서비스는 즉시 프로토타입을 만들었습니다. GitHub는 협업 알림을 WebSocket으로 전환했고, Slack은 팀 메시지 스트림을 유지하는 기반으로 채택했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>WebSocket은 HTTP 업그레이드로 연결을 연 뒤 프레임 기반 메시지를 주고받습니다. 프론트엔드는 서버 푸시를 받아 UI를 실시간으로 갱신하고, 백엔드는 상태 동기화를 위한 이벤트 루프와 메시지 브로커를 도입했습니다. 이는 이후 Socket.IO, SignalR, GraphQL Subscriptions 같은 실시간 계층을 낳았습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2013-react">
			<article class="event-detail" aria-labelledby="event-2013-react-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2013</p>
					<h2 id="event-2013-react-title">React 발표</h2>
					<p class="event-detail__summary">페이스북은 “상태가 변할 때마다 UI를 다시 선언하자”라며 컴포넌트 중심 접근을 소개했습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>JSConf 무대에서 페이스북 엔지니어 조던은 “DOM을 직접 건드리는 것보다 컴포넌트를 선언하세요.”라고 이야기했습니다. Virtual DOM 개념이 발표되자 관객들은 “브라우저가 느려지지 않을까요?”라고 물었지만, 시연은 부드럽게 동작했습니다.</p>
						<p>React는 금세 스타트업과 대규모 서비스에 채택되었고, 프론트엔드 팀은 상태 관리, 빌드 파이프라인, 테스트 도구를 포함한 독립된 조직으로 성장했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>컴포넌트 기반 개발은 UI를 재사용 가능한 모듈로 나누고, 서버와의 통신을 <strong>API 호출</strong>에 집중시키는 아키텍처를 촉진했습니다. React, Vue, Svelte 같은 프레임워크가 뒤이어 등장하면서 프론트엔드는 자체 라우팅, 상태, 렌더링 파이프라인을 갖춘 완전한 애플리케이션 계층으로 자리 잡았습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2014-lambda">
			<article class="event-detail" aria-labelledby="event-2014-lambda-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2014</p>
					<h2 id="event-2014-lambda-title">AWS Lambda 출시</h2>
					<p class="event-detail__summary">“서버를 직접 관리하지 않고 코드를 올려 실행하자”는 아이디어가 실 서비스로 제공되었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>re:Invent 무대에서 AWS는 파일 업로드나 이벤트에 반응해 코드를 실행하는 Lambda를 발표했습니다. 개발자 앨리스는 “인증 웹훅을 처리하는 데 서버가 필요 없네요.”라고 감탄했습니다. 콘솔에서 함수를 저장하자 즉시 API Gateway와 연결되어 동작했습니다.</p>
						<p>스타트업들은 로그인, 알림, 이미지 처리 등을 Lambda로 구현하며 운영 부담을 줄였습니다. 백엔드는 점점 작은 함수와 이벤트를 중심으로 재편되었습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>서버리스 모델은 확장성과 비용을 자동으로 관리해 주어 백엔드가 인프라 대신 비즈니스 로직에 집중하게 만들었습니다. 더 이상 “주말 트래픽을 대비해 서버를 몇 대 더 살지” 고민할 필요가 없었고, 함수별로 과금되기 때문에 실험용 기능을 가볍게 배포할 수 있었습니다. 그 결과 프론트엔드는 정적 자산을 CDN에 배포하고 필요한 기능만 API 호출로 연결하는 패턴(JAMstack)의 토대가 되었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2014-html5">
			<article class="event-detail" aria-labelledby="event-2014-html5-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2014</p>
					<h2 id="event-2014-html5-title">HTML5 최종 권고</h2>
					<p class="event-detail__summary">W3C가 HTML5를 권고안으로 발표하며 비디오, 캔버스, 오프라인 저장소 등 브라우저 내장 기능이 정식 표준이 되었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>2014년 10월, W3C는 HTML5 권고안을 발표하며 “플러그인 없이 웹에서 멀티미디어를 구현하세요.”라는 메시지를 전했습니다. 브라우저는 <code>&lt;video&gt;</code>, <code>&lt;canvas&gt;</code>, <code>localStorage</code> 같은 기능을 기본으로 탑재했습니다.</p>
						<p>개발자들은 워크숍에서 HTML5 기반 게임과 교육 콘텐츠를 시연했고, 기업들은 플래시에서 벗어나기 위한 마이그레이션 계획을 세웠습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>HTML5는 웹 플랫폼을 운영체제에 준하는 런타임으로 끌어올렸습니다. 프론트엔드는 비디오 스트리밍, 그래픽, 오프라인 UX를 직접 구현했고, 백엔드는 REST·스트리밍 API, 콘텐츠 보호, 적응형 비트레이트 제공 같은 서비스를 준비해야 했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2015-http2">
			<article class="event-detail" aria-labelledby="event-2015-http2-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2015</p>
					<h2 id="event-2015-http2-title">HTTP/2 표준 채택</h2>
					<p class="event-detail__summary">SPDY 경험을 바탕으로 멀티플렉싱과 헤더 압축을 포함한 HTTP/2가 표준이 되어 프론트·백엔드 성능 협업 방식이 바뀌었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>IETF는 2015년 5월 RFC 7540을 게시하며 “HTTP/1.1의 순차 요청 병목을 해소하자”고 선언했습니다. 구글 크롬과 파이어폭스는 며칠 만에 자동 업데이트로 HTTP/2를 활성화했습니다.</p>
						<p>트래픽이 많은 서비스들은 새 프로토콜로 전환하며 “이미지 스프라이트와 도메인 샤딩을 더 이상 강제로 하지 않아도 된다”고 말했습니다. 서버팀은 gRPC와 같은 바이너리 프로토콜을 실험하며 API 설계 폭을 넓혔습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>HTTP/2는 <strong>스트림 멀티플렉싱</strong>, <strong>헤더 압축(HPACK)</strong>, <strong>서버 푸시</strong>를 도입했습니다. 프론트엔드는 번들 전략을 새로 짜며 코드 스플리팅에 집중했고, 백엔드는 TLS 최적화와 프로토콜 협상을 다루는 인프라 역할을 강화했습니다. 이는 이후 HTTP/3와 QUIC으로 이어졌습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2015-graphql">
			<article class="event-detail" aria-labelledby="event-2015-graphql-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2015</p>
					<h2 id="event-2015-graphql-title">GraphQL 공개</h2>
					<p class="event-detail__summary">페이스북이 “클라이언트가 필요한 데이터 구조를 직접 선언하자”라는 새로운 API 방식을 오픈소스로 내놓았습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>React Europe 2015에서 페이스북 엔지니어는 뉴스피드 앱 시연을 보여 주며 “모바일에서는 데이터가 너무 많이 오고, 웹에서는 너무 적게 오네요.”라는 문제를 지적했습니다. GraphQL 쿼리를 작성해 필요한 필드만 요청하자, 동일한 엔드포인트에서 각 기기가 원하는 데이터만 받아갔습니다.</p>
						<p>공개 직후 핀터레스트, 깃허브 같은 서비스가 GraphQL API를 도입했습니다. 프론트엔드 팀은 “기능을 만들 때마다 새 REST 엔드포인트를 기다리지 않아도 된다.”며 백엔드 팀과의 협업이 빨라졌다고 밝혔습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>GraphQL은 단일 엔드포인트에서 <strong>스키마</strong>로 데이터 타입을 정의하고, 클라이언트가 필요한 데이터 구조를 선언형 쿼리로 요청하게 합니다. 덕분에 프론트엔드는 화면에 필요한 조각을 스스로 조합할 수 있고, 백엔드는 리졸버를 통해 데이터 출처를 관리합니다. 이는 API 설계가 “리소스 중심”에서 “그래프 중심”으로 이동했음을 의미하며, BFF(Backend for Frontend) 패턴과 API 게이트웨이 설계에도 영향을 주었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2015-lets-encrypt">
			<article class="event-detail" aria-labelledby="event-2015-lets-encrypt-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2015</p>
					<h2 id="event-2015-lets-encrypt-title">Let’s Encrypt 런칭</h2>
					<p class="event-detail__summary">비영리 인증기관 Let’s Encrypt가 등장하며 HTTPS 발급과 갱신이 자동화되어 웹 전반이 암호화를 기본값으로 삼게 되었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>2015년 12월, ISRG는 “무료 자동화된 인증서”를 내세운 Let’s Encrypt 베타를 열었습니다. <code>certbot</code> 명령을 실행하자 몇 초 만에 TLS 인증서가 발급·설치되었습니다.</p>
						<p>몇 달 뒤 브라우저는 HTTP 페이지에 “Not Secure” 경고를 표시했고, 호스팅 업체는 기본 옵션으로 HTTPS를 제공하기 시작했습니다. 개발 팀은 자동 갱신을 CI/CD 파이프라인에 통합했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>HTTPS 기본화는 프론트엔드가 서비스 워커, PWA, WebAuthn처럼 보안 연결을 전제로 하는 기능을 자유롭게 활용할 수 있게 했습니다. 백엔드는 TLS 자동화, HSTS, CSP를 관리하며 보안 계층을 운영의 필수 요소로 만들었습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2016-pwa">
			<article class="event-detail" aria-labelledby="event-2016-pwa-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2016</p>
					<h2 id="event-2016-pwa-title">PWA 권장 아키텍처</h2>
					<p class="event-detail__summary">서비스 워커와 앱 매니페스트를 묶은 PWA 가이드가 제시되면서 웹앱이 네이티브와 경쟁할 준비를 갖췄습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Google I/O 2016에서 알렉스 러셀은 “웹도 오프라인에서 작동하고 푸시 알림을 보낼 수 있습니다.”라며 Progressive Web Apps 체크리스트를 공개했습니다. 시연 중 크롬 홈 화면에 트위터 라이트 아이콘이 추가되자 관객이 환호했습니다.</p>
						<p>개발팀은 <code>serviceWorker.register()</code> 호출과 <code>manifest.json</code>만으로 설치 가능한 웹앱을 배포했고, 대형 커머스 서비스는 PWA 전환 후 전환율이 개선됐다고 보고했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>PWA는 <strong>서비스 워커</strong>, <strong>오프라인 캐시</strong>, <strong>푸시 알림</strong>을 묶어 프론트엔드가 앱 쉘 패턴을 구현하도록 이끌었습니다. 백엔드는 백그라운드 동기화와 푸시 토큰 관리 API를 제공하며, 모바일·데스크톱을 아우르는 사용자 경험 요구에 맞춰 인프라를 재정비했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2017-webassembly">
			<article class="event-detail" aria-labelledby="event-2017-webassembly-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2017</p>
					<h2 id="event-2017-webassembly-title">WebAssembly MVP 완료</h2>
					<p class="event-detail__summary">브라우저 벤더가 공동으로 WebAssembly MVP를 발표하며 웹이 컴파일 언어 런타임을 품게 되었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>2017년 3월, 주요 브라우저 엔진 팀은 “오늘부터 WebAssembly가 기본으로 켜집니다.”라고 공동 블로그 포스트를 올렸습니다. 시연 영상에서는 C++로 작성된 게임이 브라우저에서 네이티브에 가까운 속도로 실행되었습니다.</p>
						<p>핀테크와 CAD 업체는 계산 집약적인 모듈을 포팅했고, 오디오·비디오 편집 스타트업은 WebAssembly 기반 프로토타입을 공개했습니다. 프론트엔드는 자바스크립트와 WebAssembly 모듈을 함께 번들링하는 전략을 실험했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>WebAssembly는 <strong>바이너리 포맷</strong>과 <strong>샌드박스 실행</strong>을 제공해 백엔드에서 쓰던 언어를 프론트엔드로 가져올 수 있게 했습니다. 백엔드는 CPU 집약 기능을 클라이언트로 이전하거나, BFF를 통해 필요한 데이터만 전달하는 구조를 설계하며 작업 부하를 재배치했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2017-cloudflare-workers">
			<article class="event-detail" aria-labelledby="event-2017-cloudflare-workers-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2017</p>
					<h2 id="event-2017-cloudflare-workers-title">Cloudflare Workers 출시</h2>
					<p class="event-detail__summary">CDN 엣지에서 자바스크립트를 실행하는 Workers가 출시되며 “사용자 가까운 런타임”이 보편화되었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>Cloudflare는 Recurse Center에서 열린 프레스 브리핑에서 “글로벌 네트워크 어디서든 10ms 안에 코드를 실행하세요.”라며 Workers 베타를 소개했습니다. 개발자는 몇 줄의 자바스크립트를 배포해 A/B 테스트, 사용자 지정 라우팅, 이미지 변환을 실행했습니다.</p>
						<p>이후 Vercel, Netlify도 유사한 엣지 함수 플랫폼을 출시했고, 제품팀은 “정적 배포 + 엣지 + 서버리스”라는 삼단 구성을 채택했습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>엣지 런타임은 백엔드가 중앙 데이터베이스와 API를 유지하면서도 지연시간이 중요한 로직을 사용자 가까이로 분산할 수 있게 했습니다. 프론트엔드는 엣지에서 실행되는 미들웨어를 활용해 맞춤 렌더링, 인증, 국제화를 빠르게 처리했습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<template id="event-2020-jamstack">
			<article class="event-detail" aria-labelledby="event-2020-jamstack-title">
				<header class="event-detail__header">
					<p class="event-detail__year">2020</p>
					<h2 id="event-2020-jamstack-title">JAMstack와 엣지 함수 확산</h2>
					<p class="event-detail__summary">정적 빌드, CDN 배포, API 조합이 기본 옵션이 되면서 프론트엔드와 백엔드가 느슨하게 결합된 구조가 대중화되었습니다.</p>
				</header>
				<section class="event-detail__body">
					<div class="event-detail__story">
						<p>제품팀은 Netlify, Vercel 같은 플랫폼에 리포지토리를 연결하고 “main에 머지하면 자동으로 배포됩니다.”라는 알림을 받았습니다. 프론트엔드는 정적 파일로 빌드되어 전 세계 CDN에 퍼지고, 필요한 데이터는 API나 서버리스 함수에서 가져왔습니다.</p>
						<p>엣지 함수가 등장하면서 개발자들은 사용자 위치에 따라 맞춤 콘텐츠를 적용했습니다. “서울 사용자는 이 배너를, 뉴욕 사용자는 저 배너를 보여 줘.” 같은 요구가 코드 몇 줄로 가능해졌습니다.</p>
					</div>
					<div class="event-detail__notes">
						<p>JAMstack은 <strong>JavaScript</strong>, <strong>API</strong>, <strong>Markup</strong>의 조합을 강조하며 프론트엔드와 백엔드를 분리 배포하는 방식을 표준처럼 만들었습니다. 백엔드는 인증, 데이터, 비즈니스 로직을 API 형태로 제공하고, 프론트엔드는 정적 자산과 런타임 로직을 맡아 빠른 배포와 확장성을 누릴 수 있게 되었습니다. 이는 마이크로서비스, 엣지 컴퓨팅, 서버리스 워크플로로 이어지고 있습니다.</p>
					</div>
				</section>
			</article>
		</template>

		<script src="assets/js/main.js" defer></script>
	</body>
</html>
